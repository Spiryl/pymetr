# Project Source Code Collection
# Generated: 2025-02-24 16:12:49.833195
# Root Directory: C:\Users\rsmith\Documents\GitHub\pymetr


================================================================================
*** setup.py ***
### setup.py ###
================================================================================

from setuptools import setup, find_packages

setup(
    # Basic info
    name='PyMetr',
    version='0.1.0',
    author='Ryan.C.Smith',
    author_email='bellstate@gmail.com',

    # A short description of the project
    description='A comprehensive Python library for connecting, controlling, and managing test and measurement instruments.',
    
    # A long description, can be the same as your GitHub README.md
    long_description=open('README.md').read(),
    long_description_content_type='text/markdown',  # This is important to render markdown correctly on PyPI

    # The project's main homepage.
    url='https://github.com/pymetr/pymetr',

    # Find all packages in the project
    packages=find_packages(),

    # What does your project relate to?
    keywords='instrumentation control SCPI test measurement plotting real-time data',
)



================================================================================
*** __main__.py ***
### src/pymetr/__main__.py ###
================================================================================

import sys
import logging
from pathlib import Path
from PySide6.QtWidgets import QApplication
from PySide6.QtCore import Qt, QCoreApplication, QFile, QTextStream

from pymetr.ui.views.main_window import MainWindow
from pymetr.core.state import ApplicationState
from pymetr.core.logging import setup_logging

def main():
    """Application entry point."""
    # Setup logging
    setup_logging()
    logger = logging.getLogger(__name__)
    logger.info("Starting PyMetr")
    
    # Create application
    # QCoreApplication.setAttribute(Qt.AA_EnableHighDpiScaling)
    # QCoreApplication.setAttribute(Qt.AA_UseHighDpiPixmaps)
    app = QApplication(sys.argv)
    app.setApplicationName("PyMetr")
    app.setOrganizationName("PyMetr")
    
    # Set application style
    app.setStyle("Fusion")

    style_path = Path(__file__).parent / "core" / "styles.qss"
    styleSheetFile = QFile(str(style_path))
    if styleSheetFile.open(QFile.ReadOnly | QFile.Text):
        textStream = QTextStream(styleSheetFile)
        app.setStyleSheet(textStream.readAll())

    try:
        # Create state and set it as the global state.
        state = ApplicationState()
        
        # Create and show main window
        window = MainWindow(state)
        window.show()
        
        # Handle command line arguments
        if len(sys.argv) > 1:
            script_path = Path(sys.argv[1])
            if script_path.exists() and script_path.suffix == '.py':
                state.open_script(script_path)
        
        # Start event loop
        return app.exec()
        
    except Exception as e:
        logger.exception("Fatal error during startup")
        return 1

if __name__ == '__main__':
    sys.exit(main())



================================================================================
*** actions.py ***
### src/pymetr/core/actions.py ###
================================================================================

# Start of C:/Users/rsmith/Documents/GitHub/pymetr/src/pymetr/core/actions.py
from dataclasses import dataclass, field
from enum import Enum, auto
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import Dict, Any, Optional, Callable
from pathlib import Path
from PySide6.QtWidgets import QMessageBox

from pymetr.models.test import TestSuite
from pymetr.services.script import ScriptService
from pymetr.services.file_services import FileService
from pymetr.core.logging import logger

class ActionCategory(Enum):
    """Categories for ribbon actions."""
    FILE = auto()
    EDIT = auto()
    RUN = auto()
    ANALYZE = auto()
    PLOT = auto()
    DATA = auto()
    INSTRUMENT = auto()
    WINDOW = auto()
    OPTIONS = auto()
    REPORT = auto()

@dataclass
class MenuItem:
    """Menu item configuration."""
    text: str
    icon: str
    handler: Callable
    tooltip: str = ""

@dataclass
class Action:
    """Base action configuration."""
    id: str
    name: str
    category: ActionCategory
    icon: str
    handler: Callable
    tooltip: str = ""
    menu_items: Dict[str, MenuItem] = field(default_factory=dict)
    enabled: bool = True
    visible: bool = True
    shortcut: str = ""
    
    def can_execute(self, state) -> bool:
        """Check if action can be executed."""
        return self.enabled

class FileActions:
    """File-related actions coordinator."""

    @staticmethod
    def new_suite(state) -> None:
        """Create a new empty test suite."""
        try:
            from pymetr.models.test import TestSuite
            # Create basic suite with just a name
            suite = state.create_model(TestSuite, name="New Test Suite")
            state.set_active_model(suite.id)
            logger.debug(f"Created new test suite with ID: {suite.id}")
            
            # Could add a default test script folder here if desired:
            # script_group = state.create_model(TestGroup, name="Scripts")
            # state.link_models(suite.id, script_group.id)
            
        except Exception as e:
            logger.error(f"Error creating test suite: {e}")
            parent = getattr(state, '_parent', None)
            if parent:
                QMessageBox.critical(parent, "Error", f"Failed to create test suite: {e}")

    @staticmethod
    def open_suite(state) -> None:
        """Open an existing test suite."""
        parent = getattr(state, '_parent', None)
        success, path, error = FileService.open_suite(parent)
        
        if success and path:
            try:
                suite_id = FileService.import_model_data(path, state)
                if suite_id:
                    state.set_active_model(suite_id)
                    logger.debug(f"Opened test suite from {path}")
            except Exception as e:
                logger.error(f"Error opening suite: {e}")
                if parent:
                    QMessageBox.critical(parent, "Error", f"Failed to open suite: {e}")
        elif error and parent:
            QMessageBox.critical(parent, "Error", f"Failed to open suite: {error}")

    @staticmethod
    def save_suite(state) -> None:
        """Save current test suite."""
        model = state.get_active_model()
        if model and isinstance(model, TestSuite):
            parent = getattr(state, '_parent', None)
            success, path, error = FileService.save_suite(model, parent)
            
            if not success and error and parent:
                QMessageBox.critical(parent, "Error", f"Failed to save suite: {error}")

    @staticmethod 
    def add_script_to_suite(state, suite_id: str) -> None:
        """Add an existing script to a suite."""
        try:
            # Let user select a script file
            parent = getattr(state, '_parent', None)
            success, path, error = ScriptService.open_script(parent)
            
            if success and path:
                from pymetr.models.test import TestScript
                # Create script model
                script = state.create_model(TestScript, script_path=path)
                script.set_property('name', path.stem)
                
                # Link to suite
                state.link_models(suite_id, script.id)
                logger.debug(f"Added script {script.id} to suite {suite_id}")
                
        except Exception as e:
            logger.error(f"Error adding script to suite: {e}")
            if parent:
                QMessageBox.critical(parent, "Error", f"Failed to add script: {e}")

    @staticmethod
    def new_script(state) -> None:
        """Coordinate script creation between service and state."""
        logger.debug("FileActions: Creating new script")
        parent = getattr(state, '_parent', None)
        logger.debug(f"FileActions: Parent widget exists: {parent is not None}")
        
        success, path, error = ScriptService.create_script(parent)
        logger.debug(f"FileActions: Service result - success: {success}, path: {path}, error: {error}")
        
        if success and path:
            try:
                # Import here to avoid circular import
                from pymetr.models.test import TestScript
                logger.debug("FileActions: Creating script model")
                
                # Create script model in state
                script = state.create_model(TestScript, script_path=path)
                script_name = path.stem
                script.set_property('name', script_name)
                state.set_active_model(script.id)
                logger.debug(f"FileActions: Script model created with ID: {script.id}, name: {script_name}")
            except Exception as e:
                logger.error(f"FileActions: Error creating script model: {e}")
                if parent:
                    QMessageBox.critical(parent, "Error", f"Failed to create script model: {e}")
        elif error and parent:
            logger.error(f"FileActions: Failed to create script: {error}")
            QMessageBox.critical(parent, "Error", f"Failed to create script: {error}")
            
    @staticmethod
    def open_script(state) -> None:
        """Coordinate script opening between service and state."""
        logger.debug("FileActions: Opening script")
        parent = getattr(state, '_parent', None)
        logger.debug(f"FileActions: Parent widget exists: {parent is not None}")
        
        success, path, error = ScriptService.open_script(parent)
        logger.debug(f"FileActions: Service result - success: {success}, path: {path}, error: {error}")
        
        if success and path:
            try:
                from pymetr.models.test import TestScript
                logger.debug("FileActions: Creating script model")
                
                # Add more detailed logging
                logger.debug(f"FileActions: Attempting to create model with path: {path}")
                
                # Create script model in state
                try:
                    script = state.create_model(TestScript, script_path=path)
                    logger.debug(f"FileActions: Script model created successfully")
                except Exception as e:
                    logger.error(f"FileActions: IMMEDIATE create_model error: {type(e).__name__} - {e}")
                    raise
                
                script_name = path.stem
                script.set_property('name', script_name)
                state.set_active_model(script.id)
                logger.debug(f"FileActions: Script model created with ID: {script.id}, name: {script_name}")
            except Exception as e:
                logger.error(f"FileActions: FULL Error creating script model: {type(e).__name__} - {e}")
                import traceback
                logger.error(traceback.format_exc())
                if parent:
                    QMessageBox.critical(parent, "Error", f"Failed to create script model: {e}")
            
    @staticmethod
    def save_script(state) -> None:
        """Coordinate script saving."""
        model = state.get_active_model()
        if model and hasattr(model, 'save'):
            try:
                model.save()
                logger.debug("FileActions: Script saved successfully")
            except Exception as e:
                logger.error(f"FileActions: Failed to save script: {e}")
                parent = getattr(state, '_parent', None)
                if parent:
                    QMessageBox.critical(parent, "Error", f"Failed to save script: {e}")

class RunActions:
    """Script execution actions."""
    
    @staticmethod
    def run_script(state) -> None:
        """Run current script using the Engine."""
        model = state.get_active_model()
        if model and hasattr(model, 'script_path'):
            try:
                logger.debug(f"RunActions: Running script for model {model.id}")
                # Use the engine stored on the state to run the test script.
                state.engine.run_test_script(model.script_path)
            except Exception as e:
                logger.error(f"RunActions: Error running script: {e}")
                parent = getattr(state, '_parent', None)
                if parent:
                    QMessageBox.critical(parent, "Error", f"Failed to run script: {e}")
            
    @staticmethod
    def stop_script(state) -> None:
        """Stop current script using the Engine."""
        try:
            if state.engine and state.engine.script_runner is not None:
                logger.debug("RunActions: Stopping script")
                state.engine.script_runner.stop()
            else:
                logger.debug("RunActions: No active script runner found to stop")
        except Exception as e:
            logger.error(f"RunActions: Error stopping script: {e}")
            parent = getattr(state, '_parent', None)
            if parent:
                QMessageBox.critical(parent, "Error", f"Failed to stop script: {e}")

class InstrumentActions:
    """Instrument-related actions."""
    
    @staticmethod
    def discover_instruments(state) -> None:
        """Open instrument discovery dialog or view."""
        logger.debug("InstrumentActions: Initiating instrument discovery")
        parent = getattr(state, '_parent', None)
        
        try:
            if not parent:
                # No parent window - just do discovery
                state.discover_instruments()
                return
                
            from pymetr.ui.views.discovery_view import DiscoveryDialog
            dialog = DiscoveryDialog(state, parent)
            
            if dialog.exec_():
                # User selected an instrument
                info = dialog.result_info
                if info:
                    state.connect_instrument(info)
                    
        except Exception as e:
            logger.error(f"Error in discover_instruments: {e}")
            if parent:
                QMessageBox.critical(
                    parent,
                    "Discovery Error",
                    f"Failed to start discovery: {str(e)}"
                )

# Define standard actions
STANDARD_ACTIONS = {
    # File actions
    'new_suite': Action(
        id='new_suite',
        name='New Suite',
        category=ActionCategory.FILE,
        icon='new_suite.png',
        handler=FileActions.new_suite
    ),
    'open_suite': Action(
        id='open_suite',
        name='Open Suite',
        category=ActionCategory.FILE,
        icon='open_suite.png',
        handler=FileActions.open_suite
    ),
    'save_suite': Action(
        id='save_suite',
        name='Save Suite',
        category=ActionCategory.FILE,
        icon='save.png',
        handler=FileActions.save_suite
    ),
    'new_script': Action(
        id='new_script',
        name='New',
        category=ActionCategory.FILE,
        icon='new.png',
        handler=FileActions.new_script,
        menu_items={
            'script': MenuItem('New Script', 'new_script.png', FileActions.new_script),
            'suite': MenuItem('New Suite', 'new_suite.png', lambda s: None)
        }
    ),
    'open_script': Action(
        id='open_script',
        name='Open',
        category=ActionCategory.FILE,
        icon='open.png',
        handler=FileActions.open_script,
        menu_items={
            'script': MenuItem('Open Script', 'open_script.png', FileActions.open_script),
            'suite': MenuItem('Open Suite', 'open_suite.png', lambda s: None)
        }
    ),
    'save_script': Action(
        id='save_script',
        name='Save',
        category=ActionCategory.FILE,
        icon='save.png',
        handler=FileActions.save_script
    ),
    
    # Run actions
    'run_script': Action(
        id='run_script',
        name='Run',
        category=ActionCategory.RUN,
        icon='run.png',
        handler=RunActions.run_script
    ),
    'stop_script': Action(
        id='stop_script',
        name='Stop',
        category=ActionCategory.RUN,
        icon='stop.png',
        handler=RunActions.stop_script,
        enabled=False
    ),
    
    # Instrument actions
    'discover_instruments': Action(
        id='discover_instruments',
        name='Connect',
        category=ActionCategory.INSTRUMENT,
        icon='instruments.png',
        handler=InstrumentActions.discover_instruments
    )
}
# End of C:/Users/rsmith/Documents/GitHub/pymetr/src/pymetr/core/actions.py



================================================================================
*** context.py ***
### src/pymetr/core/context.py ###
================================================================================

from typing import Optional, List
from datetime import datetime
from pymetr.core.logging import logger
from pymetr.models.test import TestScript, TestStatus, TestResult,  ResultStatus, TestGroup
from pymetr.models.plot import Plot
from pymetr.models.trace import Trace
from pymetr.models.marker import Marker
from pymetr.models.cursor import Cursor
from pymetr.models.table import DataTable
from pymetr.core.visitor import InstrumentVisitor
    
class TestContext:
    """
    Context object provided to test scripts, encapsulating all allowed operations
    and maintaining script state.
    """
    def __init__(self, script: TestScript, engine):
        self.script = script
        self._engine = engine
        self._state = engine.state
        self.start_time = datetime.now()
        
        # Initialize script status
        self.script.set_property('status', TestStatus.READY)
        self.script.set_property('progress', 0.0)
        
    @property
    def progress(self) -> float:
        """Get current progress."""
        return self.script.get_property('progress', 0.0)
    
    @progress.setter
    def progress(self, value: float):
        """
        Set direct script progress. This will be averaged with result progress
        if results exist.
        """
        value = max(0.0, min(100.0, float(value)))
        self.script.set_property('progress', value)
        
        # If no results exist, this is the only progress
        if not self._get_test_results():
            return
            
        # Otherwise, trigger progress aggregation
        self._update_aggregate_progress()

    @property
    def status(self) -> TestStatus:
        """Get current test status."""
        status_str = self.script.get_property('status', TestStatus.READY.name)
        return TestStatus[status_str]

    @status.setter
    def status(self, value: TestStatus):
        """Set test status."""
        if isinstance(value, str):
            value = TestStatus[value.upper()]
        self.script.set_property('status', value.name)

    @property
    def elapsed_time(self) -> float:
        """Get elapsed time in seconds."""
        return (datetime.now() - self.start_time).total_seconds()
    
    def create_result(self, name: str) -> TestResult:
        """Create a test result with progress tracking."""
        result = self._state.create_model(TestResult, name=name)
        self._state.link_models(self.script.id, result.id)
        
        # Initialize result properties
        result.set_property('status', None)  # Not reported yet
        result.set_property('progress', 0.0)
        
        self._update_aggregate_progress()
        
        return result
    
    def create_group(self, name: str) -> TestGroup:
        """Create a result group for organizing results."""
        group = self._state.create_model(TestGroup, name=name)
        self._state.link_models(self.script.id, group.id)
        return group
    
    def create_plot(self, title: str) -> Plot:
        """Create a plot linked to this test."""
        plot = self._state.create_model(Plot, title=title)
        self._state.link_models(self.script.id, plot.id)
        return plot
    
    def create_trace(self, name: str, x_data, y_data=None, **kwargs) -> Trace:
        """
        Create a trace linked to this test.
        If y_data is None and x_data is a tuple of two arrays, then unpack them.
        """
        if y_data is None and isinstance(x_data, tuple) and len(x_data) == 2:
            x_data, y_data = x_data
        trace = self._state.create_model(Trace, name=name, x_data=x_data, y_data=y_data, **kwargs)
        self._state.link_models(self.script.id, trace.id)
        return trace
    
    def create_table(self, title: str) -> DataTable:
        """Create a table linked to this test."""
        table = self._state.create_model(DataTable, title=title)
        self._state.link_models(self.script.id, table.id)
        return table

    def create_marker(self, name: str, **kwargs) -> Marker:
        """Create a marker linked to this test."""
        marker = self._state.create_model(Marker, name=name, **kwargs)
        self._state.link_models(self.script.id, marker.id)
        return marker

    def create_cursor(self, name: str, **kwargs) -> Cursor:
        """Create a cursor linked to this test."""
        cursor = self._state.create_model(Cursor, name=name, **kwargs)
        self._state.link_models(self.script.id, cursor.id)
        return cursor

    def get_result(self, name: str) -> Optional[TestResult]:
        """Find a result by name."""
        for model in self._state.get_children(self.script.id):
            if isinstance(model, TestResult) and model.get_property('name') == name:
                return model
        return None

    def get_plot(self, title: str) -> Optional[Plot]:
        """Find a plot by title."""
        for model in self._state.get_children(self.script.id):
            if isinstance(model, Plot) and model.get_property('title') == title:
                return model
        return None

    def wait(self, milliseconds: int):
        """Wait without blocking GUI."""
        self._engine.wait(milliseconds)

    # Internal methods
    def _get_test_results(self) -> List[TestResult]:
        """Get all test results created by this script."""
        return [
            model for model in self._state.get_children(self.script.id)
            if isinstance(model, TestResult)
        ]
    
    def _determine_final_status(self) -> TestStatus:
        """Determine final script status based on results."""
        results = self._get_test_results()
        
        if not results:
            return TestStatus.COMPLETE
            
        # Check all result statuses
        has_fails = any(
            result.get_property('status') == ResultStatus.FAIL.name
            for result in results
        )
        
        if has_fails:
            return TestStatus.FAIL
            
        return TestStatus.PASS
    
    def _update_aggregate_progress(self):
        """
        Update script progress based on results.
        Averages progress of all results, or uses script's direct progress
        if no results exist.
        """
        results = self._get_test_results()
        if not results:
            return  # Keep current script progress
            
        # Calculate average progress from all results
        total_progress = sum(
            result.get_property('progress', 0.0)
            for result in results
        )
        avg_progress = total_progress / len(results)
        
        # Update script progress
        self.script.set_property('progress', avg_progress)
    
    def on_script_start(self):
        """Called by engine when script starts."""
        self.script.set_property('status', TestStatus.RUNNING)
        self.start_time = datetime.now()
    
    def on_script_error(self, error: Exception):
        """Called by engine on script error."""
        self.script.set_property('status', TestStatus.ERROR)
        self.script.set_property('error', str(error))
    
    def on_script_complete(self):
        """Called by engine when script finishes."""
        try:
            final_status = self._determine_final_status()
            self.script.set_property('status', final_status)
            self.script.set_property('progress', 100.0)
        except Exception as e:
            logger.error(f"Error determining final status: {e}")
            self.script.set_property('status', TestStatus.ERROR)
            self.script.set_property('error', str(e))
    
    # Add methods for the script engine context
    @classmethod
    def get_instrument(cls, model: str, state=None):
        """
        Factory method to create and register a new instrument instance.
        Used by the script engine context.
        """
        # Create device instance
        device = cls(model=model, state=state)
        
        # Load driver and build parameter tree
        visitor = InstrumentVisitor()
        driver_info = visitor.create_instrument_data_from_driver(f"drivers/{model}.py")
        device.set_driver_info(driver_info)
        
        # Connect and return
        device.connect()
        return device


================================================================================
*** engine.py ***
### src/pymetr/core/engine.py ###
================================================================================

# engine.py
from PySide6.QtCore import QObject, Signal, QThread, QTimer, QEventLoop
from datetime import datetime
from pathlib import Path
import importlib.util
import sys
import traceback
from typing import Optional
import numpy as np
import pandas as pd

from .context import TestContext
from pymetr.models import *
from pymetr.core.logging import logger

class SuiteRunner(QObject):
    """
    Handles test suite execution using run configurations.
    """
    suite_started = Signal(str)          # suite_id
    suite_completed = Signal(str, bool)  # suite_id, success
    suite_error = Signal(str, str)       # suite_id, error_msg
    script_queued = Signal(str, str)     # suite_id, script_name
    
    def __init__(self, engine):
        super().__init__()
        self._engine = engine
        self._state = engine.state
        self._current_suite = None
        self._current_config = None
        self._running = False
        self._script_queue = []
        
        # Connect to engine script signals
        self._engine.script_finished.connect(self._handle_script_completed)
    
    def run_suite(self, suite_id: str):
        """Start suite execution with active run configuration."""
        if self._running:
            logger.warning("Suite already running")
            return
            
        suite = self._state.get_model(suite_id)
        if not isinstance(suite, TestSuite):
            logger.error(f"Model {suite_id} is not a TestSuite")
            return
            
        # Get active config
        active_config_name = suite.get_property('active_config')
        config = None
        
        if active_config_name:
            # Find config by name
            for cfg in suite.get_run_configs():
                if cfg.get_property('name') == active_config_name:
                    config = cfg
                    break
        
        if not config:
            # Fallback to default config
            config = suite.get_default_config()
            if not config:
                self._handle_error("No valid run configuration found")
                return
        
        self._current_suite = suite
        self._current_config = config
        self._running = True
        
        try:
            # Build execution queue from config
            self._script_queue = config.get_execution_order()
            for script_id in self._script_queue:
                script = self._state.get_model(script_id)
                if script:
                    self.script_queued.emit(suite_id, script.get_property('name', ''))
            
            # Start first script
            self._run_next_script()
            
            # Emit started
            self.suite_started.emit(suite_id)
            suite.set_property('status', TestStatus.RUNNING)
            
        except Exception as e:
            self._handle_error(str(e))
    
    def stop_suite(self):
        """Stop current suite execution."""
        if not self._running:
            return
            
        # Stop current script
        if self._engine.script_runner:
            self._engine.script_runner.stop()
        
        self._cleanup()
    
    def _run_next_script(self):
        """Run next script in queue."""
        if not self._script_queue:
            self._handle_suite_complete(True)
            return
            
        script_id = self._script_queue.pop(0)
        try:
            # Get script model
            script = self._state.get_model(script_id)
            if not script:
                raise ValueError(f"Script {script_id} not found")
                
            # Run it
            self._engine.run_test_script(script.id)
            
        except Exception as e:
            self._handle_error(f"Failed to run script {script_id}: {e}")
    
    def _handle_script_completed(self, script_id: str, success: bool, error_msg: str):
        """Handle individual script completion."""
        if not self._running:
            return
            
        script = self._state.get_model(script_id)
        if not script:
            return
            
        if success:
            # Run next script
            self._run_next_script()
        else:
            # Check suite behavior
            behavior = self._current_suite.get_property('failure_behavior', 'stop')
            if behavior == 'stop':
                self._handle_suite_complete(False)
            else:
                # Continue with next script
                self._run_next_script()
    
    def _handle_suite_complete(self, success: bool):
        """Handle suite completion."""
        if self._current_suite:
            # Update suite status
            status = TestStatus.PASS if success else TestStatus.FAIL
            self._current_suite.set_property('status', status)
            
            # Emit completion
            self.suite_completed.emit(self._current_suite.id, success)
        
        self._cleanup()
    
    def _handle_error(self, error_msg: str):
        """Handle suite error."""
        if self._current_suite:
            self._current_suite.set_property('status', TestStatus.ERROR)
            self.suite_error.emit(self._current_suite.id, error_msg)
        
        self._cleanup()
    
    def _cleanup(self):
        """Clean up suite run state."""
        self._running = False
        self._script_queue.clear()
        self._current_suite = None
        self._current_config = None

class ScriptRunner(QThread):
    # Signal: finished(success, error_message)
    finished = Signal(bool, str)
    # Optional error signal: error(error_type, error_msg, traceback)
    error = Signal(str, str, str)
    
    def __init__(self, script_path: Path, globals_dict: dict):
        super().__init__()
        self.script_path = script_path
        self.globals_dict = globals_dict.copy()
        
    def run(self):
        try:
            spec = importlib.util.spec_from_file_location(self.script_path.stem, str(self.script_path))
            if spec is None or spec.loader is None:
                raise ImportError(f"Cannot load script: {self.script_path}")
            module = importlib.util.module_from_spec(spec)
            sys.modules[spec.name] = module
            spec.loader.exec_module(module)
            
            if not hasattr(module, "run_test"):
                raise AttributeError("Script must contain a run_test() function")
                
            # Update the module's globals with our globals_dict
            module.__dict__.update(self.globals_dict)
            
            # Pass the 'test' context to run_test()
            result = module.run_test(self.globals_dict['test'])
            
            # If run_test() does not return a bool, treat it as success
            if not isinstance(result, bool):
                result = True
            self.finished.emit(result, "")
        except Exception as e:
            error_type = type(e).__name__
            error_msg = str(e)
            error_tb = traceback.format_exc()
            logger.error(f"ScriptRunner error: {error_tb}")
            self.error.emit(error_type, error_msg, error_tb)
            self.finished.emit(False, error_msg)
        finally:
            self.globals_dict.clear()
            
    def stop(self):
        self.terminate()
        self.wait()


class Engine(QObject):
    # Signals for script running (active script) events
    script_started = Signal(str)               # Emits the running TestScript's ID
    script_finished = Signal(str, bool, str)     # (script_id, success, error_msg)
    progress_changed = Signal(str, float, str)   # (script_id, percent, message)
    
    def __init__(self, state):
        super().__init__()
        self.state = state
        self.script_runner = None
        self.start_time = None
        
        # Timer to update elapsed time every second while a script is running
        self.elapsed_timer = QTimer(self)
        self.elapsed_timer.setInterval(1000)
        self.elapsed_timer.timeout.connect(self._update_elapsed_time)
        
        # Include numpy and pandas in globals
        self.globals = {
            'np': np,
            'pd': pd,
            'TestStatus': TestStatus,
            'ResultStatus': ResultStatus
        }

        self.state.model_changed.connect(self._handle_model_changed)
        logger.info("Engine initialized.")

    def run_suite(self, suite_id: str):
        """Run a test suite."""
        if not hasattr(self, 'suite_runner'):
            self.suite_runner = SuiteRunner(self)
        self.suite_runner.run_suite(suite_id)

    def stop_suite(self):
        """Stop current suite execution."""
        if hasattr(self, 'suite_runner'):
            self.suite_runner.stop_suite()

    def _handle_model_changed(self, model_id: str, model_type: str, prop: str, value: object):
        """
        Whenever a model changes, if it's a TestResult child of the active script,
        recalc the script's aggregated progress.
        """
        # We only care about progress changes on TestResult
        if model_type == "TestResult" and prop == "progress":
            # See if the top-level parent is a TestScript
            script = self._find_top_level_script(model_id)
            # If the script is the currently active test, recalc progress
            active_test = self.state.get_active_test()
            if script and active_test and script.id == active_test.id:
                self._update_script_progress(script)
    
    def _find_top_level_script(self, model_id: str) -> Optional[TestScript]:
        """
        Climb up the parent chain until we find a TestScript or no parent.
        """
        while True:
            parent = self.state.get_parent(model_id)
            if not parent:
                return None
            if isinstance(parent, TestScript):
                return parent
            model_id = parent.id

    def _update_script_progress(self, script: TestScript):
        """
        Compute average progress across all child TestResults
        and update the script's 'progress' property.
        """
        # Get all child models that are TestResults
        results = [
            child for child in self.state.get_children(script.id)
            if isinstance(child, TestResult)
        ]
        if not results:
            return  # No results => do nothing
        
        total = sum(r.get_property("progress", 0.0) for r in results)
        avg = total / len(results)
        
        script.set_property("progress", avg)

    # ---------------------------------------------------
    # Script Running
    # ---------------------------------------------------

    def run_test_script(self, script_id: str) -> None:
        script = self.state.get_model(script_id)
        if not script or not isinstance(script, TestScript):
            logger.error(f"Engine.run_test_script: No TestScript found with id '{script_id}'")
            return

        # Clear previous child models
        self.state.clear_children(script.id)

        # Make sure the script is "RUNNING" from the start
        script.set_property("status", "RUNNING")
        script.set_property("progress", 0)

        # Create context for this script
        context = TestContext(script, self)

        # Set as active test
        self.state.set_active_test(script_id)

        # Start execution
        context.on_script_start()
        self.script_started.emit(script.id)

        self.script_runner = ScriptRunner(script.script_path, {"test": context})
        self.script_runner.finished.connect(
            lambda success, error: self._on_script_finished(context, success, error)
        )
        self.script_runner.error.connect(
            lambda type_, msg, tb: self._on_script_error(context, type_, msg, tb)
        )
        self.script_runner.start()
    
    def _on_script_finished(self, context: TestContext, success: bool, error_msg: str) -> None:
        """Handle script completion using context."""
        if success:
            context.on_script_complete()
        else:
            context.on_script_error(error_msg)
            
        self.script_finished.emit(context.script.id, success, error_msg)
        self.script_runner = None
    
    def _on_script_error(self, context: TestContext, error_type: str, 
                        error_msg: str, traceback: str) -> None:
        """Handle script errors using context."""
        context.on_script_error(f"{error_type}: {error_msg}")
        logger.error(f"Script error: {traceback}")

    # ---------------------------------------------------
    # Helpers
    # ---------------------------------------------------

    
    def wait(self, milliseconds: int) -> None:
        """
        Helper to 'sleep' in a Qt-friendly way without blocking the GUI event loop
        """
        loop = QEventLoop()
        QTimer.singleShot(milliseconds, loop.quit)
        loop.exec_()
    
    def _update_elapsed_time(self) -> None:
        """
        Update the elapsed_time on the currently active test script
        """
        if not self.start_time:
            return
        test_script = self.state.get_active_test()
        if test_script and isinstance(test_script, TestScript):
            elapsed = (datetime.now() - self.start_time).total_seconds()
            test_script.elapsed_time = int(elapsed)




================================================================================
*** logging.py ***
### src/pymetr/core/logging.py ###
================================================================================

# core/logging.py

import logging
import sys
import os
from pathlib import Path
from datetime import datetime

class CustomFormatter(logging.Formatter):
    def format(self, record):
        # Extract the parent folder name from the full path
        parent_folder = os.path.basename(os.path.dirname(record.pathname))
        # Prepend the parent folder to the filename
        record.filename = f"{parent_folder}/{record.filename}"
        return super().format(record)

def setup_logging(log_to_file: bool = False):
    """Configure application-wide logging with detailed formatting."""
    logger = logging.getLogger('pymetr')
    logger.setLevel(logging.ERROR)

    # Create custom formatter
    formatter = CustomFormatter(
        '%(levelname)-6s:%(lineno)-4d\t%(filename)-36s\t%(funcName)-20s - %(message)s'
    )

    # Console handler
    if not logger.handlers:
        console = logging.StreamHandler(sys.stdout)
        console.setLevel(logging.DEBUG)
        console.setFormatter(formatter)
        logger.addHandler(console)

        # File handler (optional)
        if log_to_file:
            log_dir = Path("logs")
            log_dir.mkdir(exist_ok=True)
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            file_handler = logging.FileHandler(
                log_dir / f"pymetr_{timestamp}.log",
                encoding='utf-8'
            )
            file_handler.setLevel(logging.DEBUG)
            file_handler.setFormatter(formatter)
            logger.addHandler(file_handler)

    return logger

# Initialize logger
logger = setup_logging()



================================================================================
*** registry.py ***
### src/pymetr/core/registry.py ###
================================================================================

"""
Registry for instrument drivers and device management.

This module provides a thread-safe singleton registry that maintains:
- Driver registration and loading
- Connection type information
- Discovery configuration
- Instance tracking
"""

from typing import Dict, Optional, Type, List, Any
import importlib
from enum import Enum, auto
from dataclasses import dataclass
from PySide6.QtCore import QObject, Signal, QThread, Slot, Qt, QMetaObject, Q_ARG

from pymetr.core.logging import logger
from pymetr.drivers.base.connections import ConnectionInterface
from pymetr.models.device import Device

class ConnectionType(Enum):
    """Known connection interface types"""
    VISA = auto()
    SOCKET = auto()
    SERIAL = auto()

@dataclass
class DriverInfo:
    """Driver configuration information"""
    module: str                                      # Driver module path
    class_name: str                                 # Driver class name
    interfaces: List[ConnectionType]                # Supported connection types
    socket_port: Optional[int] = None              # Default socket port if applicable
    discovery_config: Optional[Dict[str, Any]] = None  # Discovery protocol config

class InstrumentRegistry(QObject):
    """
    Thread-safe singleton registry for instrument drivers and instances.
    
    Manages:
    - Driver registration and loading
    - Device model creation
    - Instance tracking
    - Connection configuration
    """
    _instance = None  # Singleton instance
    
    # Signals
    driver_loaded = Signal(str)           # driver_module
    device_created = Signal(str, Device)  # model, device_instance
    driver_created = Signal(str, object)  # model, driver_instance
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
            cls._instance._initialized = False
        return cls._instance
        
    def __init__(self):
        if self._initialized:
            return
            
        super().__init__()
        self._drivers: Dict[str, DriverInfo] = {}         # Model -> Driver info
        self._driver_cache: Dict[str, Type] = {}         # Model -> Driver class
        self._devices: Dict[str, Device] = {}            # ID -> Device model
        self._driver_instances: Dict[str, object] = {}   # ID -> Driver instance
        self._register_builtin_drivers()
        self._initialized = True

    def _register_builtin_drivers(self):
        """Register built-in instrument drivers."""
        self.register_driver(
            "DSOX1204G",
            DriverInfo(
                module="pymetr.drivers.instruments.dsox1204g",
                class_name="DSOX1204G",
                interfaces=[ConnectionType.VISA]
            )
        )
        
        self.register_driver(
            "HS9001B",
            DriverInfo(
                module="pymetr.drivers.instruments.hs9000",
                class_name="HS9000",
                interfaces=[ConnectionType.VISA, ConnectionType.SOCKET],
                socket_port=9760,
                discovery_config={
                    "udp_port": 30303,
                    "protocol": "MICROCHIP"
                }
            )
        )
        
    def register_driver(self, model: str, info: DriverInfo) -> None:
        """Register a new instrument driver."""
        if QThread.currentThread() != self.thread():
            QMetaObject.invokeMethod(
                self,
                "_register_driver_internal",
                Qt.QueuedConnection,
                Q_ARG(str, model),
                Q_ARG(object, info)
            )
        else:
            self._register_driver_internal(model, info)

    @Slot(str, object)
    def _register_driver_internal(self, model: str, info: DriverInfo) -> None:
        """Internal registration that always runs in main thread."""
        self._drivers[model.upper()] = info
        logger.debug(f"Registered driver for {model}")

    def create_device(self, info: Dict[str, Any]) -> Optional[Device]:
        """
        Create a Device model from discovery information.
        
        Args:
            info: Dictionary containing device info from discovery
                 (manufacturer, model, serial, etc.)
        
        Returns:
            Device model or None if creation fails
        """
        try:
            # Create device model
            device = Device.from_discovery_info(info)
            
            # Store device
            self._devices[device.id] = device
            
            # Emit signal
            self.device_created.emit(info['model'], device)
            logger.debug(f"Created device model for {info['model']}")
            
            return device
            
        except Exception as e:
            logger.error(f"Failed to create device model: {e}")
            return None
        
    def get_driver_class(self, model: str) -> Optional[Type]:
        """
        Get driver class for an instrument model.
        Loads driver module if needed.
        
        Args:
            model: Instrument model identifier
            
        Returns:
            Driver class or None if not found
        """
        model = model.upper()
        
        # Return cached driver if available
        if model in self._driver_cache:
            return self._driver_cache[model]
            
        # Get driver info
        info = self._drivers.get(model)
        if not info:
            logger.error(f"No driver registered for {model}")
            return None
            
        try:
            # Import driver module
            module = importlib.import_module(info.module)
            
            # Get driver class
            driver_class = getattr(module, info.class_name)
            
            # Cache for future use
            self._driver_cache[model] = driver_class
            self.driver_loaded.emit(info.module)
            
            return driver_class
            
        except Exception as e:
            logger.error(f"Failed to load driver for {model}: {e}")
            return None

    def create_driver_instance(self, 
                           device: Device,
                           connection: ConnectionInterface,
                           threaded_mode: bool = True) -> Optional[object]:
        """
        Create a driver instance for a device.
        
        Args:
            device: Device model instance
            connection: Connection interface instance
            threaded_mode: Whether to use threaded communication
            
        Returns:
            Driver instance or None if creation fails
        """
        if QThread.currentThread() != self.thread():
            result = None
            QMetaObject.invokeMethod(
                self,
                "_create_driver_internal",
                Qt.BlockingQueuedConnection,
                Q_ARG(Device, device),
                Q_ARG(object, connection),
                Q_ARG(bool, threaded_mode),
                Q_ARG(object, result)
            )
            return result
        else:
            return self._create_driver_internal(device, connection, threaded_mode)

    @Slot(Device, object, bool, object)
    def _create_driver_internal(self, 
                            device: Device,
                            connection: ConnectionInterface,
                            threaded_mode: bool,
                            result: object = None) -> Optional[object]:
        """Internal driver creation that always runs in main thread."""
        driver_class = self.get_driver_class(device.get_property('model'))
        if not driver_class:
            return None
            
        try:
            # Create driver instance
            instance = driver_class(connection, threaded_mode=threaded_mode)
            
            # Store instance
            self._driver_instances[device.id] = instance
            
            self.driver_created.emit(device.get_property('model'), instance)
            logger.debug(f"Created driver instance for device {device.id}")
            
            return instance
            
        except Exception as e:
            logger.error(f"Failed to create driver instance: {e}")
            return None

    def get_supported_interfaces(self, model: str) -> List[ConnectionType]:
        """Get supported connection types for a model."""
        info = self._drivers.get(model.upper())
        return info.interfaces if info else []
        
    def get_discovery_config(self, model: str) -> Optional[Dict[str, Any]]:
        """Get discovery configuration for a model."""
        info = self._drivers.get(model.upper())
        return info.discovery_config if info else None

    def cleanup_device(self, device_id: str) -> None:
        """Clean up a device and its driver instance."""
        if device_id in self._devices:
            del self._devices[device_id]
        if device_id in self._driver_instances:
            del self._driver_instances[device_id]
            
    def get_device(self, device_id: str) -> Optional[Device]:
        """Get a device model by ID."""
        return self._devices.get(device_id)
        
    def get_driver_instance(self, device_id: str) -> Optional[object]:
        """Get a driver instance by device ID."""
        return self._driver_instances.get(device_id)

# Global access function
def get_registry() -> InstrumentRegistry:
    """Get the global instrument registry instance."""
    return InstrumentRegistry()


================================================================================
*** state.py ***
### src/pymetr/core/state.py ###
================================================================================



from typing import Dict, Optional, Type, TypeVar, List, Any
from PySide6.QtCore import QObject, Signal, Slot, QThread, Qt, QMetaObject, Q_ARG, QTimer
from pymetr.models.base import BaseModel
from pymetr.models import Device
from pymetr.core.engine import Engine
from pymetr.core.logging import logger
from pymetr.drivers import Instrument

T = TypeVar('T', bound=BaseModel)


class DiscoveryWorker(QObject):
    """Worker object for performing instrument discovery in a background thread."""
    
    # Signals
    finished = Signal(dict)  # Emits discovered instruments dict
    instrument_found = Signal(dict)  # Emits each instrument as it's found
    error = Signal(str)  # Emits error message if discovery fails

    def __init__(self, model_filter: Optional[List[str]] = None):
        super().__init__()
        self.model_filter = model_filter
        self._running = False
        
    def discover(self):
        """Run discovery process."""
        try:
            logger.debug("Starting discovery in worker thread")
            self._running = True
            
            # Perform discovery
            instruments = Instrument.list_instruments(self.model_filter)
            
            # Emit each instrument as we find it
            for uid, info in instruments.items():
                if not self._running:
                    # Check if we should stop
                    break
                self.instrument_found.emit(info)
            
            if self._running:
                # Only emit finished if we weren't stopped
                self.finished.emit(instruments)
                
        except Exception as e:
            logger.error(f"Error in discovery worker: {e}")
            self.error.emit(str(e))
        finally:
            self._running = False
            
    def stop(self):
        """Stop the discovery process."""
        self._running = False

class ApplicationState(QObject):
    # Signals
    model_registered = Signal(str)           # model_id
    model_changed = Signal(str, str, str, object)          # model_id, model_type, prop_name, value
    models_linked = Signal(str, str)         # parent_id, child_id
    active_model_changed = Signal(str)       # model_id
    active_test_changed = Signal(str)        # model_id
    model_registration_requested = Signal(str, str)  # model_id, model_type_name

    status_changed = Signal(str)  # Basic status message
    status_progress = Signal(float, str)  # Progress updates (percent, message)
    status_error = Signal(str)  # Error messages
    status_warning = Signal(str)  # Warning messages
    status_info = Signal(str)  # Info messages

    model_removed = Signal(str)   # model_id
    model_viewed = Signal(str)  # Emits model_id

    discovery_started = Signal()  # When instrument discovery begins
    discovery_complete = Signal(dict)  # When discovery finishes (with instruments dict)
    instrument_found = Signal(dict)  # When each instrument is found (with instrument info)
    instrument_connected = Signal(str)  # Emits the device ID when an instrument is connected

    def __init__(self):
        super().__init__()
        self._models: Dict[str, BaseModel] = {}
        self._pending_models: Dict[str, BaseModel] = {}
        self._relationships: Dict[str, set[str]] = {}
        self._active_model_id: Optional[str] = None
        self._active_test_id: Optional[str] = None
        self._parent: Optional[QObject] = None
        
        # Update throttling
        self._pending_updates = []
        self._update_timer = QTimer(self)  # Timer created in main thread
        self._update_timer.setSingleShot(True)
        self._update_timer.timeout.connect(self._process_pending_updates)
        self._throttle_interval = 16  # About 60fps

        self._discovered_instruments = {}
        self._discovery_thread = None
        self._discovery_worker = None
        
        self.engine = Engine(self)
        self.model_registration_requested.connect(self._handle_registration_request)
        logger.debug("ApplicationState initialized with Engine.")

    def set_parent(self, parent: QObject):
        """Optionally store a reference to a parent widget for dialogs."""
        self._parent = parent

    def register_model(self, model: BaseModel) -> None:
        """Register a model - keep it simple and in the main thread."""
        if model.id not in self._models:
            # Let the model know its state manager
            model.state = self
            self._models[model.id] = model

            # Connect signals
            model.property_changed.connect(self._handle_model_change)
            model.child_added.connect(self._handle_child_added)

            self.model_registered.emit(model.id)
            logger.debug(f"Registered model {model.id}")

    @Slot(str, str)
    def _handle_registration_request(self, model_id: str, model_type: str) -> None:
        """Handle registration requests from other threads."""
        if model_id in self._pending_models:
            model = self._pending_models.pop(model_id)
            self._register_model_internal(model)
        else:
            logger.error(f"Model {model_id} not found in pending registrations")

    def _register_model_internal(self, model: BaseModel) -> None:
        """Internal registration that always runs in main thread."""
        if model.id not in self._models:
            # Move model to main thread if needed
            if model.thread() != self.thread():
                model.moveToThread(self.thread())

            # Let the model know its state manager
            model.state = self
            self._models[model.id] = model

            # Connect to type-specific signals
            model.property_changed_str.connect(self._handle_model_change)
            model.property_changed_float.connect(self._handle_model_change)
            model.property_changed_int.connect(self._handle_model_change)
            model.property_changed_bool.connect(self._handle_model_change)
            model.child_added.connect(self._handle_child_added)

            self.model_registered.emit(model.id)
            logger.debug(f"Registered model {model.id}")

    def link_models(self, parent_id: str, child_id: str) -> None:
        """
        Create a relationship between models.
        """
        if QThread.currentThread() != self.thread():
            QMetaObject.invokeMethod(
                self,
                "_link_models_internal",
                Qt.QueuedConnection,
                Q_ARG(str, parent_id),
                Q_ARG(str, child_id)
            )
        else:
            self._link_models_internal(parent_id, child_id)

    @Slot(str, str)
    def _link_models_internal(self, parent_id: str, child_id: str) -> None:
        """Internal linking in main thread."""
        # Check if relationship already exists
        if parent_id in self._relationships and child_id in self._relationships[parent_id]:
            logger.debug(f"Relationship already exists between {parent_id} and {child_id}")
            return
            
        if parent_id not in self._relationships:
            self._relationships[parent_id] = set()
        self._relationships[parent_id].add(child_id)
        self.models_linked.emit(parent_id, child_id)
        logger.debug(f"Linked model {child_id} to parent {parent_id}")

    def unlink_models(self, parent_id: str, child_id: str) -> None:
        """Remove a relationship between models."""
        if parent_id in self._relationships:
            self._relationships[parent_id].discard(child_id)
            logger.debug(f"Unlinked model {child_id} from parent {parent_id}")

    def get_model(self, model_id: str) -> Optional[BaseModel]:
        """Get a model by ID."""
        return self._models.get(model_id)

    def get_models_by_type(self, model_type: Type[T]) -> List[T]:
        """Get all models of a specific type."""
        return [
            model for model in self._models.values()
            if isinstance(model, model_type)
        ]

    def get_children(self, parent_id: str) -> List[BaseModel]:
        """Get all child models for a parent."""
        child_ids = self._relationships.get(parent_id, set())
        return [
            self._models[child_id]
            for child_id in child_ids
            if child_id in self._models
        ]

    def get_parent(self, child_id: str) -> Optional[BaseModel]:
        """Get parent model of a child."""
        for parent_id, children in self._relationships.items():
            if child_id in children:
                return self._models.get(parent_id)
        return None

    @Slot(str, str, str, object)
    def _handle_model_change(self, model_id: str, model_type: str, prop: str, value: Any) -> None:
        """Handle property changes."""
        self.model_changed.emit(model_id, model_type, prop, value)

    @Slot(str, str)
    def _handle_child_added(self, parent_id: str, child_id: str) -> None:
        """A model had a child added -> link them."""
        self.link_models(parent_id, child_id)

    def set_active_test(self, model_id: Optional[str]) -> None:
        """Set the currently active test."""
        if model_id != self._active_test_id:
            self._active_test_id = model_id
            self.active_test_changed.emit(model_id)
            logger.debug(f"Active test changed to {model_id}")

    def get_active_test(self) -> Optional[BaseModel]:
        """Get the currently active test."""
        if self._active_test_id:
            return self._models.get(self._active_test_id)
        return None
    
    def set_active_model(self, model_id: Optional[str]) -> None:
        """Set the currently active model."""
        if model_id != self._active_model_id:
            self._active_model_id = model_id
            self.active_model_changed.emit(model_id)
            logger.debug(f"Active model changed to {model_id}")

    def get_model_by_name(self, name: str) -> Optional[BaseModel]:
        """Return the first model with the given humanreadable name."""
        for model in self._models.values():
            if model.get_property("name") == name:
                return model
        return None

    def get_active_model(self) -> Optional[BaseModel]:
        """Get the currently active model."""
        if self._active_model_id:
            return self._models.get(self._active_model_id)
        return None

    def create_model(self, model_class: Type[T], **kwargs) -> T:
        """
        Create and register a new model. (Convenience method)
        """
        model = model_class(**kwargs)
        self.register_model(model)
        return model
    
    def remove_model(self, model_id: str) -> None:
        if model_id in self._models:
            # Remove as child from any parent
            parent = self.get_parent(model_id)
            if parent:
                self.unlink_models(parent.id, model_id)
                    
            # Remove any children it might have
            if model_id in self._relationships:
                child_ids = list(self._relationships[model_id])
                for child_id in child_ids:
                    self.remove_model(child_id)
                del self._relationships[model_id]
                    
            # Remove the model itself
            model = self._models[model_id]
            model.deleteLater()
            del self._models[model_id]
            logger.debug(f"Removed model {model_id}")
            
            # Emit signal so that any views (like tab views or tree views) can update
            self.model_removed.emit(model_id)

    def clear_children(self, parent_id: str) -> None:
        """Remove all child models of the given parent."""
        children = self.get_children(parent_id)
        for child in children:
            self.remove_model(child.id)

    def set_status(self, message: str):
        """Set main status message."""
        self.status_changed.emit(message)
        logger.debug(f"Status: {message}")

    def set_progress(self, percent: float, message: str = ""):
        """Update progress status."""
        self.status_progress.emit(percent, message)
        logger.debug(f"Progress: {percent}% - {message}")

    def set_error(self, message: str):
        """Show error status."""
        self.status_error.emit(message)
        logger.error(f"Error: {message}")

    def set_warning(self, message: str):
        """Show warning status."""
        self.status_warning.emit(message)
        logger.warning(f"Warning: {message}")

    def set_info(self, message: str):
        """Show info status."""
        self.status_info.emit(message)
        logger.info(f"Info: {message}")

    def queue_model_update(self, model_id: str, prop: str, value: Any):
        """Queue a model update to be processed in the main thread."""
        self._pending_updates.append((model_id, prop, value))
        if not self._update_timer.isActive():
            self._update_timer.start(self._throttle_interval)

    def _process_pending_updates(self):
        """Process all pending model updates."""
        if not self._pending_updates:
            return
            
        # Group updates by model
        updates_by_model = {}
        for model_id, model_type, prop, value in self._pending_updates:
            if model_id not in updates_by_model:
                updates_by_model[model_id] = []
            updates_by_model[model_id].append((model_type, prop, value))
            
        # Process updates
        for model_id, updates in updates_by_model.items():
            model = self._models.get(model_id)
            if model:
                for model_type, prop, value in updates:
                    self.model_changed.emit(model_id, model_type, prop, value)
                    
        self._pending_updates.clear()

    def update_active_view(self, model_id: str):
        """Called when a dock is done activating."""
        self.model_viewed.emit(model_id)

    def discover_instruments(self, model_filter: Optional[List[str]] = None):
        """Start instrument discovery process in background thread."""
        logger.debug("Starting instrument discovery")
        self.discovery_started.emit()
        
        # Create worker and thread
        self._discovery_worker = DiscoveryWorker(model_filter)
        self._discovery_thread = QThread()
        
        # Move worker to thread
        self._discovery_worker.moveToThread(self._discovery_thread)
        
        # Connect signals
        self._discovery_thread.started.connect(self._discovery_worker.discover)
        self._discovery_worker.finished.connect(self._handle_discovery_complete)
        self._discovery_worker.instrument_found.connect(self._handle_instrument_found)
        self._discovery_worker.error.connect(self._handle_discovery_error)
        self._discovery_worker.finished.connect(self._discovery_thread.quit)
        self._discovery_thread.finished.connect(self._cleanup_discovery)
        
        # Start the thread
        self._discovery_thread.start()

    def stop_discovery(self):
        """Stop any ongoing discovery process."""
        if self._discovery_worker:
            self._discovery_worker.stop()
        if self._discovery_thread:
            self._discovery_thread.quit()
            self._discovery_thread.wait()
        self._cleanup_discovery()

    def _cleanup_discovery(self):
        """Clean up discovery thread and worker."""
        if self._discovery_thread:
            self._discovery_thread.deleteLater()
            self._discovery_thread = None
        if self._discovery_worker:
            self._discovery_worker.deleteLater()
            self._discovery_worker = None

    def _handle_discovery_complete(self, instruments: Dict):
        """Handle discovery completion."""
        logger.debug(f"Discovery complete, found {len(instruments)} instruments")
        self._discovered_instruments = instruments
        self.discovery_complete.emit(instruments)

    def _handle_instrument_found(self, info: Dict):
        """Handle individual instrument discovery."""
        logger.debug(f"Found instrument: {info.get('model', 'Unknown')}")
        self.instrument_found.emit(info)

    def _handle_discovery_error(self, error: str):
        """Handle discovery error."""
        logger.error(f"Discovery error: {error}")
        self.discovery_complete.emit({})  # Emit empty dict on error

    def get_discovered_instruments(self) -> Dict[str, Dict]:
        """Get the currently discovered instruments."""
        return self._discovered_instruments

    def connect_instrument(self, info: Dict[str, Any]):
        """Connect to an instrument from discovery info."""
        try:
            logger.debug(f"ApplicationState: Creating device from discovery info: {info}")
            
            # Create device with state reference
            device = Device.from_discovery_info(info)
            logger.debug(f"ApplicationState: Created device with ID: {device.id}")
            
            # Register with state BEFORE connecting
            logger.debug("ApplicationState: Registering device with state")
            self.register_model(device)
            
            # Now connect to instrument
            logger.debug("ApplicationState: Connecting device")
            device.connect_device()
            
            logger.info(f"ApplicationState: Successfully created and connected device: {device.id}")
            self.instrument_connected.emit(device.id)
            
            return device
                
        except Exception as e:
            logger.error(f"ApplicationState.connect_instrument error: {e}", exc_info=True)
            raise



================================================================================
*** __init__.py ***
### src/pymetr/drivers/__init__.py ###
================================================================================

from .base.instrument import (
    Instrument, SCPIInstrument, Subsystem
)
from .base.properties import (
    Property, ValueProperty, SwitchProperty, 
    SelectProperty, DataProperty, DataBlockProperty,
    PropertyResponse
)
from .base.connections import (
    ConnectionInterface, PyVisaConnection, RawSocketConnection
)
from .base.sources import Sources


__all__ = [
    # Base instrument classes
    'Instrument',
    'SCPIInstrument',
    'Subsystem',
    
    # Properties
    'Property',
    'PropertyResponse',
    'ValueProperty',
    'SwitchProperty',
    'SelectProperty',
    'DataProperty',
    'DataBlockProperty',
    
    # Connections
    'ConnectionInterface',
    'PyVisaConnection',
    'RawSocketConnection',
    
    # Sources
    'Sources',
]


================================================================================
*** __init__.py ***
### src/pymetr/drivers/base/__init__.py ###
================================================================================

from .instrument import Instrument, SCPIInstrument, Subsystem
from .properties import (
    Property, PropertyResponse, ValueProperty, SwitchProperty,
    SelectProperty, DataProperty, DataBlockProperty
)
from .connections import ConnectionInterface, PyVisaConnection, RawSocketConnection
from .sources import Sources

__all__ = [
    'Instrument', 'SCPIInstrument', 'Subsystem',
    'Property', 'PropertyResponse', 'ValueProperty', 'SwitchProperty',
    'SelectProperty', 'DataProperty', 'DataBlockProperty',
    'ConnectionInterface', 'PyVisaConnection', 'RawSocketConnection',
    'Sources'
]


================================================================================
*** connections.py ***
### src/pymetr/drivers/base/connections.py ###
================================================================================

# connections.py

"""
Defines the abstract base class (interface) for all instrument connections.
Adds support for non-blocking reads and data availability checking.
"""

from abc import ABC, abstractmethod
import logging
import socket
import select
import time
from typing import Optional, Dict, List
import ipaddress
from zeroconf import ServiceBrowser, Zeroconf
import concurrent.futures
import pyvisa
from PySide6.QtWidgets import QApplication

logger = logging.getLogger(__name__)

class ConnectionInterface(ABC):
    """
    An abstract base class representing the low-level connection or transport layer.
    Every specific transport (PyVISA, raw socket, serial, etc.) must implement these methods.
    """

    def __init__(self, read_termination: str = '\n', write_termination: str = '\n', encoding: str = 'ascii'):
        """
        Initialize common connection parameters.

        Args:
            read_termination: Character(s) marking end of received messages
            write_termination: Character(s) to append to sent messages
            encoding: Character encoding for string conversion
        """
        self.read_termination = read_termination.encode(encoding) if isinstance(read_termination, str) else read_termination
        self.write_termination = write_termination
        self.encoding = encoding
        self._read_buffer = bytearray()
        self._has_gui = QApplication.instance() is not None

    def _process_events(self):
        """Process GUI events if in GUI context."""
        if self._has_gui:
            QApplication.processEvents()
            
    @abstractmethod
    def open(self):
        """Opens the connection to the instrument."""
        pass

    @abstractmethod
    def close(self):
        """Closes the connection to the instrument."""
        pass

    @abstractmethod
    def write(self, command: str):
        """
        Writes a command string to the instrument.

        Args:
            command: The command string to send
        """
        pass

    @abstractmethod
    def has_data(self) -> bool:
        """
        Check if there is data available to read without blocking.

        Returns:
            bool: True if data is available to read without blocking
        """
        pass

    @abstractmethod
    def read_available(self) -> bytes:
        """
        Read whatever data is currently available without blocking.

        Returns:
            bytes: The currently available data (may be empty)
        """
        pass

    def read(self) -> str:
        """
        Default implementation of blocking read that uses has_data() and read_available().
        Can be overridden by subclasses if a more efficient implementation exists.

        Returns:
            str: The complete response string
        """
        while True:
            # Check for complete message in buffer
            if self.read_termination in self._read_buffer:
                # Find the terminator
                term_pos = self._read_buffer.find(self.read_termination)
                # Extract the message
                message = self._read_buffer[:term_pos].decode(self.encoding)
                # Remove processed data from buffer
                self._read_buffer = self._read_buffer[term_pos + len(self.read_termination):]
                return message

            # Read any available data
            if self.has_data():
                chunk = self.read_available()
                if chunk:
                    self._read_buffer.extend(chunk)
                continue

            # No data available and no complete message - block until data arrives
            chunk = self.read_available()  # This should block
            if chunk:
                self._read_buffer.extend(chunk)

    def query(self, command: str) -> str:
        """
        Default implementation of write followed by read.
        Can be overridden by subclasses if a more efficient implementation exists.

        Args:
            command: The command string to send

        Returns:
            str: The response string
        """
        self.write(command)
        return self.read()

    def clear_buffer(self):
        """Clear any partially read data from the buffer."""
        self._read_buffer.clear()


class PyVisaConnection(ConnectionInterface):
    """
    Implements the ConnectionInterface using PyVISA to communicate with instruments.
    Supports non-blocking reads through PyVISA's asynchronous I/O capabilities.
    """

    def __init__(self, resource_string: str, timeout: int = 5000,
                 read_termination: str = '\n', write_termination: str = '\n',
                 encoding: str = 'ascii'):
        """
        Initialize PyVISA connection parameters.

        Args:
            resource_string: VISA resource identifier
            timeout: I/O timeout in milliseconds
            read_termination: Character(s) marking end of received messages
            write_termination: Character(s) to append to sent messages
            encoding: Character encoding for string conversion
        """
        super().__init__(read_termination=read_termination,
                        write_termination=write_termination,
                        encoding=encoding)
        self.resource_string = resource_string
        self.timeout = timeout
        self.rm = pyvisa.ResourceManager()
        self.inst = None
        self._last_status = 0

    @staticmethod
    def list_instruments(query: str = "TCPIP?*::INSTR") -> Dict[str, str]:
        """List VISA resources without querying IDN."""
        logger.debug(f"PyVISA list_instruments called with query: '{query}'")
        discovered_devices = {}
        try:
            rm = pyvisa.ResourceManager()
            resources = rm.list_resources(query)
            logger.debug(f"PyVISA discovered resources: {list(resources)}")
            
            # Just map resource strings to themselves
            for resource in resources:
                discovered_devices[resource] = resource
                
        except Exception as e:
            logger.exception(f"PyVISA failed to list instruments: {e}")
                
        return discovered_devices
    
    @staticmethod
    def select_instrument(filter_query="TCPIP?*::INSTR"):
        """Utility method to interactively list and select VISA resources."""
        try:
            rm = pyvisa.ResourceManager()
            resources = rm.list_resources(filter_query)
            if not resources:
                print("No VISA instruments found matching your filter. Check connections.")
                raise SystemExit(0)

            print("\nAvailable Instruments:")
            for i, r in enumerate(resources, start=1):
                print(f"{i}. {r}")

            selection = input("\nSelect an instrument by number (or 'exit' to quit): ")
            if selection.lower() == 'exit':
                raise SystemExit(0)

            index = int(selection) - 1
            if index < 0 or index >= len(resources):
                raise ValueError("Invalid selection.")

            return resources[index]
        except Exception as e:
            logger.exception(f"select_instrument failed: {e}")
            raise

    def read_sync(self) -> str:
        """
        Synchronous (blocking) read operation for non-GUI contexts.
        This provides a simpler, more efficient read when async operation isn't needed.

        Returns:
            str: The complete response string
        """
        if not self.inst:
            raise ConnectionError("PyVISA instrument not open. Call open() first.")
            
        try:
            response = self.inst.read()
            logger.debug(f"PyVISA sync read response: {response}")
            return response
        except Exception as e:
            logger.exception(f"Error in sync read: {e}")
            raise

    def open(self):
        """Open the VISA session and configure it for asynchronous operation."""
        logger.debug(f"Opening PyVISA connection for resource: {self.resource_string}")
        self.inst = self.rm.open_resource(self.resource_string)
        self.inst.timeout = self.timeout
        self.inst.read_termination = self.write_termination
        self.inst.write_termination = self.write_termination

        # Enable Service Request generation if supported
        try:
            # Enable SRQ on data available
            self.inst.write("*SRE 16")  # Enable MAV bit in SRE
            self._srq_supported = True
        except pyvisa.Error:
            logger.debug("SRQ not supported by instrument")
            self._srq_supported = False

        logger.info(f"PyVISA connection opened for {self.resource_string}")

    def close(self):
        """Close the VISA session."""
        if self.inst is not None:
            logger.debug(f"Closing PyVISA connection for resource: {self.resource_string}")
            try:
                self.inst.close()
            finally:
                self.inst = None
                logger.info(f"PyVISA connection closed for {self.resource_string}")

    def write(self, command: str):
        """
        Write a command string to the instrument.

        Args:
            command: The command string to send
        """
        if not self.inst:
            raise ConnectionError("PyVISA instrument not open. Call open() first.")
        logger.debug(f"PyVISA write: {command}")
        self.inst.write(command)

    def has_data(self) -> bool:
        """
        Check if data is available to read without blocking.

        Returns:
            bool: True if data is available
        """
        if not self.inst:
            raise ConnectionError("PyVISA instrument not open. Call open() first.")

        try:
            if self._srq_supported:
                # Use STB polling for data availability
                stb = self.inst.read_stb()
                return bool(stb & 0x10)  # Check MAV bit
            else:
                # Fall back to VI_ATTR_TMO_VALUE=0 read attempt
                orig_timeout = self.inst.timeout
                self.inst.timeout = 0
                try:
                    self.inst.read_bytes(1)
                    return True
                except pyvisa.VisaIOError as e:
                    if e.error_code == pyvisa.constants.StatusCode.error_timeout:
                        return False
                    raise
                finally:
                    self.inst.timeout = orig_timeout
        except Exception as e:
            logger.exception(f"Error checking for data: {e}")
            raise

    def read_available(self) -> bytes:
        """
        Read whatever data is currently available.
        If no data is available, blocks for up to timeout period.

        Returns:
            bytes: The currently available data (may be empty)
        """
        if not self.inst:
            raise ConnectionError("PyVISA instrument not open. Call open() first.")

        try:
            # If data is available, read it
            if self.has_data():
                return self.inst.read_raw()

            # No immediate data - wait for timeout period
            if self._srq_supported:
                # Wait for SRQ
                if self.inst.wait_for_srq(self.timeout / 1000):
                    return self.inst.read_raw()
            else:
                # Regular timeout-based read
                try:
                    return self.inst.read_raw()
                except pyvisa.VisaIOError as e:
                    if e.error_code == pyvisa.constants.StatusCode.error_timeout:
                        return b''
                    raise

            return b''

        except Exception as e:
            logger.exception(f"Error reading available data: {e}")
            raise


class RawSocketConnection(ConnectionInterface):
    """
    Implements a raw socket-based connection for instruments that communicate over TCP/IP
    without requiring a VISA driver. Supports non-blocking reads.
    """

    # Default discovery port for Microchip TCP/IP Stack (PIC32MX/MZ)
    DISCOVERY_PORT = 30303

    @staticmethod
    def parse_resource_string(resource: str) -> tuple[str, int]:
        """Parse various resource string formats into host and port."""
        # Handle TCPIP resource string format
        if resource.startswith("TCPIP::"):
            parts = resource.split("::")
            if len(parts) >= 3:
                return parts[1], int(parts[2])
        
        # Handle direct IP:port format
        if ":" in resource:
            host, port = resource.split(":")
            return host.strip(), int(port)
            
        # If just an IP/hostname is provided
        return resource, 5025  # Default SCPI port
    
    def __init__(self, host: str, port: int = 5025, timeout: float = 2.5,
                 encoding: str = 'ascii', read_termination: str = '\n',
                 write_termination: str = '\n'):
        """
        Initialize socket connection parameters.
        
        Args:
            host: IP address, hostname, or resource string
            port: TCP port number (default: 5025 for SCPI)
            timeout: Socket timeout in seconds
            encoding: Character encoding for string conversion
            read_termination: Character(s) marking end of received messages
            write_termination: Character(s) to append to sent messages
        """
        super().__init__(read_termination=read_termination,
                        write_termination=write_termination,
                        encoding=encoding)
                        
        # Handle if host is actually a resource string
        if isinstance(host, str) and ("::" in host or ":" in host):
            self.host, parsed_port = self.parse_resource_string(host)
            self.port = port if port != 5025 else parsed_port  # Use explicitly provided port if given
        else:
            self.host = host
            self.port = port
            
        self.timeout = timeout
        self.sock = None

    def open(self):
        """Open the socket connection to the instrument."""
        logger.debug(f"Opening raw socket connection to {self.host}:{self.port}")
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.settimeout(self.timeout)
            self.sock.connect((self.host, self.port))
            # Set non-blocking mode after connection
            self.sock.setblocking(False)
            logger.info(f"Raw socket connection established to {self.host}:{self.port}")
        except socket.error as e:
            logger.exception(f"Failed to connect to {self.host}:{self.port} - {e}")
            raise

    def close(self):
        """Close the socket connection."""
        if self.sock is not None:
            logger.debug(f"Closing raw socket connection to {self.host}:{self.port}")
            try:
                self.sock.close()
            finally:
                self.sock = None
                logger.info(f"Raw socket connection closed for {self.host}:{self.port}")

    def write(self, command: str):
        """
        Send a command string to the instrument.

        Args:
            command: The command string to send
        """
        if not self.sock:
            raise ConnectionError("Raw socket not open. Call open() first.")

        # Append termination if not already present
        if not command.endswith(self.write_termination):
            command += self.write_termination

        data = command.encode(self.encoding)
        logger.debug(f"Raw socket write: {command.strip()}")

        try:
            self.sock.sendall(data)
        except socket.error as e:
            logger.exception(f"Failed to send data to {self.host}:{self.port} - {e}")
            raise

    def has_data(self) -> bool:
        """
        Check if data is available to read without blocking.

        Returns:
            bool: True if data is available
        """
        if not self.sock:
            raise ConnectionError("Raw socket not open. Call open() first.")

        try:
            readable, _, _ = select.select([self.sock], [], [], 0)
            return bool(readable)
        except select.error as e:
            logger.exception(f"Select error checking for data: {e}")
            raise

    def read_available(self) -> bytes:
        """
        Read whatever data is currently available without blocking.
        If no data is available, blocks for up to timeout seconds.

        Returns:
            bytes: The currently available data (may be empty)
        """
        if not self.sock:
            raise ConnectionError("Raw socket not open. Call open() first.")

        try:
            # If data is immediately available, read it
            if self.has_data():
                return self.sock.recv(4096)

            # No data available - wait for timeout period
            readable, _, _ = select.select([self.sock], [], [], self.timeout)
            if readable:
                return self.sock.recv(4096)
            return b''
        except socket.error as e:
            logger.exception(f"Failed to read data from {self.host}:{self.port} - {e}")
            raise

    @staticmethod
    def list_instruments(methods: List[str] = ['udp', 'mdns', 'scan'], timeout: float = 5.0) -> Dict[str, str]:
        """
        Discover raw socket instruments using various methods.

        Args:
            methods (list): Methods to use for discovery ('udp', 'mdns', 'scan').
            timeout (float): Timeout for discovery methods in seconds.

        Returns:
            dict[str, str]: A dictionary mapping unique IDs to resource strings.
        """
        discovered_devices = {}

        # Discover all local IP ranges
        local_ip_ranges = RawSocketConnection.get_all_local_ip_ranges()
        logger.debug(f"Detected local IP ranges: {local_ip_ranges}")

        for ip_range in local_ip_ranges:
            if 'udp' in methods:
                devices = RawSocketConnection._discover_udp(timeout, ip_range)
                discovered_devices.update(devices)

            # Implement these in a full scan.
            # if 'mdns' in methods and not discovered_devices:
            #     devices = RawSocketConnection._discover_mdns(timeout)
            #     discovered_devices.update(devices)

            # if 'scan' in methods and not discovered_devices:
            #     devices = RawSocketConnection._discover_scan(ip_range=ip_range, timeout=timeout)
            #     discovered_devices.update(devices)

        logger.debug(f"RawSocket discovered devices before filtering: {discovered_devices}")

        # Filtering will be handled externally in Instrument.list_instruments

        return discovered_devices

    @staticmethod
    def _discover_udp(timeout: float, ip_range: str) -> Dict[str, str]:
        """Discover instruments via UDP broadcast within a specific IP range."""
        discovered_devices = {}
        discovered_ips = set()  
        port = 30303  # PIC32 discovery port

        # Check for GUI context once
        has_gui = QApplication.instance() is not None

        # Derive broadcast address from IP range
        network = ipaddress.ip_network(ip_range, strict=False)
        broadcast_address = str(network.broadcast_address)

        logger.debug(f"Starting UDP discovery on {broadcast_address}:{port}")

        try:
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                sock.bind(('', port))
                sock.settimeout(timeout)

                # Send discovery message
                discovery_message = b"Discovery: Who is out there!"
                sock.sendto(discovery_message, (broadcast_address, port))
                logger.debug(f"Sent UDP discovery message to {broadcast_address}:{port}")

                # Collect responses
                start_time = time.time()
                while time.time() - start_time < timeout:
                    try:
                        data, addr = sock.recvfrom(4096)
                        logger.debug(f"Received UDP response from {addr}")
                        discovered_ips.add(addr[0])
                    except socket.timeout:
                        pass
                    
                    if has_gui:
                        QApplication.processEvents()

        except Exception as e:
            logger.exception(f"Failed to perform UDP discovery: {e}")

        # Now try to identify devices on standard ports using parallel scanning
        instrument_ports = [9760]
        discovered_resources = {}

        def scan_port(ip, port):
            if has_gui:
                QApplication.processEvents()
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                    sock.settimeout(0.5)  # Reduced timeout for faster scanning
                    sock.connect((ip, port))
                    resource = f"TCPIP::{ip}::{port}::SOCKET"
                    logger.info(f"Found device at {ip}:{port}")
                    return resource, resource  # Don't query IDN
            except (socket.timeout, ConnectionRefusedError):
                return None
            except Exception as e:
                logger.debug(f"Error checking {ip}:{port} - {e}")
                return None

        with concurrent.futures.ThreadPoolExecutor(max_workers=100) as executor:
            futures = [
                executor.submit(scan_port, ip, port) 
                for ip in discovered_ips 
                for port in instrument_ports
            ]
            for future in concurrent.futures.as_completed(futures):
                result = future.result()
                if result:
                    unique_id, resource = result
                    discovered_resources[unique_id] = resource

        logger.debug(f"RawSocket discovered devices before filtering: {discovered_resources}")

        # Filtering will be handled externally in Instrument.list_instruments

        return discovered_resources

    @staticmethod
    def get_all_local_ip_ranges(default: str = "192.168.1.0/24") -> List[str]:
        """
        Retrieve all local IPv4 addresses and derive their subnets.

        Args:
            default (str): Default subnet to use if no valid IPs are found

        Returns:
            List[str]: A list of IP ranges in CIDR notation
        """
        ip_ranges = []
        try:
            hostname = socket.gethostname()
            logger.debug(f"Host name: {hostname}")
            host_info = socket.gethostbyname_ex(hostname)
            # host_info[2] contains a list of IP addresses
            for ip in host_info[2]:
                try:
                    # Exclude loopback and non-private IPs
                    if ip.startswith("127.") or not RawSocketConnection.is_private_ip(ip):
                        continue
                    network = ipaddress.IPv4Network(f"{ip}/24", strict=False)
                    ip_ranges.append(str(network))
                    logger.debug(f"Derived network from IP {ip}: {network}")
                except ValueError as ve:
                    logger.warning(f"Invalid IP address '{ip}': {ve}")
        except Exception as e:
            logger.error(f"Failed to retrieve local IP addresses: {e}")
            ip_ranges.append(default)
            logger.debug(f"Using default IP range: {default}")

        return ip_ranges if ip_ranges else [default]

    @staticmethod
    def is_private_ip(ip: str) -> bool:
        """
        Check if the given IP address is within a private network range.

        Args:
            ip (str): IP address to check

        Returns:
            bool: True if private, False otherwise
        """
        private_networks = [
            ipaddress.IPv4Network('10.0.0.0/8'),
            ipaddress.IPv4Network('172.16.0.0/12'),
            ipaddress.IPv4Network('192.168.0.0/16'),
        ]
        ip_addr = ipaddress.IPv4Address(ip)
        return any(ip_addr in network for network in private_networks)
    
    @staticmethod
    def parse_datagram(datagram: bytes) -> str:
        """
        Parse PIC32 UDP response datagram.
        PIC32 devices using Microchip's TCP/IP stack typically respond with ASCII text
        containing device information and network configuration.

        Args:
            datagram (bytes): The received UDP datagram.

        Returns:
            str: The parsed device identifier or empty string if parsing fails.
        """
        try:
            # PIC32 responses are typically ASCII
            data_str = datagram.decode('ascii').strip()
            logger.debug(f"Parsing PIC32 response: {data_str}")
            
            # Extract device identifier (usually first part of response)
            device_id = data_str.split(',')[0].strip()
            return device_id

        except Exception as e:
            logger.error(f"Failed to parse PIC32 response '{datagram.hex()}': {e}")
            return ""
    
    @staticmethod
    def _discover_mdns(timeout: float) -> Dict[str, str]:
        """
        Discover instruments via mDNS.

        Args:
            timeout (float): Timeout for discovery in seconds.

        Returns:
            dict[str, str]: A dictionary mapping unique IDs to resource strings.
        """
        discovered_devices = {}
        service_type = "_instrument._tcp.local."  # Replace with your instrument's service type

        logger.debug(f"Starting mDNS discovery for service type: {service_type}")

        class InstrumentListener:
            def __init__(self):
                self.devices = {}

            def remove_service(self, zeroconf, type, name):
                logger.debug(f"Service {name} removed")

            def add_service(self, zeroconf, type, name):
                info = zeroconf.get_service_info(type, name)
                if info:
                    addr = socket.inet_ntoa(info.addresses[0])
                    port = info.port
                    properties = info.properties
                    unique_id = properties.get(b'unique_id', b'').decode('utf-8')
                    if unique_id:
                        resource = f"TCPIP::{addr}::{port}::SOCKET"
                        self.devices[unique_id] = resource
                        logger.info(f"Discovered mDNS Instrument - ID: {unique_id}, Resource: {resource}")

            def update_service(self, zeroconf, type, name):
                logger.debug(f"Service {name} updated")
                self.add_service(zeroconf, type, name)

        zeroconf = Zeroconf()
        listener = InstrumentListener()
        browser = ServiceBrowser(zeroconf, service_type, listener)

        try:
            logger.debug(f"Waiting for mDNS responses for {timeout} seconds...")
            time.sleep(timeout)
        finally:
            zeroconf.close()

        discovered_devices = listener.devices
        logger.debug(f"mDNS discovery completed. Devices found: {discovered_devices}")

        return discovered_devices

    @staticmethod
    def _discover_scan(ip_range: Optional[str] = None, ports: list = [5025, 9760, 1234], 
                      timeout: float = 3.0) -> Dict[str, str]:
        """
        Discover instruments by scanning a range of IP addresses and specific ports.

        Args:
            ip_range (str, optional): IP range in CIDR notation. If None, detect automatically.
            ports (list): List of port numbers to scan.
            timeout (float): Timeout for each connection attempt in seconds.

        Returns:
            dict[str, str]: A dictionary mapping unique IDs to resource strings.
        """
        if ip_range is None:
            ip_ranges = RawSocketConnection.get_all_local_ip_ranges()
        else:
            ip_ranges = [ip_range]

        discovered_devices = {}
        logger.debug(f"Starting network scan on IP range(s): {ip_ranges}, Ports: {ports}")

        for current_ip_range in ip_ranges:
            try:
                network = ipaddress.ip_network(current_ip_range, strict=False)
            except ValueError as e:
                logger.error(f"Invalid IP range '{current_ip_range}': {e}")
                continue

            def scan_ip(ip, port):
                if QApplication.instance() is not None:
                    QApplication.processEvents()
                    
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                    sock.settimeout(timeout)
                    try:
                        sock.connect((str(ip), port))
                        resource = f"TCPIP::{ip}::{port}::SOCKET"
                        logger.info(f"Found device at {ip}:{port}")
                        return resource, resource  # Don't query IDN
                    except (socket.timeout, ConnectionRefusedError):
                        pass
                    except Exception as e:
                        logger.debug(f"Error scanning {ip}:{port} - {e}")
                return None

            # Utilize ThreadPoolExecutor for efficient scanning
            with concurrent.futures.ThreadPoolExecutor(max_workers=100) as executor:
                futures = [executor.submit(scan_ip, ip, port) 
                          for ip in network.hosts() 
                          for port in ports]
                
                for future in concurrent.futures.as_completed(futures):
                    result = future.result()
                    if result:
                        unique_id, resource = result
                        discovered_devices[unique_id] = resource

        logger.debug(f"Network scan completed. Devices found: {discovered_devices}")

        return discovered_devices



================================================================================
*** instrument.py ***
### src/pymetr/drivers/base/instrument.py ###
================================================================================

# drivers/base/instrument.py
import logging
import time
from abc import ABCMeta, abstractmethod
from typing import Optional, Any, Dict, List
import concurrent.futures
import queue

# Third-party imports
import numpy as np
from PySide6.QtCore import QObject, Signal, QThread, Slot
from PySide6.QtWidgets import QApplication

# Local imports
from pymetr.core.logging import logger
from pymetr.drivers.base.connections import (
    ConnectionInterface,
    PyVisaConnection,
    RawSocketConnection
)

class ConnectionWorker(QObject):
    """Worker object that handles instrument communication in a separate thread."""
    command_finished = Signal(str)    # Response string
    error_occurred = Signal(str)      # Error message
    
    def __init__(self, connection):
        super().__init__()
        self.connection = connection
        self.command_queue = queue.Queue()
        self.running = True
        
    @Slot()
    def process_commands(self):
        """Process raw SCPI commands."""
        while self.running:
            try:
                # Get command with timeout
                try:
                    cmd_type, command = self.command_queue.get(timeout=0.1)
                except queue.Empty:
                    continue
                    
                # Execute command
                try:
                    if cmd_type == "write":
                        self.connection.write(command)
                        self.command_finished.emit("")
                    elif cmd_type == "read":
                        response = self.connection.read()
                        self.command_finished.emit(response)
                    elif cmd_type == "query":
                        response = self.connection.query(command)
                        self.command_finished.emit(response)
                except Exception as e:
                    self.error_occurred.emit(str(e))
                    
            except Exception as e:
                self.error_occurred.emit(f"Worker error: {str(e)}")

    def stop(self):
        """Stop the worker thread."""
        self.running = False
        
    def write(self, command: str):
        """Queue a write command."""
        self.command_queue.put(("write", command))
        
    def read(self):
        """Queue a read command."""
        self.command_queue.put(("read", ""))
        
    def query(self, command: str):
        """Queue a query command."""
        self.command_queue.put(("query", command))

class ABCQObjectMeta(type(QObject), ABCMeta):
    """Metaclass that combines QObject and ABC functionality."""
    pass

class Instrument(QObject, metaclass=ABCQObjectMeta):
    """
    Base Instrument class supporting both threaded and direct communication modes.
    """
    commandSent = Signal(str)               
    responseReceived = Signal(str, str)     
    exceptionOccured = Signal(str)
    traceDataReady = Signal(np.ndarray, np.ndarray)

    def __init__(self, connection: ConnectionInterface,
                 read_after_write: bool = False, 
                 read_timeout: float = 1.5,
                 threaded_mode: bool = None,  # None = auto-detect based on GUI context
                 parent: Optional[QObject] = None):
        super().__init__(parent)
        self.connection = connection
        self.read_after_write = read_after_write
        self.read_timeout = read_timeout
        
        # State flags
        self.continuous_mode = False
        self._ready_for_data = True
        self.unique_id = None

        # Determine communication mode
        self._has_gui = QApplication.instance() is not None
        self._threaded_mode = threaded_mode if threaded_mode is not None else self._has_gui
        self._worker = None
        self._worker_thread = None

        if self._threaded_mode:
            self._setup_worker()

    def _setup_worker(self):
        """Initialize connection worker and thread if needed."""
        self._worker = ConnectionWorker(self.connection)
        self._worker_thread = QThread()
        self._worker.moveToThread(self._worker_thread)
        
        # Connect signals
        self._worker_thread.started.connect(self._worker.process_commands)
        self._worker.command_finished.connect(self._handle_worker_response)
        self._worker.error_occurred.connect(self._handle_worker_error)
        
        self._worker_thread.start()

    def _cleanup_worker(self):
        """Clean up worker thread."""
        if self._worker:
            self._worker.stop()
            self._worker_thread.quit()
            self._worker_thread.wait()
            self._worker = None
            self._worker_thread = None

    def open(self):
        """Opens the connection to the instrument."""
        try:
            self.connection.open()
            logger.info("Instrument connection opened")
        except Exception as e:
            logger.exception(f"Failed to open connection: {e}")
            raise

    def close(self):
        """Closes the connection to the instrument."""
        self._cleanup_worker()
        try:
            self.connection.close()
            logger.info("Instrument connection closed")
        except Exception as e:
            logger.exception(f"Failed to close connection: {e}")
            raise

    def write(self, command: str) -> None:
        """Write a command to the instrument."""
        desc = f"WRITE: {command}"
        logger.debug(desc)

        try:
            if self._threaded_mode:
                self._worker.write(command)
            else:
                self.connection.write(command)
                
            self.commandSent.emit(command)

            if self.read_after_write:
                return self.read()

        except Exception as e:
            logger.exception(f"Error executing {desc}: {e}")
            self.exceptionOccured.emit(f"{desc} -> {e}")
            raise

    def read(self) -> str:
        """Read from the instrument."""
        desc = "READ"
        logger.debug(desc)

        try:
            if self._threaded_mode:
                self._worker.read()
                # Response will come through _handle_worker_response
                return None  # Or use a Future/Promise pattern if needed
            else:
                response = self.connection.read()
                self.responseReceived.emit("READ", response)
                return response

        except Exception as e:
            logger.exception(f"Error executing {desc}: {e}")
            self.exceptionOccured.emit(f"{desc} -> {e}")
            raise

    def query(self, command: str) -> str:
        """Send a query and get the response."""
        desc = f"QUERY: {command}"
        logger.debug(desc)

        try:
            if self._threaded_mode:
                self._worker.query(command)
                # Response will come through _handle_worker_response
                return None  # Or use a Future/Promise pattern if needed
            else:
                self.write(command)
                response = self.read()
                self.responseReceived.emit(command, response)
                return response

        except Exception as e:
            logger.exception(f"Error executing {desc}: {e}")
            self.exceptionOccured.emit(f"{desc} -> {e}")
            raise

    def _handle_worker_response(self, response: str):
        """Handle responses from worker thread."""
        self.responseReceived.emit("READ", response)

    def _handle_worker_error(self, error: str):
        """Handle errors from worker thread."""
        self.exceptionOccured.emit(error)

    def set_continuous_mode(self, mode: bool):
        """Set continuous mode flag."""
        logger.debug(f"Set continuous mode to {mode}")
        self.continuous_mode = mode
        self._ready_for_data = not mode

    def set_unique_id(self, uid: str):
        """Set unique identifier for this instrument."""
        self.unique_id = uid

    @abstractmethod
    def fetch_trace(self, *args, **kwargs):
        """
        Abstract method for fetching trace data.
        Must be implemented by derived classes.
        """
        pass

    @staticmethod
    def gui_command(func):
        """Decorator for GUI-related commands."""
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        return wrapper

    @classmethod
    def list_instruments(cls, model_filter: Optional[List[str]] = None) -> Dict[str, Dict[str, str]]:
        """
        List available instruments, starting with fast UDP discovery.
        Emits instrument_found signals as devices are discovered.
        
        Args:
            model_filter (List[str], optional): List of model substrings to filter instruments.
            
        Returns:
            Dict[str, Dict[str, str]]: Dictionary mapping unique IDs to instrument details.
        """
        logger.debug(f"Starting instrument discovery with model_filter: '{model_filter}'")
        instruments = {}
        has_gui = QApplication.instance() is not None

        # Start with UDP discovery (faster)
        try:
            logger.debug("Starting UDP discovery")
            for ip_range in RawSocketConnection.get_all_local_ip_ranges():
                udp_devices = RawSocketConnection._discover_udp(timeout=1.0, ip_range=ip_range)
                
                # Process each UDP-discovered device
                for resource in udp_devices.values():
                    try:
                        # Create socket connection
                        host, port = RawSocketConnection.parse_resource_string(resource)
                        conn = RawSocketConnection(host=host, port=port, timeout=1.0)
                        conn.open()
                        
                        # Quick IDN query
                        idn = conn.query("*IDN?").strip()
                        conn.close()

                        if idn:
                            # Parse IDN parts
                            idn_parts = [part.strip() for part in idn.split(",")]
                            if len(idn_parts) >= 4:
                                manufacturer, model, serial, firmware = idn_parts[:4]
                            else:
                                manufacturer, model, serial, firmware = idn_parts + [""]*(4-len(idn_parts))

                            # Apply model filter if provided
                            if not model_filter or any(f.lower() in model.lower() for f in model_filter):
                                instrument_info = {
                                    'manufacturer': manufacturer,
                                    'model': model,
                                    'serial': serial,
                                    'firmware': firmware,
                                    'resource': resource
                                }
                                unique_id = f"{model}, {serial}"
                                instruments[unique_id] = instrument_info
                                
                                # Emit signal if we found a device
                                if hasattr(cls, 'instrument_found'):
                                    cls.instrument_found.emit(instrument_info)
                                logger.info(f"Found instrument via UDP: {unique_id}")

                    except Exception as e:
                        logger.debug(f"Could not query device at {resource}: {e}")

                    if has_gui:
                        QApplication.processEvents()

        except Exception as e:
            logger.warning(f"UDP discovery error: {e}")

        # Then do VISA discovery (slower but might find additional devices)
        try:
            logger.debug("Starting VISA discovery")
            visa_resources = PyVisaConnection.list_instruments()
            
            def query_visa_device(resource):
                if has_gui:
                    QApplication.processEvents()
                try:
                    conn = PyVisaConnection(resource, timeout=1000)  # Short timeout
                    conn.open()
                    idn = conn.query("*IDN?").strip()
                    conn.close()

                    if idn:
                        idn_parts = [part.strip() for part in idn.split(",")]
                        if len(idn_parts) >= 4:
                            manufacturer, model, serial, firmware = idn_parts[:4]
                        else:
                            manufacturer, model, serial, firmware = idn_parts + [""]*(4-len(idn_parts))

                        if not model_filter or any(f.lower() in model.lower() for f in model_filter):
                            instrument_info = {
                                'manufacturer': manufacturer,
                                'model': model,
                                'serial': serial,
                                'firmware': firmware,
                                'resource': resource
                            }
                            unique_id = f"{model}, {serial}"
                            
                            # Only add/emit if we haven't already found this device
                            if unique_id not in instruments:
                                instruments[unique_id] = instrument_info
                                if hasattr(cls, 'instrument_found'):
                                    cls.instrument_found.emit(instrument_info)
                                logger.info(f"Found instrument via VISA: {unique_id}")

                except Exception as e:
                    logger.debug(f"Could not query VISA device at {resource}: {e}")

            # Use thread pool for VISA discovery
            with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
                list(executor.map(query_visa_device, visa_resources.values()))

        except Exception as e:
            logger.warning(f"VISA discovery error: {e}")

        logger.info(f"Discovery complete. Found {len(instruments)} instruments")
        return instruments


class SCPIInstrument(Instrument):
    """
    A specialized Instrument for SCPI-compatible devices.
    
    Args:
        connection (ConnectionInterface): The connection to use
        async_mode (bool): Whether to use UI-responsive mode (default: True)
        read_after_write (bool): Whether to read after every write (default: False)
        timeout (int): Default timeout for operations in milliseconds (default: 5000)
        parent (QObject): Parent QObject (default: None)
    """

    def __init__(self, connection, read_after_write=False, timeout=5000, parent=None):
        super().__init__(connection, read_after_write=read_after_write, parent=parent)
        self._data_mode = "ASCII"
        self._data_type = "B"  # Default data type for binary transfers
        self.timeout = timeout
        
        # Status tracking
        self._last_status = None
        self._error_queue = []

    @property
    def data_mode(self) -> str:
        """Gets or sets the data transfer mode ('ASCII' or 'BINARY')."""
        return self._data_mode
    
    @data_mode.setter
    def data_mode(self, mode: str):
        mode = mode.upper()
        if mode not in ["ASCII", "BINARY"]:
            raise ValueError("data_mode must be 'ASCII' or 'BINARY'")
        self._data_mode = mode
        logger.debug(f"Set data_mode to {self._data_mode}")

    @property
    def data_type(self) -> str:
        """Gets or sets the binary data type (e.g., 'B' for unsigned char)."""
        return self._data_type
    
    @data_type.setter
    def data_type(self, dtype: str):
        self._data_type = dtype
        logger.debug(f"Set data_type to {self._data_type}")

    # IEEE 488.2 Common Commands

    def idn(self) -> str:
        """
        Queries the instrument identity (*IDN?).
        
        Returns:
            str: The identification string
        """
        logger.debug("Querying instrument identity (*IDN?)")
        response = self._execute_command(self.connection.query, "*IDN?")
        logger.debug(f"Received IDN response: {response}")
        return response
    
    def get_identity(self) -> str:
        """
        Queries the instrument identity (*IDN?).
        
        Returns:
            str: The identification string
        """
        logger.debug("Querying instrument identity (*IDN?)")
        response = self.query("*IDN?")
        logger.debug(f"Received IDN response: {response}")
        return response
    
    def query_operation_complete(self):
        """Waits for operation complete (*OPC?)."""
        logger.info("Waiting for operation complete (*OPC?)")
        return self.query("*OPC?")

    def reset(self):
        """Resets the instrument (*RST)."""
        logger.info("Performing instrument reset (*RST)")
        self.write("*RST")

    def clear_status_registers(self):
        """Clears the status registers (*CLS)."""
        logger.info("Clearing status registers (*CLS)")
        self.write("*CLS")

    def set_operation_complete(self):
        """Sets the operation complete flag (*OPC)."""
        logger.info("Setting operation complete flag (*OPC)")
        self.write("*OPC")

    def check_error_queue(self) -> List[str]:
        """
        Queries the error queue (SYST:ERR?).
        
        Returns:
            List[str]: List of error messages
        """
        logger.debug("Checking error queue (SYST:ERR?)")
        errors = []
        
        while True:
            response = self.query("SYST:ERR?")
            if "No error" in response.lower() or response.startswith("0,"):
                logger.debug("No more errors in the error queue.")
                break
            errors.append(response)
            logger.warning(f"Instrument error: {response}")
        
        return errors

    # Helper Methods for Data Handling

    def _parse_binary_header(self, response: bytes) -> tuple:
        """
        Parses IEEE 488.2 binary block header.
        Format: '#' + num_of_length_digits + data_length + data
        
        Returns:
            tuple: (data_bytes, header_length)
        """
        if not response.startswith(b'#'):
            raise ValueError("Invalid binary block format")
            
        num_digits = int(response[1:2])
        header_len = 2 + num_digits
        data_len = int(response[2:header_len])
        
        return response[header_len:header_len + data_len], header_len

    def _format_binary_data(self, data: np.ndarray) -> bytes:
        """
        Formats data array as IEEE 488.2 binary block.
        
        Args:
            data: Numpy array to format
            
        Returns:
            bytes: Formatted binary data
        """
        raw_data = data.tobytes()
        len_str = str(len(raw_data))
        header = f"#{len(len_str)}{len_str}".encode()
        return header + raw_data

    def write_binary_data(self, command: str, data: np.ndarray):
        """
        Writes binary data to instrument with proper formatting.
        
        Args:
            command: SCPI command
            data: Numpy array to send
        """
        binary_data = self._format_binary_data(data)
        full_command = command.encode() + b' ' + binary_data
        self._execute_command(self.connection.write, full_command)

    def read_binary_data(self) -> np.ndarray:
        """
        Reads binary data from instrument and converts to numpy array.
        
        Returns:
            numpy.ndarray: Parsed data array
        """
        response = self._execute_command(self.connection.read)
        data, _ = self._parse_binary_header(response)
        return np.frombuffer(data, dtype=self._data_type)
    

class Subsystem:
    """
    Base class for creating instrument subsystems, supporting both simple and indexed instantiation, 
    and enabling nested subsystem command prefix cascading.
    """

    def __init__(self, instr, cmd_prefix="", index=None):
        """
        Initializes a Subsystem instance.

        Args:
            instr (Instrument or Subsystem): The parent instrument or subsystem this instance belongs to.
            cmd_prefix (str): The command prefix specific to this subsystem.
            index (int, optional): If provided, specifies the index for this instance.
        """
        self.instr = instr
        logger.debug(f"Initializing subsystem with instrument {instr}, prefix '{cmd_prefix}', and index {index}")
        # Handle cascading of command prefixes for nested subsystems
        self.cmd_prefix = f"{getattr(instr, 'cmd_prefix', '')}{cmd_prefix}"
        if index is not None:
            self.cmd_prefix += str(index)
        logger.debug(f"Subsystem command prefix set to '{self.cmd_prefix}'")

    def write(self, command: str) -> None:
        """
        Forward write command to parent instrument.

        Args:
            command (str): The SCPI command string to send.
        """
        logger.debug(f"Subsystem forwarding WRITE command: '{command}'")
        return self.instr.write(command)

    def read(self) -> str:
        """
        Forward read command to parent instrument.

        Returns:
            str: The response string from the instrument.
        """
        logger.debug("Subsystem forwarding READ command")
        return self.instr.read()

    def query(self, command: str) -> str:
        """
        Forward query command to parent instrument.

        Args:
            command (str): The SCPI query command string.

        Returns:
            str: The response string from the instrument.
        """
        logger.debug(f"Subsystem forwarding QUERY command: '{command}'")
        return self.instr.query(command)

    def _execute_command(self, func, *args, **kwargs):
        """
        Forward command execution to parent instrument.

        Args:
            func (callable): The function to execute (e.g., write, read, query).
            *args: Positional arguments for the function.
            **kwargs: Keyword arguments for the function.

        Returns:
            Any: The result of the executed function.
        """
        logger.debug(f"Subsystem executing command with function: '{func.__name__}'")
        return self.instr._execute_command(func, *args, **kwargs)

    @classmethod
    def build(cls, parent, cmd_prefix, indices=None):
        """
        Class method to instantiate subsystems. Handles both single and indexed instances.

        Args:
            parent (Instrument or Subsystem): The parent object for the new subsystem(s).
            cmd_prefix (str): The SCPI command prefix.
            indices (int, optional): Number of indexed instances to create.

        Returns:
            Subsystem or list of Subsystem: Single instance or list of indexed instances.
        """
        if indices is None:
            # Single instance (no indexing)
            logger.debug(f"Building single instance of {cls.__name__} with prefix '{cmd_prefix}'")
            return cls(parent, cmd_prefix)
        
        subsystems = [None]  # Dummy element at index=0 for 1-based indexing
        if isinstance(indices, int) and indices > 0:
            # Create indexed instances from 1 to indices
            for i in range(1, indices + 1):
                logger.debug(f"Building indexed instance {i} of {cls.__name__} with prefix '{cmd_prefix}'")
                subsystems.append(cls(parent, cmd_prefix, i))
            return subsystems
        else:
            raise ValueError("Unsupported type or value for indices. Must be a positive integer or None.")




================================================================================
*** properties.py ***
### src/pymetr/drivers/base/properties.py ###
================================================================================


"""
SCPI Property System - Simplified Implementation

This module provides descriptor classes for handling SCPI instrument properties.
Each property class implements specific behavior for different types of instrument
settings while relying on the base Instrument class for communication handling.
"""

from abc import ABC, abstractmethod
import logging
from typing import Any, Optional, Union, Tuple, List, Type, Callable
from enum import Enum
from dataclasses import dataclass
import numpy as np

logger = logging.getLogger(__name__)

@dataclass
class PropertyResponse:
    """
    Tracks the response and status of property operations.

    Attributes:
        value: The converted/processed value from the instrument
        raw_response: The raw string response from the instrument
        success: Whether the operation completed successfully
        error: Error message if the operation failed
    """
    value: Any = None
    raw_response: str = ""
    success: bool = True
    error: Optional[str] = None

class Property(ABC):
    """
    Base class for all SCPI property descriptors.

    This class implements the descriptor protocol and provides basic functionality
    for getting and setting SCPI instrument properties. It relies on the instrument's
    write/read/query methods for communication.

    Args:
        cmd_str: The SCPI command string associated with this property
        doc_str: Documentation string describing the property
        access: Access mode ('read', 'write', or 'read-write')
        join_char: Character used to join command and value
    """

    def __init__(self, cmd_str: str, doc_str: str = "", access: str = "read-write", join_char: str = " "):
        logger.debug(f"Initializing Property with cmd_str='{cmd_str}', access='{access}'")
        self.cmd_str = cmd_str
        self.doc_str = doc_str
        self.access = access.lower()
        self.join_char = join_char
        self.last_response = PropertyResponse()

    def __get__(self, instance, owner):
        """Descriptor get implementation."""
        if instance is None:
            logger.debug(f"Property accessed on class, returning self")
            return self
            
        if self.access not in ["read", "read-write"]:
            msg = f"Property '{self.cmd_str}' is write-only"
            logger.error(msg)
            raise AttributeError(msg)
            
        return self.getter(instance)

    def __set__(self, instance, value):
        """Descriptor set implementation."""
        if self.access not in ["write", "read-write"]:
            msg = f"Property '{self.cmd_str}' is read-only"
            logger.error(msg)
            raise AttributeError(msg)
            
        self.setter(instance, value)

    @abstractmethod
    def getter(self, instance) -> Any:
        """Abstract getter method to be implemented by subclasses."""
        pass

    @abstractmethod
    def setter(self, instance, value):
        """Abstract setter method to be implemented by subclasses."""
        pass

class ValueProperty(Property):
    """
    Numeric property with range validation and unit handling.

    Args:
        cmd_str: SCPI command string
        type: Data type ('float' or 'int')
        range: Optional tuple of (min, max) values
        units: Optional unit string to append to values
        doc_str: Documentation string
        access: Access mode ('read', 'write', or 'read-write')
        join_char: Character used to join command and value
    """

    def __init__(self, cmd_str: str, type: str = None, range: Optional[Tuple] = None,
                 units: str = "", doc_str: str = "", access: str = "read-write",
                 join_char: str = " "):
        super().__init__(cmd_str, doc_str, access, join_char)
        self.type = type
        self.range = range
        self.units = units
        logger.debug(
            f"Initialized ValueProperty: type='{type}', range={range}, "
            f"units='{units}'"
        )

    def _validate_value(self, value: Any) -> Union[float, int]:
        """
        Validate and convert a value according to type and range constraints.

        Args:
            value: Value to validate and convert

        Returns:
            Converted and validated value
        """
        logger.debug(f"Validating value: {value}")
        try:
            # Convert value to proper type
            if self.type == "float":
                value = float(value)
            elif self.type == "int":
                value = int(float(value))  # Handle scientific notation
            else:
                value = value  # No conversion if type is None

            # Check range if specified
            if self.range:
                min_val, max_val = self.range
                if (min_val is not None and value < min_val) or \
                   (max_val is not None and value > max_val):
                    msg = f"Value {value} outside range [{min_val}, {max_val}]"
                    logger.error(msg)
                    raise ValueError(msg)

            logger.debug(f"Value {value} validated successfully")
            return value

        except (ValueError, TypeError) as e:
            msg = f"Validation error for '{value}': {str(e)}"
            logger.error(msg)
            raise ValueError(msg)

    def getter(self, instance) -> Union[float, int]:
        """Get the current numeric value from the instrument."""
        logger.debug(f"Getting value for '{self.cmd_str}'")
        try:
            response = instance.query(f"{self.cmd_str}?")
            value = self._validate_value(response)
            self.last_response = PropertyResponse(
                value=value,
                raw_response=response
            )
            return value
        except Exception as e:
            logger.error(f"Error in getter for '{self.cmd_str}': {e}")
            self.last_response = PropertyResponse(
                success=False,
                error=str(e)
            )
            raise

    def setter(self, instance, value):
        """Set a numeric value on the instrument."""
        logger.debug(f"Setting '{self.cmd_str}' to {value}")
        try:
            validated_value = self._validate_value(value)
            command = f"{self.cmd_str}{self.join_char}{validated_value}{self.units}"
            instance.write(command)
            self.last_response = PropertyResponse(
                value=validated_value,
                raw_response=command
            )
        except Exception as e:
            logger.error(f"Error in setter for '{self.cmd_str}': {e}")
            self.last_response = PropertyResponse(
                success=False,
                error=str(e)
            )
            raise

class SwitchProperty(Property):
    """
    Boolean property with configurable true/false representation.
    
    Args:
        cmd_str: SCPI command string
        doc_str: Documentation string
        format: Format for sending values ('ON_OFF', 'TRUE_FALSE', '1_0')
        access: Access mode ('read', 'write', or 'read-write')
        join_char: Character used to join command and value
    """

    # Define standard format mappings
    FORMAT_MAPS = {
        'ON_OFF': {'true': 'ON', 'false': 'OFF'},
        'TRUE_FALSE': {'true': 'TRUE', 'false': 'FALSE'},
        '1_0': {'true': '1', 'false': '0'}
    }

    def __init__(self, cmd_str: str, doc_str: str = "", format: str = '1_0', 
                 access: str = "read-write", join_char: str = " "):
        super().__init__(cmd_str, doc_str, access, join_char)
        
        # Validate and set format
        format = format.upper()
        if format not in self.FORMAT_MAPS:
            raise ValueError(f"Invalid format '{format}'. Must be one of: {list(self.FORMAT_MAPS.keys())}")
        self.format = format
        
        # Define accepted input values (case-insensitive)
        self.true_values = {'on', '1', 'true', 'yes'}
        self.false_values = {'off', '0', 'false', 'no'}
        logger.debug(f"Initialized SwitchProperty with format '{format}'")

    def _convert_to_bool(self, value: Union[str, bool]) -> bool:
        """Convert various inputs to boolean values."""
        if isinstance(value, bool):
            return value
            
        value_str = str(value).lower().strip()
        if value_str in self.true_values:
            return True
        if value_str in self.false_values:
            return False
            
        raise ValueError(f"Invalid boolean value: '{value}'")

    def _format_bool(self, value: bool) -> str:
        """Convert boolean to the configured string format."""
        return self.FORMAT_MAPS[self.format]['true' if value else 'false']

    def getter(self, instance) -> bool:
        """Get the current boolean state from the instrument."""
        logger.debug(f"Getting boolean value for '{self.cmd_str}'")
        try:
            response = instance.query(f"{self.cmd_str}?")
            value = self._convert_to_bool(response)
            self.last_response = PropertyResponse(
                value=value,
                raw_response=response
            )
            return value
        except Exception as e:
            logger.error(f"Error in getter for '{self.cmd_str}': {e}")
            self.last_response = PropertyResponse(
                success=False,
                error=str(e)
            )
            raise

    def setter(self, instance, value):
        """Set a boolean value on the instrument."""
        logger.debug(f"Setting '{self.cmd_str}' to {value}")
        try:
            bool_value = self._convert_to_bool(value)
            formatted_value = self._format_bool(bool_value)
            command = f"{self.cmd_str}{self.join_char}{formatted_value}"
            instance.write(command)
            self.last_response = PropertyResponse(
                value=bool_value,
                raw_response=command
            )
        except Exception as e:
            logger.error(f"Error in setter for '{self.cmd_str}': {e}")
            self.last_response = PropertyResponse(
                success=False,
                error=str(e)
            )
            raise

class SelectProperty(Property):
    """
    Property that handles selection from a predefined set of choices.

    Args:
        cmd_str: SCPI command string
        choices: List of valid choices (strings) or Enum class
        doc_str: Documentation string
        access: Access mode ('read', 'write', or 'read-write')
        join_char: Character used to join command and value
    """

    def __init__(self, cmd_str: str, choices: Union[List[str], Type[Enum]], 
                 doc_str: str = "", access: str = "read-write", join_char: str = " "):
        super().__init__(cmd_str, doc_str, access, join_char)
        
        # Handle both enum and list inputs
        self.enum_class = None
        if isinstance(choices, type) and issubclass(choices, Enum):
            self.enum_class = choices
            self.choices = [e.value for e in choices]
        else:
            self.choices = [str(c) for c in choices]
            
        logger.debug(f"Initialized SelectProperty with choices: {self.choices}")

    def _find_match(self, value: Union[str, Enum]) -> str:
        """Find the best match for a value in the choices list."""
        logger.debug(f"Finding match for value: {value}")
        
        # Handle enum input
        if isinstance(value, Enum):
            logger.debug(f"Value is an Enum: {value}")
            return value.value

        # Handle string input
        value_str = str(value).strip().upper()
        logger.debug(f"Normalized string value: {value_str}")
        
        # Create normalized versions of choices for comparison
        norm_choices = {c.strip().upper(): c for c in self.choices}
        
        # Try exact match first
        if value_str in norm_choices:
            logger.debug(f"Found exact match: {norm_choices[value_str]}")
            return norm_choices[value_str]
            
        # Try prefix match
        matches = [
            orig for norm, orig in norm_choices.items()
            if norm.startswith(value_str) or value_str.startswith(norm)
        ]
        
        if len(matches) == 1:
            logger.debug(f"Found unique prefix match: {matches[0]}")
            return matches[0]
            
        if not matches:
            msg = f"Invalid choice: '{value}'. Valid options: {', '.join(self.choices)}"
            logger.error(msg)
            raise ValueError(msg)
        else:
            msg = f"Ambiguous value '{value}' matches multiple choices: {', '.join(matches)}"
            logger.error(msg)
            raise ValueError(msg)

    def getter(self, instance) -> Union[str, Enum]:
        """Get the current selection from the instrument."""
        logger.debug(f"Getting selection for '{self.cmd_str}'")
        try:
            response = instance.query(f"{self.cmd_str}?")
            matched_value = self._find_match(response)
            
            # Convert to enum if applicable
            if self.enum_class:
                result = self.enum_class(matched_value)
                logger.debug(f"Converted to enum: {result}")
            else:
                result = matched_value
                logger.debug(f"Using string value: {result}")
                
            self.last_response = PropertyResponse(
                value=result,
                raw_response=response
            )
            return result
        except Exception as e:
            logger.error(f"Error in getter for '{self.cmd_str}': {e}")
            self.last_response = PropertyResponse(
                success=False,
                error=str(e)
            )
            raise

    def setter(self, instance, value):
        """Set a selection on the instrument."""
        logger.debug(f"Setting '{self.cmd_str}' to {value}")
        try:
            matched_value = self._find_match(value)
            command = f"{self.cmd_str}{self.join_char}{matched_value}"
            instance.write(command)
            self.last_response = PropertyResponse(
                value=matched_value,
                raw_response=command
            )
        except Exception as e:
            logger.error(f"Error in setter for '{self.cmd_str}': {e}")
            self.last_response = PropertyResponse(
                success=False,
                error=str(e)
            )
            raise

class DataProperty(Property):
    """
    Property for handling basic ASCII data arrays.
    
    This property type handles simple arrays of ASCII values like comma-separated 
    lists of numbers. It provides validation and conversion of array data.

    Args:
        cmd_str: SCPI command string
        access: Access mode ('read', 'write', or 'read-write')
        doc_str: Documentation string
        container: Container type for the data (default: numpy.array)
        converter: Function to convert individual values (default: float)
        separator: String separator between values
        join_char: Character used to join command and value
        terminator: Read termination character(s)
    """

    def __init__(self, cmd_str: str, access: str = "read-write", doc_str: str = "",
                 container=np.array, converter: Callable = float, separator: str = ",", 
                 join_char: str = " ", terminator: str = '\n'):
        super().__init__(cmd_str, doc_str, access, join_char)
        self.container = container
        self.converter = converter
        self.separator = separator
        self.terminator = terminator
        logger.debug(
            f"Initialized DataProperty with separator='{separator}', "
            f"terminator='{terminator}'"
        )

    def _convert_to_array(self, response: str) -> Any:
        """Convert a response string into an array of values."""
        logger.debug("Converting response to array")
        try:
            # Split response and filter out empty strings
            values = [v.strip() for v in response.strip().split(self.separator)]
            values = [v for v in values if v]
            
            # Convert values using specified converter
            converted = [self.converter(v) for v in values]
            logger.debug(f"Converted {len(converted)} values")
            
            # Return in specified container
            return self.container(converted)
        except Exception as e:
            msg = f"Error converting response to array: {e}"
            logger.error(msg)
            raise ValueError(msg)

    def _format_array(self, value: Any) -> str:
        """Format an array of values for sending to instrument."""
        logger.debug("Formatting array for transmission")
        try:
            # Convert each value and join with separator
            formatted = self.separator.join(str(self.converter(v)) for v in value)
            if self.terminator and not formatted.endswith(self.terminator):
                formatted += self.terminator
            return formatted
        except Exception as e:
            msg = f"Error formatting array: {e}"
            logger.error(msg)
            raise ValueError(msg)

    def getter(self, instance) -> Any:
        """Get array data from the instrument."""
        logger.debug(f"Getting array data for '{self.cmd_str}'")
        try:
            response = instance.query(f"{self.cmd_str}?")
            array_data = self._convert_to_array(response)
            self.last_response = PropertyResponse(
                value=array_data,
                raw_response=response
            )
            return array_data
        except Exception as e:
            logger.error(f"Error in getter for '{self.cmd_str}': {e}")
            self.last_response = PropertyResponse(
                success=False,
                error=str(e)
            )
            raise

    def setter(self, instance, value):
        """Set array data on the instrument."""
        logger.debug(f"Setting array data for '{self.cmd_str}'")
        if not hasattr(value, '__iter__'):
            raise ValueError(f"Value must be iterable, got {type(value)}")
            
        try:
            formatted_data = self._format_array(value)
            command = f"{self.cmd_str}{self.join_char}{formatted_data}"
            instance.write(command)
            self.last_response = PropertyResponse(
                value=value,
                raw_response=command
            )
        except Exception as e:
            logger.error(f"Error in setter for '{self.cmd_str}': {e}")
            self.last_response = PropertyResponse(
                success=False,
                error=str(e)
            )
            raise

class DataBlockProperty(Property):
    """
    Property for handling binary data blocks with IEEE headers.

    This property type handles binary data transfers with IEEE 488.2 binary block 
    format, often used for waveform data and other large datasets.

    Args:
        cmd_str: SCPI command string
        access: Access mode ('read', 'write', or 'read-write')
        doc_str: Documentation string
        container: Container type for the data (default: numpy.array)
        dtype: NumPy dtype for binary data (default: np.float32)
        ieee_header: Whether to expect/generate IEEE headers (default: True)
    """

    def __init__(self, cmd_str: str, access: str = "read-write", doc_str: str = "",
                 container=np.array, dtype=np.float32, ieee_header: bool = True):
        super().__init__(cmd_str, doc_str, access)
        self.container = container
        self.dtype = dtype
        self.ieee_header = ieee_header
        logger.debug(
            f"Initialized DataBlockProperty with dtype={dtype}, "
            f"ieee_header={ieee_header}"
        )

    def _parse_ieee_header(self, data: bytes) -> Tuple[bytes, int]:
        """
        Parse IEEE 488.2 binary block header.
        Format: '#' + number_of_digits + data_length + data
        Example: #42000 means 4 digits follow, data length is 2000 bytes
        """
        logger.debug("Parsing IEEE header")
        if not data.startswith(b'#'):
            raise ValueError("Invalid IEEE block header: missing '#' marker")

        try:
            num_digits = int(data[1:2])
            header_len = 2 + num_digits
            data_len = int(data[2:header_len])
            logger.debug(f"Found IEEE header: {num_digits} digits, {data_len} bytes")
            return data[header_len:header_len + data_len], header_len
        except Exception as e:
            msg = f"Error parsing IEEE header: {e}"
            logger.error(msg)
            raise ValueError(msg)

    def _format_ieee_block(self, data: np.ndarray) -> bytes:
        """Format data as IEEE 488.2 binary block."""
        logger.debug("Formatting IEEE block")
        try:
            # Convert data to bytes
            raw_data = data.astype(self.dtype).tobytes()
            
            # Create IEEE header
            length_str = str(len(raw_data)).encode()
            header = b'#' + str(len(length_str)).encode() + length_str
            
            return header + raw_data
        except Exception as e:
            msg = f"Error formatting IEEE block: {e}"
            logger.error(msg)
            raise ValueError(msg)

    def getter(self, instance) -> np.ndarray:
        """Get binary block data from the instrument."""
        logger.debug(f"Getting binary data for '{self.cmd_str}'")
        try:
            response = instance.query(f"{self.cmd_str}?")
            
            # Handle binary response
            if isinstance(response, bytes):
                if self.ieee_header:
                    data_bytes, _ = self._parse_ieee_header(response)
                else:
                    data_bytes = response
                    
                # Convert to numpy array
                array_data = np.frombuffer(data_bytes, dtype=self.dtype)
                
            # Handle ASCII response
            else:
                values = [float(v) for v in response.strip().split(',')]
                array_data = np.array(values, dtype=self.dtype)
            
            array_data = self.container(array_data)
            self.last_response = PropertyResponse(
                value=array_data,
                raw_response=response
            )
            return array_data
            
        except Exception as e:
            logger.error(f"Error in getter for '{self.cmd_str}': {e}")
            self.last_response = PropertyResponse(
                success=False,
                error=str(e)
            )
            raise

    def setter(self, instance, value):
        """Set binary block data on the instrument."""
        logger.debug(f"Setting binary data for '{self.cmd_str}'")
        try:
            # Convert input to numpy array if needed
            if not isinstance(value, np.ndarray):
                value = np.array(value, dtype=self.dtype)
                
            # Format data
            if self.ieee_header:
                data = self._format_ieee_block(value)
                command = f"{self.cmd_str}{self.join_char}".encode() + data
            else:
                # Fall back to ASCII if no IEEE header
                command = f"{self.cmd_str}{self.join_char}" + \
                         ",".join(str(x) for x in value)
            
            instance.write(command)
            self.last_response = PropertyResponse(
                value=value,
                raw_response=str(command)
            )
        except Exception as e:
            logger.error(f"Error in setter for '{self.cmd_str}': {e}")
            self.last_response = PropertyResponse(
                success=False,
                error=str(e)
            )
            raise


================================================================================
*** sources.py ***
### src/pymetr/drivers/base/sources.py ###
================================================================================

import logging
logger = logging.getLogger(__name__)
from enum import Enum
from collections.abc import Iterable
from PySide6.QtCore import QObject, Signal
import logging

class Sources(QObject):
    """
    Handles the management and operation of sources for SCPI instruments.

    Attributes:
        source_changed (Signal): Emitted when the list of active sources changes.
    """

    source_changed = Signal(list)

    def __init__(self, sources):
        """
        Initializes the Sources object with the available sources.

        Args:
            sources (list): List of available sources.
        """
        super().__init__()
        self._sources = [source.value if isinstance(source, Enum) else source for source in sources]
        self._source = []
        logger.info("Sources initialized with: %s", self._sources)

    @property
    def source(self):
        """
        Returns the list of active sources.

        Returns:
            list: Active sources.
        """
        return self._source

    @source.setter
    def source(self, sources):
        """
        Sets the active sources from the available sources.

        Args:
            sources (list): List of sources to set as active.
        """
        self._source = [source for source in sources if source in self._sources]
        logger.debug("Active source set to: %s", self._source)
        self.source_changed.emit(self._source)

    @property
    def sources(self):
        """
        Returns the list of available sources.

        Returns:
            list: Available sources.
        """
        return self._sources

    def add_source(self, source):
        """
        Adds a source to the list of active sources if it's available and not already active.

        Args:
            source (str or Enum): Source to add to the active sources.
        """
        source = source.value if isinstance(source, Enum) else source
        if source in self._sources and source not in self._source:
            self._source.append(source)
            logger.info("Added active source: %s", source)
            self.source_changed.emit(self._source)

    def remove_source(self, source):
        """
        Removes a source from the list of active sources if it's currently active.

        Args:
            source (str or Enum): Source to remove from the active sources.
        """
        source = source.value if isinstance(source, Enum) else source
        if source in self._source:
            self._source.remove(source)
            logger.info("Removed active source: %s", source)
            self.source_changed.emit(self._source)

    def set_sources(self, sources):
        """
        Sets the list of active sources from the available sources.

        Args:
            sources (list): List of sources to set as active.
        """
        self._source = [source.value if isinstance(source, Enum) else source for source in sources if source in self._sources]
        logger.debug("Active sources set to: %s", self._source)
        self.source_changed.emit(self._source)

    @staticmethod
    def source_command(command_template=None, formatter=None, single=False, join_str=', '):
        """
        Decorator for source-related commands.

        The `source_command` decorator is used to handle source-related commands in a flexible manner.
        It allows you to specify a command template, source formatting, and whether to handle sources
        individually or collectively.

        Usage Examples:
            @Sources.source_command(":DIGitize {}", single=True)
            def digitize(self, source):
                # Digitizes the specified source individually.
                pass

            @Sources.source_command(":calculate:measurement {}", formatter="'{}'", join_str=', ')
            def calculate_measurement(self, *sources):
                # Calculates the measurement for the specified sources.
                pass

            @Sources.source_command(single=True)
            def custom_function_single(self, source):
                # Performs a custom operation on each source individually.
                pass

            @Sources.source_command()
            def custom_function_multi(self, *sources):
                # Performs a custom operation on multiple sources.
                pass

        Args:
            command_template (str, optional): Template for the SCPI command. Defaults to None.
            formatter (str, optional): Formatter for the sources. Defaults to None.
            single (bool, optional): Whether to handle sources individually. Defaults to False.
            join_str (str, optional): String to join multiple sources. Defaults to ', '.

        Returns:
            function: Decorated function.
        """
        def decorator(func):
            def wrapper(self, *args, **kwargs):
                sources_to_use = self.sources.source if not args else args

                if isinstance(sources_to_use, Enum):
                    sources_to_use = [sources_to_use]
                elif not isinstance(sources_to_use, Iterable) or isinstance(sources_to_use, str):
                    sources_to_use = [sources_to_use]

                cleaned_sources = [source.value if isinstance(source, Enum) else source for source in sources_to_use]

                if formatter:
                    cleaned_sources = [formatter.format(source) for source in cleaned_sources]

                if command_template:
                    if single:
                        for source in cleaned_sources:
                            command = command_template.format(source)
                            logger.debug(f"Executing command: {command}")
                            self.write(command)
                            func(self, source, **kwargs)
                    else:
                        command = command_template.format(join_str.join(cleaned_sources))
                        logger.debug(f"Executing command: {command}")
                        self.write(command)
                        return func(self, *cleaned_sources, **kwargs)
                else:
                    if single:
                        for source in cleaned_sources:
                            func(self, source, **kwargs)
                    else:
                        return func(self, *cleaned_sources, **kwargs)

            return wrapper
        return decorator
    


================================================================================
*** visitor.py ***
### src/pymetr/drivers/base/visitor.py ###
================================================================================

import ast
import os
from copy import deepcopy


from pymetr.core.logging import logger

class InstrumentVisitor(ast.NodeVisitor):
    def __init__(self):
        super().__init__()
        self.instruments = {}
        self.current_instrument = None
        self.current_subsystem = None
        logger.debug(" InstrumentVisitor initialized ")

    def build_instrument_data_model(self, driver_source: str) -> dict:
        """
        Parse the provided driver source code and extract instrument data.
        
        Args:
            driver_source: The source code of the driver (as a string).
            
        Returns:
            A dictionary with the instrument data.
        """
        try:
            tree = ast.parse(driver_source)
            # Reset instruments dictionary before visiting
            self.instruments = {}
            self.visit(tree)
            logger.debug(f"InstrumentVisitor: Completed extraction. Instruments: {list(self.instruments.keys())}")
            return self.instruments
        except Exception as e:
            logger.error(f"Error in create_instrument_data_from_driver: {e}")
            return {}
        
    def visit_ClassDef(self, node):
        logger.debug(f" Visiting Class Definition: {node.name} ")
        bases = [base.id for base in node.bases if isinstance(base, ast.Name)]
        if any(base in ['Instrument', 'SCPIInstrument'] for base in bases):
            self.current_instrument = node.name
            logger.debug(f" Found Instrument: {self.current_instrument} ")
            self.instruments[node.name] = {
                'subsystems': {},
                'properties': [],
                'methods': {},
                'gui_methods': {},
                'other_methods': {},
                'sources': []
            }
            self.extract_instrument_info(node)

        elif 'Subsystem' in bases and self.current_instrument:
            logger.debug(f" Found Subsystem: {node.name} within {self.current_instrument} ")
            subsystem_visitor = SubsystemVisitor()
            subsystem_visitor.visit(node)
            subsystem_info = self.instruments[self.current_instrument]['subsystems'].get(node.name, {
                'properties': [],
                'methods': [],
                'instances': {}
            })

            if subsystem_info.get('needs_indexing', False):
                self.handle_indexed_subsystem(node, subsystem_info, subsystem_visitor.properties_methods)
            else:
                self.instruments[self.current_instrument]['subsystems'][node.name].update(subsystem_visitor.properties_methods)
            logger.debug(f" Subsystem info updated for {node.name} in {self.current_instrument} ")

        super().generic_visit(node)

    def extract_instrument_info(self, node):
        for item in node.body:
            if isinstance(item, ast.FunctionDef) and not item.name.startswith('_'):
                self.extract_method_info(item)
            elif isinstance(item, ast.Assign):
                self.process_assignment(item)

    def extract_method_info(self, item):
        logger.debug(f"Found method in {self.current_instrument}: {item.name}")
        method_info = {
            'args': [arg.arg for arg in item.args.args if arg.arg != 'self'],
            'return': self.get_return_annotation(item),
            'is_gui_method': self.is_gui_method(item)
        }
        if method_info['is_gui_method']:
            self.instruments[self.current_instrument]['gui_methods'][item.name] = method_info
        else:
            self.instruments[self.current_instrument]['other_methods'][item.name] = method_info

    def is_gui_method(self, node):
        for decorator in node.decorator_list:
            if (isinstance(decorator, ast.Attribute) and
                isinstance(decorator.value, ast.Name) and
                decorator.value.id == 'Instrument' and
                decorator.attr == 'gui_command'):
                return True
        return False

    def process_assignment(self, item):
        if (isinstance(item.value, ast.Call) and
                isinstance(item.value.func, ast.Name) and
                item.value.func.id == 'Sources'):
            sources_list = self.get_ast_node_value(item.value.args[0])
            self.instruments[self.current_instrument]['sources'] = sources_list
            logger.debug(f"Captured Sources for {self.current_instrument}: {sources_list}")

    def get_return_annotation(self, node):
        if node.returns:
            if isinstance(node.returns, ast.Name):
                return node.returns.id
            elif isinstance(node.returns, ast.Attribute):
                return f"{node.returns.value.id}.{node.returns.attr}"
        return None

    def handle_indexed_subsystem(self, node, subsystem_info, properties_methods):
        for index in range(1, subsystem_info['indices'] + 1):
            logger.debug(f" Indexing {index} in {node.name} ")
            instance_info = deepcopy(properties_methods)
            self.instruments[self.current_instrument]['subsystems'][node.name]['instances'][index] = instance_info

    def visit_Assign(self, node):
        if self.current_instrument:
            if isinstance(node.value, ast.Call) and getattr(node.value.func, 'attr', '') == 'build':
                logger.debug(f" Parsing build call in {self.current_instrument} ")
                subsystem_class_name = node.value.func.value.id
                indices = next((self.get_ast_node_value(kw.value) for kw in node.value.keywords if kw.arg == 'indices'), 1)

                subsystem_info = {
                    'indices': indices,
                    'needs_indexing': indices > 1,
                    'properties': [],
                    'methods': [],
                    'instances': {} if indices > 1 else None
                }
                self.instruments[self.current_instrument]['subsystems'][subsystem_class_name] = subsystem_info
                logger.debug(f" Subsystem {subsystem_class_name} initialized with indexing: {indices > 1} ")
            elif (isinstance(node.value, ast.Call) and
                isinstance(node.value.func, ast.Name) and
                node.value.func.id == 'Sources'):
                logger.debug(f"Found Sources initialization: {ast.dump(node.value)}")
                sources_list = []
                
                # Check for positional arguments
                if node.value.args:
                    sources_arg = node.value.args[0]
                    if isinstance(sources_arg, ast.List):
                        sources_list = [el.value for el in sources_arg.elts]
                
                # Check for keyword arguments
                sources_keyword = next((kw for kw in node.value.keywords if kw.arg == 'sources'), None)
                if sources_keyword and isinstance(sources_keyword.value, ast.List):
                    sources_list = [el.value for el in sources_keyword.value.elts]
                
                if sources_list:
                    self.instruments[self.current_instrument]['sources'] = sources_list
                    logger.debug(f"Captured Sources for {self.current_instrument}: {sources_list}")
                else:
                    logger.warning(f"No sources found in Sources initialization for {self.current_instrument}")
        
        super().generic_visit(node)

    def get_ast_node_value(self, node):
        if isinstance(node, ast.Constant):
            return node.value
        elif isinstance(node, ast.Name):
            return node.id
        elif isinstance(node, ast.List):
            return [self.get_ast_node_value(el) for el in node.elts]
        elif isinstance(node, ast.Dict):
            return {key.value: self.get_ast_node_value(value) for key, value in zip(node.keys, node.values)}
        elif isinstance(node, ast.UnaryOp):
            operand = self.get_ast_node_value(node.operand)
            if isinstance(node.op, ast.UAdd):
                return +operand
            elif isinstance(node.op, ast.USub):
                return -operand
        else:
            logger.error(f"Unhandled node type: {type(node).__name__}")
            logger.debug(f"Node dump: {ast.dump(node)}")
            return None

class SubsystemVisitor(ast.NodeVisitor):
    def __init__(self):
        super().__init__()
        self.properties_methods = {'properties': [], 'methods': []}
        self.current_subsystem = None
        logger.debug(" Initialized SubsystemVisitor ")

    def visit_ClassDef(self, node):
        bases = [base.id for base in node.bases if isinstance(base, ast.Name)]
        if 'Subsystem' in bases:
            self.current_subsystem = node.name
            logger.debug(f" Visiting Subsystem: {self.current_subsystem} ")
        self.generic_visit(node)
        if self.current_subsystem == node.name:
            self.current_subsystem = None

    def visit_Assign(self, node):
        logger.debug(f" Visiting Assign Node: {ast.dump(node)} ")
        if isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name):
            prop_class_name = node.value.func.id
            if prop_class_name in ['SelectProperty', 'ValueProperty', 'SwitchProperty', 'StringProperty', 'DataProperty']:
                logger.debug(f" Found a property: {prop_class_name} ")
                prop_name = node.targets[0].id
                prop_details = self.parse_property_details(node.value, prop_class_name, prop_name)
                if prop_details:
                    if self.current_subsystem:
                        prop_details['subsystem'] = self.current_subsystem
                    self.properties_methods['properties'].append(prop_details)
                    logger.debug(f" Added property details for {prop_name}: {prop_details} ")
        super().generic_visit(node)

    def parse_property_details(self, call_node, prop_class_name, prop_name):
        logger.debug(f" Parsing property details for type: {prop_class_name} ")
        details = {'type': prop_class_name, 'name': prop_name}
        
        for kw in call_node.keywords:
            if kw.arg == 'access':
                details['access'] = self.get_ast_node_value(kw.value)
                logger.debug(f" Access mode set for {prop_name}: {details['access']} ")

        if prop_class_name == 'SelectProperty':
            if len(call_node.args) > 1:
                choices_arg = call_node.args[1]
                if isinstance(choices_arg, ast.List):
                    details['choices'] = [self.get_ast_node_value(el) for el in choices_arg.elts]
                    logger.debug(f" Choices set for SelectProperty: {details['choices']} ")

        elif prop_class_name == 'ValueProperty':
            for kw in call_node.keywords:
                if kw.arg in ['type', 'range', 'units', 'doc_str']:
                    details[kw.arg] = self.get_ast_node_value(kw.value)
                    logger.debug(f" Setting {kw.arg}: {details[kw.arg]} ")

        elif prop_class_name in ['SwitchProperty', 'StringProperty', 'DataProperty']:
            logger.debug(f" No additional processing needed for {prop_class_name} ")

        else:
            logger.warning(f" Unsupported property class: {prop_class_name} ")

        return details

    def get_ast_node_value(self, node):
        if isinstance(node, ast.Constant):
            return node.value
        elif isinstance(node, ast.Name):
            return node.id
        elif isinstance(node, ast.List):
            return [self.get_ast_node_value(el) for el in node.elts]
        elif isinstance(node, ast.UnaryOp):
            operand = self.get_ast_node_value(node.operand)
            if isinstance(node.op, ast.UAdd):
                return +operand
            elif isinstance(node.op, ast.USub):
                return -operand
        else:
            logger.error(f"Unhandled node type: {type(node).__name__}")
            return None
    
if __name__ == "__main__":

    def print_consolidated_view(instrument):
        for instrument_name, instrument_info in instrument.items():
            print(f"{instrument_name}/")

            # Print sources
            print(" Sources")
            for source in instrument_info['sources']:
                print(f"    {source}")

            # Print GUI methods
            print(" GUI Methods")
            for method_name, method_info in instrument_info['gui_methods'].items():
                args_str = ', '.join(method_info['args'])
                return_str = f" -> {method_info['return']}" if method_info['return'] else ""
                print(f"    {method_name}({args_str}){return_str}")

            # Print other methods
            print(" Other Methods")
            for method_name, method_info in instrument_info['other_methods'].items():
                args_str = ', '.join(method_info['args'])
                return_str = f" -> {method_info['return']}" if method_info['return'] else ""
                print(f"    {method_name}({args_str}){return_str}")

            # Print subsystems and their properties
            subsystems = instrument_info['subsystems'].items()
            for subsystem_name, subsystem_info in subsystems:
                if 'instances' in subsystem_info and subsystem_info['instances']:
                    print(f" {subsystem_name}")
                    for instance_name, instance_info in subsystem_info['instances'].items():
                        print(f"    {instance_name}")
                        print_properties(instance_info['properties'], is_last=False)
                else:
                    print(f" {subsystem_name}")
                    print_properties(subsystem_info['properties'], is_last=False)
            print()  # For a newline after each instrument

    def print_properties(properties, is_last):
        indent = "      " if not is_last else "    "  # Adjust the indentation based on hierarchy
        for prop in properties:
            prop_summary = format_property_summary(prop)
            print(f"{indent} {prop_summary}")

    def format_property_summary(prop):
        """Formats a property summary based on its type and details."""
        prop_type = prop.get('type')
        summary_parts = [f"{prop['name']} ({prop_type})"]
        if 'choices' in prop:
            if isinstance(prop['choices'][0], str):
                choices_str = ", ".join(prop['choices'])
                summary_parts.append(f"[Choices: {choices_str}]")
            else:
                summary_parts.append(f"[Choices: {len(prop['choices'])} items]")
        elif 'range' in prop:
            range_str = f"[Range: {prop['range'][0]} to {prop['range'][1]}]"
            summary_parts.append(range_str)
        if 'units' in prop:
            summary_parts.append(f"[Units: {prop['units']}]")
        if 'access' in prop:
            summary_parts.append(f"[Access: {prop['access']}]")
        return " ".join(summary_parts)
    
    # Get the directory of the current script.
    current_dir = os.path.dirname(os.path.abspath(__file__))

    # Construct the path: one directory above, then into drivers/instruments
    path = os.path.join(current_dir, '..', 'drivers', 'instruments', 'dsox1204g.py')
    path = os.path.abspath(path)  # Normalize the path

    with open(path, 'r') as file:
        source = file.read()

    tree = ast.parse(source, filename=path)

    visitor = InstrumentVisitor()
    visitor.visit(tree)  # Build the instrument data model

    print_consolidated_view(visitor.instruments)
    #print(visitor.instruments)


================================================================================
*** __init__.py ***
### src/pymetr/drivers/instruments/__init__.py ###
================================================================================

# from .registry import DRIVER_REGISTRY, get_driver_info
# from .dsox1204g import Dsox1204g
# from .hp8563a import HP8563A
# from .hs9000 import HSXSynth

# __all__ = [
#     'DRIVER_REGISTRY',
#     'get_driver_info',
#     'Dsox1204g',
#     'HP8563A', 
#     'HSXSynth'
# ]


================================================================================
*** dsox1204g.py ***
### src/pymetr/drivers/instruments/dsox1204g.py ###
================================================================================

# dsox1204g.py
"""
Keysight DSOX1204G Oscilloscope Driver

Rewritten to use the new queue-based architecture:
 - Inherits from SCPIInstrument (async read/write/query).
 - Removes direct QThread/QTimer references.
 - Each method enqueues commands for the worker to process.
 - 'fetch_trace()' is turned into an asynchronous method that returns data 
   after an acquisition is complete, using a DataBlockProperty or a callback.

Usage in your scripts or UI code remains mostly the same, but be aware all 
communication is now asynchronous.
"""

import logging
import numpy as np

from pymetr.drivers.base import SCPIInstrument
from pymetr.drivers.base import Subsystem
from pymetr.drivers.base.sources import Sources
from pymetr.models import Trace
from pymetr.drivers.base.properties import (
    SwitchProperty,
    SelectProperty,
    ValueProperty,
    DataProperty,
    DataBlockProperty
)

logger = logging.getLogger(__name__)


class Dsox1204g(SCPIInstrument):
    """
    Driver for Keysight DSOX1204G. Demonstrates:
     - Asynchronous SCPI commands
     - Subsystems for waveforms, triggers, timebase, etc.
     - fetch_trace() example using DataBlockProperty
    """

    def __init__(self, connection):
        """
        Args:
            connection: a ConnectionInterface object 
                        (PyVisaConnection, RawSocketConnection, etc.).
        """
        super().__init__(connection)

        self._format = "BYTE"  # Global data format
        self.sources = Sources(['CHAN1', 'CHAN2', 'CHAN3', 'CHAN4'])
        self.sources.source = ["CHAN1"]

        # X-axis data caching for repeated fetches
        self.x_data = {}

        # Build subsystems
        self.waveform = Waveform.build(self, ':WAVeform')
        self.trigger  = Trigger.build(self, ':TRIGger')
        self.timebase = Timebase.build(self, ':TIMebase')
        self.wavegen  = WaveGen.build(self, ':WGEN')
        self.acquire  = Acquire.build(self, ':ACQuire')
        self.channel  = Channel.build(self, ':CHANnel', indices=4)

    # ------------------------------------------------
    # "format" property controlling global data format
    # ------------------------------------------------
    @property
    def format(self):
        return self._format

    @format.setter
    def format(self, new_fmt):
        if new_fmt not in ["ASCII", "BYTE", "WORD"]:
            raise ValueError("Invalid data format. Must be 'ASCII', 'BYTE', or 'WORD'.")
        self._format = new_fmt

    # ------------------------------------------------
    # GUI Commands (decorators)
    # ------------------------------------------------
    @SCPIInstrument.gui_command
    @Sources.source_command(":AUTOScale {}")
    def autoscale(self, *sources):
        """
        Autoscale the scope for given channels. 
        Because the decorator is used, the UI can auto-generate a button.
        """
        pass

    @SCPIInstrument.gui_command
    def digitize(self, *sources):
        """
        Calls fetch_trace() (async) to get a fresh trace from the scope.
        """
        logger.debug("Digitize command called.")
        self.fetch_trace()

    @SCPIInstrument.gui_command
    def single(self):
        """
        Performs a single acquisition:
         1) Stop
         2) *OPC? wait
         3) :SINGle
         4) Wait for armed + acquisition done
         5) fetch_trace()
        """
        logger.debug("Single trigger command received.")
        self.continuous_mode = False
        self.write(":STOP")
        self.query_operation_complete()   # async *OPC?
        self.write(":SINGle")
        self._enqueue_check_trigger_armed()

    @SCPIInstrument.gui_command
    def stop(self):
        logger.debug("Stop command received.")
        self.write(":STOP")
        self.continuous_mode = False

    @SCPIInstrument.gui_command
    def run(self):
        """
        Puts scope in continuous run mode, then starts checking triggers 
        in the background if desired. 
        """
        logger.debug("Run command received.")
        self.write(":RUN")
        self.continuous_mode = True
        # If you want to keep polling the scope in the background, 
        # you can do something like self._enqueue_check_trigger_armed() again.
        # but let's keep it minimal unless you need continuous data

    # ------------------------------------------------
    # Checking armed or acquisition done
    # ------------------------------------------------
    def _enqueue_check_trigger_armed(self):
        """
        We enqueue a command to query(":AER?"), then parse the response 
        in responseReceived to see if armed=1. 
        If not armed, we re-enqueue a short 'delay' or re-check. 
        Once armed, call wait_for_acquisition_complete.
        """
        logger.debug("Enqueue check_trigger_armed -> :AER?")
        self.query(":AER?")

    def _enqueue_check_acquisition_done(self):
        logger.debug("Enqueue check_acquisition_done -> :OPERegister:CONDition?")
        self.query(":OPERegister:CONDition?")

    # If you want to handle these in responseReceived, you can parse the value 
    # and re-enqueue if not done, or call fetch_trace when done.

    # ------------------------------------------------
    # Asynchronous fetch_trace
    # ------------------------------------------------
    @Sources.source_command(":DIGitize {}")
    def fetch_trace(self, *sources):
        """
        1) :DIGitize (enqueued by decorator).
        2) *OPC? wait or manual check (we can do query_operation_complete here).
        3) read the waveforms for each active channel, build a list of Trace objects, return them.

        Because of the @trace_thread decorator, the returning data 
        is automatically emitted to `traceDataReady` signal as well.
        """
        self.query_operation_complete()
        logger.debug(f"Fetching trace data from scope {self}")
        if not sources:
            sources = self.sources.source

        traces = []
        for source in sources:
            time_vals = self._fetch_time(source)
            data_vals = self._fetch_data(source)
            trace_obj = Trace(data_vals, x_data=time_vals, label=source)
            traces.append(trace_obj)

        return traces

    def _fetch_time(self, source=None):
        """
        Gets the horizontal scale info from the waveform preamble, builds time array.
        """
        if source:
            self.waveform.source = source

        try:
            preamble = self.waveform.preamble
            self._x_increment, self._x_origin, self._x_reference = preamble[4], preamble[5], int(preamble[6])
            self._y_increment, self._y_origin, self._y_reference = preamble[7], preamble[8], int(preamble[9])
            self.waveform.format = self._format

            count_points = self.waveform.points
            timestamps = (np.arange(count_points) - self._x_reference) * self._x_increment + self._x_origin
            return timestamps
        except Exception as e:
            raise ValueError(f"Issue fetching or parsing preamble: {e}")

    def _fetch_data(self, source=None):
        """
        Fetch raw data from self.waveform.data, convert if binary, etc.
        """
        if source:
            self.waveform.source = source

        self.waveform.format = self.format
        is_unsigned = self.waveform.unsigned

        if self._format in ["BYTE", "WORD"]:
            # e.g. 'B' vs 'b' for data_type
            data_type = 'B' if is_unsigned else 'b'
            self.data_type = data_type
            self.data_mode = "BINARY"
        else:
            self.data_type = 'B'
            self.data_mode = "ASCII"

        # read the raw data
        raw_data = self.waveform.data

        # Convert if binary:
        if self._format in ["BYTE", "WORD"]:
            voltages = (raw_data - self._y_reference) * self._y_increment + self._y_origin
        elif self._format == "ASCII":
            voltages = raw_data
        else:
            raise ValueError(f"Unsupported data format: {self.format}")

        return voltages


# ---------------------------------------------------------------------------
# Subsystems
# ---------------------------------------------------------------------------
class Acquire(Subsystem):
    mode         = SelectProperty(":MODE", ['RTIMe', 'SEGMmented'], "Acquisition mode")
    type         = SelectProperty(":TYPE", ['NORMal','AVERage','HRESolution','PEAK'], "Acq type")
    sample_rate  = ValueProperty(":SRATe",  type="float", range=[0.1, 1e9], units="S/s", doc_str="Sample rate")
    count        = ValueProperty(":COUNt", type="int",   range=[1, 10000],  doc_str="Averaging count / acquisitions")

class Channel(Subsystem):
    coupling = SelectProperty(":COUPling", ['AC', 'DC'], "Channel coupling")
    display  = SwitchProperty(":DISPlay",  "Channel on/off")
    scale    = ValueProperty(":SCALe",     type="float", range=[1e-3,1e3], units="V", doc_str="Vert scale")
    offset   = ValueProperty(":OFFSet",    type="float", range=[-1e2,1e2], units="V", doc_str="Vertical offset")
    probe    = ValueProperty(":PROBe",     type="float", doc_str="Probe attenuation")

class Timebase(Subsystem):
    mode       = SelectProperty(":MODE",       ['MAIN','WIND','XY','ROLL'], "Timebase mode")
    reference  = SelectProperty(":REFerence",  ['LEFT','CENTer','RIGHT'],   "Timebase ref")
    scale      = ValueProperty(":SCALe",       type="float", range=[1e-9,1.0],units="s", doc_str="Timebase scale")
    position   = ValueProperty(":POSition",    type="float", range=[-5.0,5.0],units="s", doc_str="Timebase pos")
    range      = ValueProperty(":RANGe",       type="float", range=[2e-9,50], units="s", doc_str="Timebase range")

class Trigger(Subsystem):
    mode   = SelectProperty(":MODe",   ['EDGE','GLITch','PATTern','SHOL','NONE'], "Trig mode")
    source = SelectProperty(":SOURce", ['CHAN1','CHAN2','CHAN3','CHAN4','EXT','LINE','WGEN'], "Trig source")
    slope  = SelectProperty(":SLOPe",  ['POSitive','NEGative'], "Trig slope")
    sweep  = SelectProperty(":SWEep",  ['AUTO','NORMAL'],       "Sweep mode")
    level  = ValueProperty(":LEVel",   type="float", range=[-5,5],units="V", doc_str="Trig level")

class WaveGen(Subsystem):
    function   = SelectProperty(":FUNC",  ['SIN','SQUare','RAMP','PULSe','NOISe','DC'], "Wavegen function")
    output     = SwitchProperty(":OUTP", "Wavegen output on/off")
    frequency  = ValueProperty(":FREQ",  type="float", range=[1e-3,1e8], units="Hz", doc_str="Wavegen freq")
    amplitude  = ValueProperty(":VOLT",  type="float", range=[1e-3,10],  units="V",  doc_str="Wavegen amplitude")
    offset     = ValueProperty(":VOLT:OFFS",type="float",range=[-5,5],   units="V",  doc_str="Wavegen offset")

class Waveform(Subsystem):
    source       = SelectProperty(":SOURce", ['CHAN1','CHAN2','CHAN3','CHAN4','FUNC','MATH','FFT','WMEM','BUS1','BUS2','EXT'], "Waveform src")
    format       = SelectProperty(":FORMat", ['ASCII','WORD','BYTE'],  "Waveform data fmt")
    points_mode  = SelectProperty(":POINts:MODE", ['NORMal','MAXimum','RAW'], "Points mode")
    byte_order   = SelectProperty(":BYTeorder", ['LSBFirst','MSBFirst'],      "Byte order")
    unsigned     = SwitchProperty(":UNSigned", "Data signed or unsigned")
    points       = ValueProperty(":POINts",  type="int", access='write', doc_str="Trace points to fetch")
    x_increment  = DataProperty(":XINCrement", doc_str="Waveform X incr")
    x_origin     = DataProperty(":XORigin",     doc_str="Waveform X origin")
    x_reference  = DataProperty(":XREFerence",  doc_str="Waveform X ref")
    y_increment  = DataProperty(":YINCrement", doc_str="Waveform Y incr")
    y_origin     = DataProperty(":YORigin",     doc_str="Waveform Y origin")
    y_reference  = DataProperty(":YREFerence",  doc_str="Waveform Y ref")
    preamble     = DataProperty(":PREamble", access='read', doc_str="Pre info")
    data         = DataBlockProperty(":DATa",   access='read', ieee_header=True, doc_str="Waveform data array")



================================================================================
*** hp8563a.py ***
### src/pymetr/drivers/instruments/hp8563a.py ###
================================================================================

# hp8563a.py

"""
HP 8563A Spectrum Analyzer Driver with improved non-blocking trace acquisition
"""

import logging
from enum import Enum
import numpy as np

from pymetr.drivers.base.subsystem import Subsystem
from pymetr.drivers.base.scpi_instrument import SCPIInstrument
from pymetr.drivers.base.properties import (
    ValueProperty, SelectProperty, SwitchProperty, DataProperty
)

logger = logging.getLogger(__name__)

class TriggerMode(Enum):
    FREE = "FREE"
    SINGLE = "SNGLS"
    LINE = "LINE"
    VIDEO = "VID"
    EXTERNAL = "EXT"

class ScaleType(Enum):
    LINEAR = "LIN"
    LOG = "LOG"

class DetectorMode(Enum):
    NORMAL = "NRM"
    POSITIVE = "POS"
    NEGATIVE = "NEG"
    SAMPLE = "SMP"

class FrequencySubsystem(Subsystem):
    """Frequency control subsystem"""
    center = ValueProperty("CF", type="float", doc_str="Center freq (e.g. '1GHz')")
    span = ValueProperty("SP", type="float", doc_str="Span freq (e.g. '100MHz')")
    start = ValueProperty("FA", type="float", doc_str="Start frequency")
    stop = ValueProperty("FB", type="float", doc_str="Stop frequency")

class AmplitudeSubsystem(Subsystem):
    """Amplitude and attenuation control"""
    reference_level = ValueProperty("RL", type="float", range=(-139.9, 30), units="dBm", doc_str="Reference level")
    attenuation = ValueProperty("AT", type="float", range=(0, 70), units="dB", doc_str="Input attenuation")
    scale_type = SelectProperty("SCAL", ["LIN", "LOG"], doc_str="Amplitude scale type")

class BandwidthSubsystem(Subsystem):
    """Resolution and video bandwidth control"""
    resolution = ValueProperty("RB", type="float", range=(10, 3e6), units="Hz", doc_str="Resolution bandwidth")
    video = ValueProperty("VB", type="float", range=(1, 3e6), units="Hz", doc_str="Video bandwidth")

class SweepSubsystem(Subsystem):
    """Sweep control subsystem"""
    time = ValueProperty("ST", type="float", range=(20e-6, 100), units="s", doc_str="Sweep time")
    auto_time = SwitchProperty("ST AUTO", doc_str="Auto sweep time")
    trigger_mode = SelectProperty("TM", TriggerMode, doc_str="Trigger mode selection")
    continuous = SwitchProperty("CONTS", doc_str="Continuous sweep")

class TraceSubsystem(Subsystem):
    """Trace data and display control"""
    detector = SelectProperty("DET", DetectorMode, doc_str="Trace detector mode")
    data = DataProperty("TRA", access='read', doc_str="Trace A data (601 points)", 
                       container=np.array, converter=float, separator=',', terminator='\r\n')

class HP8563A(SCPIInstrument):
    """
    HP8563A Spectrum Analyzer driver with improved non-blocking trace acquisition.
    
    Features:
    - Full frequency control (start/stop/center/span)
    - Resolution and video bandwidth
    - Reference level and attenuation
    - Sweep and trigger controls
    - Non-blocking trace data acquisition
    """

    def __init__(self, connection):
        super().__init__(connection)
        logger.debug("Initializing HP8563A Spectrum Analyzer Driver")

        # Build subsystems
        logger.debug("Building subsystems")
        self.frequency = FrequencySubsystem.build(self, "")
        self.amplitude = AmplitudeSubsystem.build(self, "")
        self.bandwidth = BandwidthSubsystem.build(self, "")
        self.sweep = SweepSubsystem.build(self, "")
        self.trace = TraceSubsystem.build(self, "")
        logger.debug("Subsystems initialized successfully")

        # Initialize state
        self._sweep_in_progress = False
        self._sweep_complete = False

    def fetch_trace(self):
        """
        Start trace acquisition and emit signal when complete.
        Uses non-blocking reads to prevent UI blocking.
        """
        try:
            logger.debug("Starting trace acquisition")
            
            # Clear any previous sweep state
            self._sweep_in_progress = False
            self._sweep_complete = False
            
            # Put in single sweep mode and start sweep
            self.sweep.trigger_mode = TriggerMode.SINGLE
            self.write("SNGLS")
            self._sweep_in_progress = True
            
            # Get sweep parameters using property system
            start_freq = self.frequency.start
            stop_freq = self.frequency.stop
            sweep_time = self.sweep.time
            
            # Now read the trace data - this will use our non-blocking read implementation
            amp_data = self.trace.data
            
            # Create frequency axis
            freq_points = len(amp_data)
            freq_axis = np.linspace(start_freq, stop_freq, freq_points)
            
            # Emit the data
            self.traceDataReady.emit(freq_axis, amp_data)
            logger.debug(f"Emitted trace data: {freq_points} points")
            
            self._sweep_complete = True
            self._sweep_in_progress = False
            
            return freq_axis, amp_data
        
        except Exception as e:
            self._sweep_in_progress = False
            logger.error(f"Error in fetch_trace: {e}")
            self.exceptionOccured.emit(str(e))
            raise

    def is_sweep_complete(self) -> bool:
        """Check if the current sweep operation is complete."""
        if not self._sweep_in_progress:
            return self._sweep_complete
            
        try:
            # Check sweep status
            response = self.query("DONE?")
            if response.strip() == "1":
                self._sweep_in_progress = False
                self._sweep_complete = True
                
        except Exception as e:
            logger.error(f"Error checking sweep status: {e}")
            self._sweep_in_progress = False
            
        return self._sweep_complete

    def abort_sweep(self):
        """Abort the current sweep operation."""
        try:
            self.write("ABORT")
            self._sweep_in_progress = False
            self._sweep_complete = False
        except Exception as e:
            logger.error(f"Error aborting sweep: {e}")
            raise

    def single_sweep(self):
        """Initiates a single sweep."""
        logger.debug("Initiating single sweep")
        try:
            self.sweep.trigger_mode = TriggerMode.SINGLE
            self.write("SNGLS")
            self._sweep_in_progress = True
            self._sweep_complete = False
        except Exception as e:
            logger.error(f"Error initiating single sweep: {e}")
            raise

    def continuous_sweep(self):
        """Sets continuous sweep mode."""
        logger.debug("Setting continuous sweep mode")
        try:
            self.sweep.trigger_mode = TriggerMode.FREE
            self.write("CONT")
            self._sweep_in_progress = False
            self._sweep_complete = False
        except Exception as e:
            logger.error(f"Error setting continuous sweep mode: {e}")
            raise

    def preset(self):
        """Presets the instrument to default state."""
        logger.debug("Presetting instrument to default state")
        try:
            self.write("IP")
            self._sweep_in_progress = False
            self._sweep_complete = False
        except Exception as e:
            logger.error(f"Error presetting instrument: {e}")
            raise

    def get_identity(self) -> str:
        """
        Query the instrument identity (*IDN?).
        
        Returns:
            str: The instrument's identification string
        """
        logger.debug("Querying instrument identity")
        try:
            identity = self.query("ID?")
            logger.debug(f"Instrument identity: {identity}")
            return identity
        except Exception as e:
            logger.error(f"Error querying instrument identity: {e}")
            raise

    def check_error(self) -> tuple[int, str]:
        """
        Query the error queue.
        
        Returns:
            tuple: (error_code, error_message)
        """
        try:
            response = self.query("ERR?")
            code = int(response)
            msg = {
                0: "No error",
                -410: "Query INTERRUPTED",
                -420: "Query UNTERMINATED",
                -430: "Query DEADLOCKED"
            }.get(code, "Unknown error")
            return code, msg
        except Exception as e:
            logger.error(f"Error checking error queue: {e}")
            raise


================================================================================
*** hs9000.py ***
### src/pymetr/drivers/instruments/hs9000.py ###
================================================================================

import logging
from pymetr.drivers.base import SCPIInstrument
from pymetr.drivers.base import Subsystem
from pymetr.drivers.base.properties import (
    ValueProperty, SelectProperty, SwitchProperty
)

logger = logging.getLogger(__name__)

class HS9000(SCPIInstrument):
    """
    HSX Series Synthesizer Driver

    Features:
    - Multiple channels (CH1..CHn) for freq/power/phase control
    - Reference clock selection and monitoring
    - Built-in diagnostics
    - Network configuration
    - Temperature monitoring

    Usage:
        synth = HSXSynth(connection, channels=4)
        synth.ch[1].frequency = "2105MHz"
        synth.ch[2].output = True
        synth.ref.source = "EXT:10MHz"
        synth.diag.start()
    """

    def __init__(self, connection, channels: int = 4):
        super().__init__(connection)
        
        # Build subsystems
        self.channel = Channel.build(self, ":CH", indices=4)
        self.reference = Reference.build(self, ":REF")
        self.diagnostics = Diagnostics.build(self, ":HSX:DIAG")
        self.ip = IP.build(self, ":IP")
        self.communications = Communication.build(self, ":COMM")

        # Set response mode based on read_after_write flag
        if self.read_after_write:
            self.communications.respond = True

class Channel(Subsystem):
    """
    Represents a single synthesizer channel (n) with properties and methods.
    Commands use the pattern :CHn:<command>
    """
    # Frequency settings with unit suffixes
    frequency = ValueProperty(":FREQ", type="float", range=(10e6, 6e9), units="Hz", doc_str="Channel output frequency", join_char=":")
    freq_min = ValueProperty(":FREQ:MIN", access='read', doc_str="Min freq for this channel", join_char=":")
    freq_max = ValueProperty(":FREQ:MAX", access='read', doc_str="Max freq for this channel", join_char=":")

    # Power settings
    power = ValueProperty(":PWR", type="float", range=(-20, 20), units="dBm",doc_str="Channel output power", join_char=":")
    output = SwitchProperty(":PWR:RF", doc_str="RF output state", join_char=":")
    power_mode = SelectProperty(":PWR:MODE", ["AUTO", "HIGH", "NORMAL", "FIX"],doc_str="Power/attenuator mode", join_char=":")

    # Phase settings
    phase = ValueProperty(":PHASE", type="float", range=(0, 360), units="deg",doc_str="Phase offset", join_char=":")
    phase_max = ValueProperty(":PHASE:MAX", access='read', doc_str="Max phase for current freq", join_char=":")
    phase_res = ValueProperty(":PHASE:RES", access='read',doc_str="Phase resolution", join_char=":")

    # Temperature monitoring
    temperature = ValueProperty(":TEMP", access='read', type="float", doc_str="Channel temperature in C", join_char=":")

class Reference(Subsystem):
    """
    Reference clock subsystem.
    Commands use pattern :REF:<command>
    """
    source = SelectProperty("", ["EXT:10MHz", "INT:100MHz"], doc_str="Reference clock source", join_char=":")

class IP(Subsystem):
    """
    IP address configuration subsystem.
    Commands use pattern :IP:<command>
    """
    mode = SelectProperty(":STATUS", ["STATIC", "DHCP"], doc_str="IP address mode", join_char=":")
    address = ValueProperty(":ADDR", doc_str="Static IP address", join_char=":")
    subnet = ValueProperty(":SUBNET", doc_str="Subnet mask", join_char=":")
    gateway = ValueProperty(":GATEWAY", doc_str="Gateway address", join_char=":")

class Communication(Subsystem):
    """
    Communication settings subsystem.
    Commands use pattern :COMM:<command>
    """
    respond = SwitchProperty(":RESPOND", doc_str="Enable responses for all commands", join_char=":")

class Diagnostics(Subsystem):
    """
    Diagnostics subsystem.
    Commands use pattern :HSX:DIAG:<command>
    """
    def start(self):
        """Start mini diagnostics routine."""
        self.write(f"{self.cmd_prefix}:MIN:START")

    def get_status(self) -> str:
        """Query diagnostics status."""
        return self.query(f"{self.cmd_prefix}:DONE")

    def get_errors(self) -> str:
        """Query diagnostic errors."""
        return self.query(f"{self.cmd_prefix}:ERROR")
        
    def get_board_info(self) -> str:
        """Query board information."""
        return self.query(f"{self.cmd_prefix}:INFO:BOARDS")


================================================================================
*** plugin.py ***
### src/pymetr/drivers/instruments/plugin.py ###
================================================================================

import os
import yaml
from typing import Dict

# Determine the path to the YAML file.
# This assumes the YAML file is in the same directory as this module.
REGISTRY_FILE = os.path.join(os.path.dirname(__file__), 'driver_registry.yaml')

def load_registry() -> Dict[str, Dict[str, str]]:
    """Load the driver registry from the YAML file."""
    try:
        with open(REGISTRY_FILE, 'r') as f:
            registry = yaml.safe_load(f)
        return registry
    except Exception as e:
        raise RuntimeError(f"Failed to load driver registry YAML file: {e}")

# Load the registry once at module load time.
_DRIVER_REGISTRY = load_registry()

def get_driver_info(model: str) -> Dict[str, str]:
    """
    Get driver module and class information for a given model.
    Raises ValueError if model not found.
    """
    if model not in _DRIVER_REGISTRY:
        raise ValueError(f"No driver registered for model: {model}")
    return _DRIVER_REGISTRY[model]



================================================================================
*** registry.py ***
### src/pymetr/drivers/instruments/registry.py ###
================================================================================

"""
Registry mapping instrument model numbers to their driver implementations.
"""

from typing import Dict

DRIVER_REGISTRY: Dict[str, Dict[str, str]] = {
    "HP8563A": {
        "module": "drivers.hp8563a",
        "class": "HP8563A"
    },
    "HP8564E": {
        "module": "drivers.hp8564e",
        "class": "HP8564E"
    },
    "HP8657B": {
        "module": "drivers.hp8657b",
        "class": "HP8657B"
    },
    "HP437B": {
        "module": "drivers.hp437b",
        "class": "HP437B"
    },
    "HS9001B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9002B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9003B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9004B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9005B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9006B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9007B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9008B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9009B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9010B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9011B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9012B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9013B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9014B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9015B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9016B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    }
    # Add more models as needed
}

def get_driver_info(model: str) -> Dict[str, str]:
    """
    Get driver module and class information for a given model.
    Raises ValueError if model not found.
    """
    if model not in DRIVER_REGISTRY:
        raise ValueError(f"No driver registered for model: {model}")
    return DRIVER_REGISTRY[model]


================================================================================
*** __init__.py ***
### src/pymetr/models/__init__.py ###
================================================================================

# C:/Users/rsmith/Documents/GitHub/pymetr/src/pymetr/models/__init__.py

from .base import BaseModel
from .cursor import Cursor
from .device import Device
from .marker import Marker
from .measurement import Measurement
from .plot import Plot
from .table import DataTable
from .test import TestSuite, TestScript, TestGroup, TestResult, TestStatus, ResultStatus
from .trace import Trace

__all__ = [
    "BaseModel",
    "Cursor",
    "Device",
    "Marker",
    "Measurement",
    "Plot",
    "DataTable",
    "TestSuite",
    "TestScript",
    "TestGroup",
    "TestResult",
    "TestStatus",
    "ResultStatus",
    "Trace",
]



================================================================================
*** analysis_dual_model.py ***
### src/pymetr/models/analysis_dual_model.py ###
================================================================================


from typing import Optional, Any, Tuple
import numpy as np
from pymetr.models.analysis.analysis_model import Analysis, SpectralAnalysis
from pymetr.core.logging import logger

class DualTraceAnalysis(Analysis):
    """Base class for analyses requiring two input traces."""
    def __init__(
        self, 
        name: str,
        trace_a_id: str,
        trace_b_id: str,
        **kwargs
    ):
        super().__init__(name, trace_a_id, **kwargs)
        self._trace_b_id = trace_b_id
        
        # Result trace for computed output
        self._result_trace = self.create_trace(
            x_data=np.array([]),
            y_data=np.array([]),
            name=f"{name} Result"
        )
        
    @property
    def trace_a(self):
        """First input trace."""
        return self.input_trace  # From base class
        
    @property
    def trace_b(self):
        """Second input trace."""
        return self.state.get_model(self._trace_b_id)
        
    def _get_aligned_data(self) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """Get x-aligned data from both traces."""
        if not self.trace_a or not self.trace_b:
            return np.array([]), np.array([]), np.array([])
            
        # Get data respecting ROI
        xa, ya = self.get_analysis_data()
        xb, yb = self.trace_b.data
        
        # Interpolate trace B to match trace A x points
        yb_interp = np.interp(xa, xb, yb)
        
        return xa, ya, yb_interp

class TraceMath(DualTraceAnalysis):
    """Basic math operations between traces."""
    OPERATIONS = {
        'add': (lambda a,b: a + b, '+'),
        'subtract': (lambda a,b: a - b, '-'),
        'multiply': (lambda a,b: a * b, ''),
        'divide': (lambda a,b: np.divide(a, b, where=b!=0), ''),
        'min': (np.minimum, 'min'),
        'max': (np.maximum, 'max'),
        'average': (lambda a,b: (a + b)/2, 'avg')
    }
    
    def __init__(
        self, 
        trace_a_id: str,
        trace_b_id: str,
        operation: str = 'add',
        **kwargs
    ):
        name = f"Trace {self.OPERATIONS[operation][1]}"
        super().__init__(name, trace_a_id, trace_b_id, **kwargs)
        self._operation = operation
        self._result_trace.color = "#00FFFF"  # Make result stand out
        
        # Add label marker to show operation
        self._label = self.create_marker(
            x=0, y=0,
            name="Operation",
            label=f"{trace_a_id} {self.OPERATIONS[operation][1]} {trace_b_id}"
        )
        
        self.update()
        
    def update(self):
        x, ya, yb = self._get_aligned_data()
        if len(x) == 0:
            return
            
        # Apply operation
        op_func = self.OPERATIONS[self._operation][0]
        result = op_func(ya, yb)
        
        # Update result trace
        self._result_trace.data = (x, result)
        
        # Update label position
        self._label.x = x[len(x)//2]
        self._label.y = result[len(result)//2]

class CrossCorrelation(DualTraceAnalysis):
    """Cross-correlation analysis between traces."""
    def __init__(self, trace_a_id: str, trace_b_id: str, **kwargs):
        super().__init__("Cross Correlation", trace_a_id, trace_b_id, **kwargs)
        self._result_trace.color = "#FF00FF"
        
        # Add lag cursor
        self._lag_cursor = self.create_cursor(
            position=0,
            axis='x',
            name="Peak Lag"
        )
        
        # Add correlation value marker
        self._corr_marker = self.create_marker(
            x=0, y=0,
            name="Correlation"
        )
        
        self.update()
        
    def update(self):
        x, ya, yb = self._get_aligned_data()
        if len(x) == 0:
            return
            
        # Compute cross correlation
        correlation = np.correlate(ya - ya.mean(), 
                                 yb - yb.mean(), 
                                 mode='full')
        
        # Normalize
        correlation = correlation / (len(ya) * ya.std() * yb.std())
        
        # Create lag axis
        dt = x[1] - x[0]
        lags = np.arange(-(len(x)-1), len(x)) * dt
        
        # Find peak correlation
        peak_idx = np.argmax(np.abs(correlation))
        peak_lag = lags[peak_idx]
        peak_corr = correlation[peak_idx]
        
        # Update result trace
        self._result_trace.data = (lags, correlation)
        
        # Update markers
        self._lag_cursor.position = peak_lag
        self._corr_marker.x = peak_lag
        self._corr_marker.y = peak_corr
        self._corr_marker.label = f"Correlation: {peak_corr:.2f}\nLag: {peak_lag:.2e}s"

class CrossSpectrum(DualTraceAnalysis, SpectralAnalysis):
    """Cross-spectral analysis between two traces."""
    def __init__(self, trace_a_id: str, trace_b_id: str, **kwargs):
        DualTraceAnalysis.__init__(self, "Cross Spectrum", 
                                 trace_a_id, trace_b_id, **kwargs)
        SpectralAnalysis.__init__(self, trace_a_id, **kwargs)
        
        # Override trace names
        self._mag_trace.name = "Cross Magnitude"
        self._phase_trace = self.create_trace(
            x_data=np.array([]),
            y_data=np.array([]),
            name="Cross Phase",
            color="#FF8800"
        )
        
        # Coherence trace
        self._coherence = self.create_trace(
            x_data=np.array([]),
            y_data=np.array([]),
            name="Coherence",
            color="#00FF00"
        )
        
        self.update()
        
    def update(self):
        x, ya, yb = self._get_aligned_data()
        if len(x) == 0:
            return
            
        # Remove DC if requested
        if self._remove_dc:
            ya = ya - np.mean(ya)
            yb = yb - np.mean(yb)
            
        # Apply windows
        ya_win = self._apply_window(ya)
        yb_win = self._apply_window(yb)
        
        # Compute FFTs
        fft_a = np.fft.rfft(ya_win)
        fft_b = np.fft.rfft(yb_win)
        freqs = self._compute_freq_axis(x)
        
        # Compute cross spectrum
        cross_spec = fft_a * np.conj(fft_b)
        
        # Compute coherence
        auto_a = np.abs(fft_a)**2
        auto_b = np.abs(fft_b)**2
        coherence = np.abs(cross_spec)**2 / (auto_a * auto_b)
        
        # Update traces
        self._mag_trace.data = (freqs, self._to_db(cross_spec))
        self._phase_trace.data = (freqs, np.angle(cross_spec, deg=True))
        self._coherence.data = (freqs, coherence)
        
        # Update peak at most coherent frequency
        peak_idx = np.argmax(coherence)
        self._peak.x = freqs[peak_idx]
        self._peak.y = coherence[peak_idx]
        self._peak.label = (f"Max Coherence:\n{freqs[peak_idx]:.2f}Hz\n"
                          f"{coherence[peak_idx]:.3f}")


================================================================================
*** analysis_model.py ***
### src/pymetr/models/analysis_model.py ###
================================================================================

from typing import Optional, Any, Tuple, TYPE_CHECKING
import numpy as np
from pymetr.models.base_model import BaseModel
from pymetr.core.logging import logger

if TYPE_CHECKING:
    from pymetr.models.trace.trace_model import Trace  # Import only for type checking
    from pymetr.models.plot.plot_model import Plot
    from pymetr.models.marker.marker_model import Marker
    from pymetr.models.cursor.cursor_model import Cursor

class Analysis(BaseModel):
    """
    Base analysis model that generates and manages plot objects.
    Results are shown in parent plot through child objects.
    """
    def __init__(
        self, 
        name: str,
        input_trace_id: str,  # Required input trace
        model_id: Optional[str] = None
    ):
        super().__init__(model_type='Analysis', model_id=model_id, name=name)
        self._input_trace_id = input_trace_id
        
        logger.debug(f"Analysis {self.id} created for trace {input_trace_id}")

    @property
    def input_trace(self) -> Optional["Trace"]:  # Use string annotation to avoid runtime import
        """Get input trace model."""
        return self.state.get_model(self._input_trace_id)

    @property
    def parent_plot(self) -> Optional["Plot"]:  # Use string annotation
        """Get parent plot model."""
        return self.state.get_parent(self.id)

    def create_marker(self, **kwargs) -> "Marker":
        """Create a marker as a child of this analysis."""
        marker = self.state.create_model(Marker, **kwargs)
        self.add_child(marker)
        logger.debug(f"Analysis {self.id} created marker {marker.id}")
        return marker

    def create_cursor(self, **kwargs) -> "Cursor":
        """Create a cursor as a child of this analysis."""
        cursor = self.state.create_model(Cursor, **kwargs)
        self.add_child(cursor)
        logger.debug(f"Analysis {self.id} created cursor {cursor.id}")
        return cursor

    def create_trace(self, **kwargs) -> "Trace":
        """Create a trace as a child of this analysis."""
        from pymetr.models.trace.trace_model import Trace  # Deferred import
        trace = self.state.create_model(Trace, **kwargs)
        self.add_child(trace)
        logger.debug(f"Analysis {self.id} created trace {trace.id}")
        return trace

    def update(self):
        """Update analysis results."""
        raise NotImplementedError

    def _handle_model_change(self, model_id: str, model_type: str, prop: str, value: Any):
        """Handle model changes affecting analysis."""
        try:
            # Update if input trace data changes
            if model_id == self._input_trace_id and prop == "data":
                self.update()
                
            # Update if plot ROI changes
            if self.parent_plot and model_id == self.parent_plot.id:
                if prop in ("roi", "roi_visible"):
                    self.update()
                    
        except Exception as e:
            logger.error(f"Error handling model change in {self.id}: {e}")

    def get_analysis_data(self) -> Tuple[np.ndarray, np.ndarray]:
        """Get data to analyze, respecting ROI if active."""
        trace = self.input_trace
        if not trace:
            return np.array([]), np.array([])
            
        x_data, y_data = trace.data
        
        # Check if we should use ROI
        if self.parent_plot and self.parent_plot.roi_visible:
            roi = self.parent_plot.roi
            if roi and len(roi) == 2:
                mask = (x_data >= roi[0]) & (x_data <= roi[1])
                return x_data[mask], y_data[mask]
                
        return x_data, y_data
    
class EdgeMeasurement(Analysis):
    """Base class for edge timing measurements."""
    def __init__(self, name: str, input_trace_id: str, edge_type: str = "rise", **kwargs):
        super().__init__(name, input_trace_id, **kwargs)
        self.edge_type = edge_type  # "rise" or "fall"
        
        # Create level cursors
        self._low = self.create_cursor(
            position=0, axis='y', name="10%",
            color="#00FF00"
        )
        self._high = self.create_cursor(
            position=0, axis='y', name="90%",
            color="#00FF00"
        )
        
        # Create edge cursors
        self._start = self.create_cursor(
            position=0, axis='x', name="Start",
            color="#FFFF00"
        )
        self._end = self.create_cursor(
            position=0, axis='x', name="End",
            color="#FFFF00"
        )
        
        # Result marker
        self._result = self.create_marker(
            x=0, y=0, name=f"{edge_type.title()} Time"
        )
        
        self.update()
        
    def update(self):
        """Update edge measurement."""
        x_data, y_data = self.get_analysis_data()
        if len(y_data) < 2:
            return
            
        # Find reference levels
        y_min, y_max = y_data.min(), y_data.max()
        y_range = y_max - y_min
        
        low_level = y_min + y_range * 0.1  # 10%
        high_level = y_min + y_range * 0.9  # 90%
        
        # Update level cursors
        self._low.position = low_level
        self._high.position = high_level
        
        # Find edge crossing points
        if self.edge_type == "rise":
            low_idx = np.where(y_data >= low_level)[0][0]
            high_idx = np.where(y_data >= high_level)[0][0]
        else:  # fall
            low_idx = np.where(y_data <= low_level)[0][0]
            high_idx = np.where(y_data <= high_level)[0][0]
            
        # Update edge cursors
        self._start.position = x_data[low_idx]
        self._end.position = x_data[high_idx]
        
        # Calculate edge time
        edge_time = abs(x_data[high_idx] - x_data[low_idx])
        
        # Update result
        self._result.x = (x_data[high_idx] + x_data[low_idx]) / 2
        self._result.y = (high_level + low_level) / 2
        self._result.label = f"{self.edge_type.title()} Time: {edge_time:.2e}s"

class RiseTime(EdgeMeasurement):
    """Rise time measurement (10% to 90%)."""
    def __init__(self, input_trace_id: str, **kwargs):
        super().__init__("Rise Time", input_trace_id, edge_type="rise", **kwargs)

class FallTime(EdgeMeasurement):
    """Fall time measurement (90% to 10%)."""
    def __init__(self, input_trace_id: str, **kwargs):
        super().__init__("Fall Time", input_trace_id, edge_type="fall", **kwargs)

class PulseWidth(Analysis):
    """Measure pulse width at 50% threshold."""
    def __init__(self, input_trace_id: str, **kwargs):
        super().__init__("Pulse Width", input_trace_id, **kwargs)
        
        self._threshold = self.create_cursor(
            position=0, axis='y', name="50%",
            color="#00FFFF",
            style="dash"
        )
        
        self._start = self.create_cursor(
            position=0, axis='x', name="Start",
            color="#FFFF00"
        )
        self._end = self.create_cursor(
            position=0, axis='x', name="End",
            color="#FFFF00"
        )
        
        self._result = self.create_marker(
            x=0, y=0, name="Width"
        )
        
        self.update()

    def update(self):
        x_data, y_data = self.get_analysis_data()
        if len(y_data) < 2:
            return
            
        # Find 50% threshold
        threshold = y_data.mean()
        self._threshold.position = threshold
        
        # Find crossings
        crossings = np.where(np.diff(y_data > threshold))[0]
        if len(crossings) >= 2:
            self._start.position = x_data[crossings[0]]
            self._end.position = x_data[crossings[1]]
            
            width = abs(x_data[crossings[1]] - x_data[crossings[0]])
            
            self._result.x = (x_data[crossings[0]] + x_data[crossings[1]]) / 2
            self._result.y = threshold * 1.2  # Place above line
            self._result.label = f"Width: {width:.2e}s"

class PhaseDifference(Analysis):
    """Measure phase difference between two traces."""
    def __init__(self, input_trace_id: str, reference_trace_id: str, **kwargs):
        super().__init__("Phase", input_trace_id, **kwargs)
        self._ref_trace_id = reference_trace_id
        
        # Reference trace zero crossing
        self._ref_cursor = self.create_cursor(
            position=0, axis='x', name="Ref",
            color="#FF00FF"
        )
        
        # Input trace crossing
        self._input_cursor = self.create_cursor(
            position=0, axis='x', name="Input",
            color="#00FFFF"
        )
        
        self._result = self.create_marker(
            x=0, y=0, name="Phase"
        )
        
        self.update()
        
    def update(self):
        ref_trace = self.state.get_model(self._ref_trace_id)
        input_trace = self.input_trace
        if not ref_trace or not input_trace:
            return
            
        # Get first zero crossing of each
        ref_x, ref_y = ref_trace.data
        in_x, in_y = input_trace.data
        
        # Find zero crossings
        ref_cross = ref_x[np.where(np.diff(np.signbit(ref_y)))[0][0]]
        in_cross = in_x[np.where(np.diff(np.signbit(in_y)))[0][0]]
        
        self._ref_cursor.position = ref_cross
        self._input_cursor.position = in_cross
        
        # Calculate phase difference
        time_diff = abs(in_cross - ref_cross)
        period = self._find_period(ref_x, ref_y)
        if period:
            phase_deg = (time_diff / period) * 360.0
            
            self._result.x = (ref_cross + in_cross) / 2
            self._result.y = max(ref_y.max(), in_y.max())
            self._result.label = f"Phase: {phase_deg:.1f}"
            
    def _find_period(self, x: np.ndarray, y: np.ndarray) -> Optional[float]:
        """Find signal period from zero crossings."""
        crossings = np.where(np.diff(np.signbit(y)))[0]
        if len(crossings) >= 2:
            return abs(x[crossings[1]] - x[crossings[0]]) * 2
        return None

class SlewRate(EdgeMeasurement):
    """Measure slew rate (V/s) on edges."""
    def __init__(self, input_trace_id: str, edge_type: str = "rise", **kwargs):
        super().__init__("Slew Rate", input_trace_id, edge_type=edge_type, **kwargs)
        
    def update(self):
        super().update()  # Get basic edge timing
        
        # Calculate dV/dt
        if self._start.position and self._end.position:
            dv = abs(self._high.position - self._low.position)
            dt = abs(self._end.position - self._start.position)
            slew = dv/dt if dt else 0
            
            self._result.label = f"Slew: {slew:.2e}V/s"

class DutyCycle(Analysis):
    """Measure duty cycle of periodic signal."""
    def __init__(self, input_trace_id: str, **kwargs):
        super().__init__("Duty Cycle", input_trace_id, **kwargs)
        
        self._threshold = self.create_cursor(
            position=0, axis='y', name="50%",
            color="#00FFFF",
            style="dash"
        )
        
        self._high_time = self.create_cursor(
            position=0, axis='x', name="High",
            color="#FFFF00"
        )
        
        self._period = self.create_cursor(
            position=0, axis='x', name="Period",
            color="#FF00FF"
        )
        
        self._result = self.create_marker(
            x=0, y=0, name="Duty"
        )
        
        self.update()
        
    def update(self):
        x_data, y_data = self.get_analysis_data()
        if len(y_data) < 2:
            return
            
        # Find 50% threshold
        threshold = (y_data.max() + y_data.min()) / 2
        self._threshold.position = threshold
        
        # Find high/low transitions
        crossings = np.where(np.diff(y_data > threshold))[0]
        if len(crossings) >= 2:
            # Time above threshold
            high_time = x_data[crossings[1]] - x_data[crossings[0]]
            
            # Total period
            if len(crossings) >= 3:
                period = x_data[crossings[2]] - x_data[crossings[0]]
                duty = (high_time / period) * 100 if period else 0
                
                self._high_time.position = x_data[crossings[0]] + high_time
                self._period.position = x_data[crossings[0]] + period
                
                self._result.x = x_data[crossings[0]] + period/2
                self._result.y = threshold * 1.2
                self._result.label = f"Duty: {duty:.1f}%"

class Overshoot(Analysis):
    """Measure overshoot/undershoot on edges."""
    def __init__(self, input_trace_id: str, **kwargs):
        super().__init__("Overshoot", input_trace_id, **kwargs)
        
        # Steady state levels
        self._high = self.create_cursor(
            position=0, axis='y', name="High",
            color="#00FF00"
        )
        self._low = self.create_cursor(
            position=0, axis='y', name="Low",
            color="#00FF00"
        )
        
        # Overshoot/undershoot markers
        self._over = self.create_marker(
            x=0, y=0, name="Over",
            color="#FF0000"
        )
        self._under = self.create_marker(
            x=0, y=0, name="Under",
            color="#FF0000"
        )
        
        self.update()
        
    def update(self):
        x_data, y_data = self.get_analysis_data()
        if len(y_data) < 2:
            return
            
        # Find steady state levels (using histogram)
        hist, bins = np.histogram(y_data, bins=50)
        peaks = np.where(hist > np.mean(hist))[0]
        if len(peaks) >= 2:
            low_level = bins[peaks[0]]
            high_level = bins[peaks[-1]]
            
            self._high.position = high_level
            self._low.position = low_level
            
            # Find overshoots
            over_idx = np.argmax(y_data)
            under_idx = np.argmin(y_data)
            
            over_amount = ((y_data[over_idx] - high_level) / 
                         (high_level - low_level) * 100)
            under_amount = ((low_level - y_data[under_idx]) / 
                          (high_level - low_level) * 100)
            
            # Update markers
            self._over.x = x_data[over_idx]
            self._over.y = y_data[over_idx]
            self._over.label = f"Over: {over_amount:.1f}%"
            
            self._under.x = x_data[under_idx]
            self._under.y = y_data[under_idx]
            self._under.label = f"Under: {under_amount:.1f}%"

class Jitter(Analysis):
    """Edge jitter measurement."""
    def __init__(self, input_trace_id: str, **kwargs):
        super().__init__("Jitter", input_trace_id, **kwargs)
        
        # Threshold cursor
        self._threshold = self.create_cursor(
            position=0, axis='y', name="50%",
            color="#00FFFF"
        )
        
        # Create markers for min/max timing
        self._early = self.create_cursor(
            position=0, axis='x', name="Early",
            color="#FF0000"
        )
        self._late = self.create_cursor(
            position=0, axis='x', name="Late",
            color="#FF0000"
        )
        
        self._result = self.create_marker(
            x=0, y=0, name="Jitter"
        )
        
        self.update()
        
    def update(self):
        x_data, y_data = self.get_analysis_data()
        if len(y_data) < 2:
            return
            
        # Find threshold
        threshold = (y_data.max() + y_data.min()) / 2
        self._threshold.position = threshold
        
        # Find all edge crossings
        crossings = []
        for i in range(1, len(y_data)):
            if (y_data[i-1] < threshold and y_data[i] >= threshold):
                # Interpolate precise crossing
                t = (threshold - y_data[i-1]) / (y_data[i] - y_data[i-1])
                cross_time = x_data[i-1] + t * (x_data[i] - x_data[i-1])
                crossings.append(cross_time)
                
        if len(crossings) >= 2:
            # Find average period
            periods = np.diff(crossings)
            avg_period = np.mean(periods)
            
            # Calculate timing variations
            deviations = periods - avg_period
            pk_pk_jitter = np.ptp(deviations)
            rms_jitter = np.std(deviations)
            
            # Update cursors to show extremes
            min_idx = np.argmin(periods)
            max_idx = np.argmax(periods)
            
            self._early.position = crossings[min_idx]
            self._late.position = crossings[max_idx]
            
            # Update result
            mid_x = (crossings[min_idx] + crossings[max_idx]) / 2
            self._result.x = mid_x
            self._result.y = threshold * 1.2
            self._result.label = (f"Jitter:\nPk-Pk: {pk_pk_jitter:.2e}s\n"
                                f"RMS: {rms_jitter:.2e}s")

class EyeDiagram(Analysis):
    """Eye diagram analysis using trace overlay."""
    def __init__(self, input_trace_id: str, **kwargs):
        super().__init__("Eye", input_trace_id, **kwargs)
        
        # Create overlaid trace for eye
        self._eye_trace = self.create_trace(
            x_data=np.array([]),
            y_data=np.array([]),
            name="Eye",
            color="#00FFFF",
            opacity=0.5
        )
        
        # Measurements
        self._height = self.create_marker(
            x=0, y=0, name="Height"
        )
        self._width = self.create_marker(
            x=0, y=0, name="Width"
        )
        
        self.update()
        
    def update(self):
        x_data, y_data = self.get_analysis_data()
        if len(y_data) < 2:
            return
            
        # Find bit period (assuming NRZ)
        threshold = (y_data.max() + y_data.min()) / 2
        crossings = np.where(np.diff(y_data > threshold))[0]
        if len(crossings) < 2:
            return
            
        # Estimate bit period
        periods = np.diff(crossings)
        bit_period = np.median(periods) * (x_data[1] - x_data[0])
        
        # Create eye by overlaying bit periods
        eye_x = []
        eye_y = []
        
        for i in range(len(crossings)-1):
            start_idx = crossings[i]
            end_idx = min(start_idx + int(bit_period*2), len(x_data))
            
            # Normalize to bit period
            segment_x = x_data[start_idx:end_idx]
            segment_x = (segment_x - x_data[start_idx]) / bit_period
            
            eye_x.extend(segment_x)
            eye_y.extend(y_data[start_idx:end_idx])
        
        # Update eye trace
        self._eye_trace.data = (np.array(eye_x), np.array(eye_y))
        
        # Measure eye parameters
        if len(eye_y) > 0:
            eye_height = np.percentile(eye_y, 95) - np.percentile(eye_y, 5)
            eye_width = bit_period * 0.8  # Approximate from histogram
            
            self._height.x = 0.5  # Center of eye
            self._height.y = threshold
            self._height.label = f"Eye Height: {eye_height:.2e}"
            
            self._width.x = 0.5
            self._width.y = threshold * 0.8
            self._width.label = f"Eye Width: {eye_width:.2e}s"

class SpectralAnalysis(Analysis):
    """Base class for FFT-based analysis."""
    
    WINDOWS = {
        'rectangular': (np.ones, 'Uniform'),
        'hanning': (np.hanning, 'Hanning'),
        'hamming': (np.hamming, 'Hamming'),
        'flattop': (lambda N: np.blackman(N), 'Flat Top'),
        'blackman': (np.blackman, 'Blackman')
    }
    
    def __init__(self, input_trace_id: str, **kwargs):
        super().__init__("FFT", input_trace_id, **kwargs)
        
        # Analysis settings
        self._window_type = kwargs.get('window', 'hanning')
        self._remove_dc = kwargs.get('remove_dc', True)
        self._db_ref = kwargs.get('db_ref', 1.0)  # For dB conversion
        
        # Create magnitude trace
        self._mag_trace = self.create_trace(
            x_data=np.array([]),
            y_data=np.array([]),
            name="Magnitude",
            color="#00FFFF"
        )
        
        # Peak marker
        self._peak = self.create_marker(
            x=0, y=0,
            name="Peak",
            color="#FF00FF"
        )
        
        self.update()
        
    def _apply_window(self, data: np.ndarray) -> np.ndarray:
        """Apply selected window function."""
        window_func = self.WINDOWS[self._window_type][0]
        return data * window_func(len(data))
        
    def _compute_freq_axis(self, x_data: np.ndarray) -> np.ndarray:
        """Compute frequency axis."""
        dt = np.mean(np.diff(x_data))
        fs = 1/dt
        freqs = np.fft.rfftfreq(len(x_data), dt)
        return freqs
        
    def _to_db(self, magnitude: np.ndarray) -> np.ndarray:
        """Convert to dB."""
        return 20 * np.log10(np.abs(magnitude) / self._db_ref)

class FFT(SpectralAnalysis):
    """Single trace FFT analysis."""
    def __init__(self, input_trace_id: str, **kwargs):
        super().__init__(input_trace_id, **kwargs)
        self._mag_trace.name = "FFT Magnitude"
        
        # Add phase trace
        self._phase_trace = self.create_trace(
            x_data=np.array([]),
            y_data=np.array([]),
            name="Phase",
            color="#FF8800"
        )
        
        self.update()
        
    def update(self):
        x_data, y_data = self.get_analysis_data()
        if len(y_data) < 2:
            return
            
        # Remove DC if requested
        if self._remove_dc:
            y_data = y_data - np.mean(y_data)
            
        # Apply window
        windowed = self._apply_window(y_data)
        
        # Compute FFT
        spectrum = np.fft.rfft(windowed)
        freqs = self._compute_freq_axis(x_data)
        
        # Convert to dB
        magnitude = self._to_db(spectrum)
        phase = np.angle(spectrum, deg=True)
        
        # Update traces
        self._mag_trace.data = (freqs, magnitude)
        self._phase_trace.data = (freqs, phase)
        
        # Find peak
        peak_idx = np.argmax(magnitude)
        self._peak.x = freqs[peak_idx]
        self._peak.y = magnitude[peak_idx]
        self._peak.label = (f"Peak:\n{freqs[peak_idx]:.2f}Hz\n"
                          f"{magnitude[peak_idx]:.1f}dB")
        
class PeriodMeasurement(Analysis):
    """Period/frequency measurement between two cursors."""
    def __init__(self, input_trace_id: str, **kwargs):
        super().__init__("Period Measurement", input_trace_id, **kwargs)
        
        # Create cursors
        self._x1 = self.create_cursor(
            position=0, axis='x', name="X1",
            color="#FFFF00"
        )
        self._x2 = self.create_cursor(
            position=0, axis='x', name="X2",
            color="#FFFF00"
        )
        
        # Create result marker
        self._result = self.create_marker(
            x=0, y=0, name="Period",
            color="#FFFF00"
        )
        
        self._auto_place_cursors()
        
    def _auto_place_cursors(self):
        """Place cursors at zero crossings."""
        trace = self.input_trace
        if not trace:
            return
            
        x_data, y_data = trace.data
        if len(y_data) < 2:
            return
            
        # Find zero crossings
        zero_crossings = np.where(np.diff(np.signbit(y_data)))[0]
        if len(zero_crossings) >= 2:
            self._x1.position = x_data[zero_crossings[0]]
            self._x2.position = x_data[zero_crossings[1]]
            
        self.update()
        
    def update(self):
        """Update measurement."""
        period = abs(self._x2.position - self._x1.position)
        freq = 1.0 / period if period != 0 else 0
        
        # Update marker position and label
        mid_x = (self._x1.position + self._x2.position) / 2
        y_pos = self.input_trace.y_data.max() * 0.9  # Place near top
        
        self._result.x = mid_x
        self._result.y = y_pos
        self._result.label = f"Period: {period:.2e}s\nFreq: {freq:.2f}Hz"

class PeakToPeak(Analysis):
    """Peak-to-peak measurement with horizontal cursors."""
    def __init__(self, input_trace_id: str, **kwargs):
        super().__init__("Peak-to-Peak", input_trace_id, **kwargs)
        
        # Create cursors at min/max
        self._y_max = self.create_cursor(
            position=0, axis='y', name="Max",
            color="#FF00FF"
        )
        self._y_min = self.create_cursor(
            position=0, axis='y', name="Min",
            color="#FF00FF"
        )
        
        self._result = self.create_marker(
            x=0, y=0, name="P-P",
            color="#FF00FF"
        )
        
        self.update()
        
    def update(self):
        """Update min/max cursors and measurement."""
        trace = self.input_trace
        if not trace:
            return
            
        x_data, y_data = trace.data
        if len(y_data) < 2:
            return
            
        y_min, y_max = y_data.min(), y_data.max()
        self._y_min.position = y_min
        self._y_max.position = y_max
        
        # Place result marker
        x_pos = x_data[len(x_data)//2]  # Middle of x range
        y_pos = (y_max + y_min) / 2  # Middle of y range
        
        self._result.x = x_pos
        self._result.y = y_pos
        self._result.label = f"P-P: {y_max - y_min:.2f}"


================================================================================
*** base.py ***
### src/pymetr/models/base.py ###
================================================================================

# pymetr/models/base.py
from PySide6.QtCore import QObject, Signal
from typing import Optional, Any
import uuid
import pandas as pd
from pymetr.core.logging import logger

class BaseModel(QObject):
    # Updated signal to include model_type
    property_changed = Signal(str, str, str, object)  # model_id, model_type, property, value
    child_added = Signal(str, str)              # parent_id, child_id

    def __init__(self, model_type: str, state=None, model_id: Optional[str] = None, name: Optional[str] = None):
        super().__init__()
        self.model_type = model_type
        self._id = model_id or str(uuid.uuid4())
        # Set the human-readable name; default to "Untitled" if not provided.
        self._name = name if name is not None else "Untitled"
        
        # Create a valid Qt objectName from the model name/id
        # Replace spaces and special chars with underscores
        safe_name = self._name.replace(' ', '_').replace(';', '').replace(':', '')
        object_name = f"{safe_name}_{self._id}"
        self.setObjectName(object_name)  # Set QObject name
        
        self._properties = {}
        self._children = {}
        self._connections = []
        self._batch_mode = False
        self._pending_updates = {}
        self.state = state
        if self.state is not None:
            self.state.register_model(self)
        logger.debug(f"{self.model_type} created with ID: {self._id}, name: {self._name}, objectName: {object_name}")
        # Store both name and objectName as properties
        self.set_property('name', self._name)
        self.set_property('objectName', object_name)

    @property
    def id(self) -> str:
        return self._id

    @property
    def name(self) -> str:
        """Return the human-readable name of the model."""
        return self._name

    def set_property(self, name: str, value: object) -> None:
        """
        Assign value to self._properties[name] unconditionally
        and emit self.property_changed(...) with (model_id, model_type, name, value).
        Skips all array/DataFrame comparison logic, so it may emit even if unchanged.
        """

        # If it's a DataFrame, store a copy so we don't accidentally mutate the original
        if isinstance(value, pd.DataFrame):
            self._properties[name] = value.copy()
        else:
            self._properties[name] = value

        # Always emit the signal (no old/new comparison)
        self.property_changed.emit(self.id, self.model_type, name, value)

    def get_property(self, prop: str, default: Any = None) -> Any:
        """Get a property value with optional default."""
        return self._properties.get(prop, default)

    def begin_update(self) -> None:
        """Begin batch update mode."""
        self._batch_mode = True
        self._pending_updates.clear()

    def end_update(self) -> None:
        """End batch update mode and emit changes."""
        self._batch_mode = False
        self._process_pending_updates()

    def _process_pending_updates(self) -> None:
        """Process all pending updates."""
        if not self._pending_updates:
            return

        # Emit all pending changes
        for prop, value in self._pending_updates.items():
            self.property_changed.emit(self.id, self.model_type, prop, value)
        
        self._pending_updates.clear()

    def add_child(self, child_model: 'BaseModel') -> None:
        """Add a child model with proper cleanup handling."""
        if child_model.id in self._children:
            logger.warning(f"Child {child_model.id} already exists in {self.id}")
            return

        self._children[child_model.id] = child_model
        self.child_added.emit(self.id, child_model.id)
        logger.debug(f"Added child {child_model.id} to {self.id}")

    def get_children(self) -> list['BaseModel']:
        """Get list of child models."""
        return list(self._children.values())

    def clear_children(self) -> None:
        """Remove all children with proper cleanup."""
        for child_id in list(self._children.keys()):
            if self.state:
                self.state.remove_model(child_id)
        self._children.clear()
        logger.debug(f"Cleared all children from {self.id}")

    def cleanup(self) -> None:
        """Clean up resources and connections."""
        # Clear all properties and pending updates
        self._properties.clear()
        self._pending_updates.clear()
        
        # Clean up children
        self.clear_children()
        
        # Clear state reference
        self.state = None
        
        logger.debug(f"Cleaned up model {self.id}")

    def deleteLater(self) -> None:
        """Override deleteLater for proper cleanup."""
        self.cleanup()
        super().deleteLater()

    def show(self) -> None:
        """Request model view activation."""
        if self.state:
            self.state.set_active_model(self.id)
            logger.debug(f"Model {self.id} requested to be shown")
        else:
            logger.warning(f"Cannot show model {self.id} - no state manager attached")




================================================================================
*** cursor.py ***
### src/pymetr/models/cursor.py ###
================================================================================

from pymetr.models.base import BaseModel
from typing import Optional
from PySide6.QtCore import QThread, Qt, QMetaObject, Q_ARG
from pymetr.core.logging import logger

class Cursor(BaseModel):
    """
    An infinite line on the plot, either vertical (axis='x') or horizontal (axis='y').
    
    Properties:
        axis (str): 'x' for vertical cursor, 'y' for horizontal cursor
        position (float): Position along the axis
        color (str): Cursor color (e.g., 'yellow', '#FFFF00')
        style (str): Line style ('solid', 'dash', 'dot', 'dash-dot')
        width (int): Line width in pixels
        visible (bool): Whether the cursor is visible
    """

    def __init__(
        self, 
        name: str = "Cursor",
        axis: str = "x", 
        position: float = 0.0,
        color: str = "yellow",
        style: str = "solid",
        width: int = 1,
        visible: bool = True,
        model_id: Optional[str] = None,
    ):
        super().__init__(model_type='Cursor', model_id=model_id, name=name)
        
        # Validate axis
        if axis not in ("x", "y"):
            raise ValueError("Cursor axis must be 'x' or 'y'.")

        # Initialize all properties
        self._init_properties(name, axis, position, color, style, width, visible)

    def _init_properties(self, name, axis, position, color, style, width, visible):
        """Initialize all cursor properties."""
        self.set_property("name", name)
        self.set_property("axis", axis)
        self.set_property("position", position)
        self.set_property("color", color)
        self.set_property("style", style)
        self.set_property("width", width)
        self.set_property("visible", visible)

    # --- Property Accessors ---

    @property
    def name(self) -> str:
        return self.get_property("name")

    @name.setter
    def name(self, value: str):
        self.set_property("name", value)

    @property
    def axis(self) -> str:
        """Get the cursor axis ('x' or 'y')."""
        return self.get_property("axis")

    @axis.setter
    def axis(self, value: str):
        if value not in ("x", "y"):
            raise ValueError("Cursor axis must be 'x' or 'y'.")
        self.set_property("axis", value)

    @property
    def position(self) -> float:
        """Get the cursor position."""
        return self.get_property("position")

    @position.setter
    def position(self, value: float):
        """Set the cursor position with thread safety."""
        if QThread.currentThread() != self.thread():
            QMetaObject.invokeMethod(
                self,
                "_set_position_internal",
                Qt.QueuedConnection,
                Q_ARG(float, value)
            )
        else:
            self._set_position_internal(value)

    @property
    def color(self) -> str:
        """Get the cursor color."""
        return self.get_property("color")

    @color.setter
    def color(self, value: str):
        self.set_property("color", value)

    @property
    def style(self) -> str:
        """Get the cursor line style."""
        return self.get_property("style")

    @style.setter
    def style(self, value: str):
        self.set_property("style", value)

    @property
    def width(self) -> int:
        """Get the cursor line width."""
        return self.get_property("width")

    @width.setter
    def width(self, value: int):
        self.set_property("width", value)

    @property
    def visible(self) -> bool:
        """Get cursor visibility."""
        return self.get_property("visible")

    @visible.setter
    def visible(self, value: bool):
        self.set_property("visible", value)

    # --- Internal Methods ---

    def _set_position_internal(self, pos: float):
        """Internal method to update position."""
        self.set_property("position", pos)
        logger.debug(f"Cursor {self.id} moved to {pos} on {self.axis} axis.")

    # --- Public Methods ---

    def set_position(self, pos: float):
        """Public method for setting position (maintains backward compatibility)."""
        self.position = pos


================================================================================
*** device.py ***
### src/pymetr/models/device.py ###
================================================================================

from typing import Dict, Any, Optional, List
from enum import Enum
from collections import deque
import importlib
import inspect
import time
import numpy as np
from PySide6.QtCore import Signal, QTimer

from pymetr.models.base import BaseModel
from pymetr.models.plot import Plot
from pymetr.models.trace import Trace
from pymetr.drivers.instruments.plugin import get_driver_info
from pymetr.core.logging import logger

class AcquisitionMode(Enum):
    SINGLE = "SINGLE"      # One-shot acquisition
    STACK = "STACK"        # Keep traces, add new ones
    CONTINUOUS = "CONTINUOUS"  # Clear and update continuously
    AVERAGE = "AVERAGE"    # Average N acquisitions then stop
    MAX_HOLD = "MAX_HOLD"  # Show live data and max envelope
    ROLLING_AVG = "ROLLING_AVG"  # Show live data and rolling average

class Device(BaseModel):
    """Device model representing a discovered instrument."""
    
    # Signals for UI updates
    connection_changed = Signal(bool)
    error_occurred = Signal(str)
    
    def __init__(self, 
                 manufacturer: Optional[str] = None,
                 model: Optional[str] = None,
                 serial_number: Optional[str] = None,
                 firmware: Optional[str] = None,
                 resource: Optional[str] = None,
                 model_id: Optional[str] = None):
        """Initialize device model with discovery information."""
        super().__init__(model_type="Device", model_id=model_id)
        
        # Internal state
        self.instrument = None  # Will hold driver instance
        self._instrument_connections = []
        self._driver_info: Dict[str, Any] = {}
        self._parameter_tree: Any = {}
        self._error_message: Optional[str] = None
        
        # Set basic device properties
        name = f"{model}-{serial_number}" if model and serial_number else "Unnamed Device"
        self.set_property('name', name)
        self.set_property('model', model or '')
        self.set_property('manufacturer', manufacturer or '')
        self.set_property('serial', serial_number or '')
        self.set_property('firmware', firmware or '')
        self.set_property('resource', resource or '')
        self.set_property('connection_string', resource or '')
        self.set_property('is_connected', False)
        
        # Acquisition settings
        self.set_property('acquisition_mode', AcquisitionMode.SINGLE.value)
        self.set_property('averaging_count', 10)
        self.set_property('is_acquiring', False)
        
        # Acquisition state
        self._acquisition_timer = QTimer()
        self._acquisition_timer.timeout.connect(self._handle_acquisition)
        self._avg_data = {}  # name -> (count, (x_data, y_data))
        self._max_hold_data = {}  # name -> (x_data, max_y_data)
        self._rolling_buffers = {}  # name -> deque of last N traces
        
        # Create default plot
        self._create_default_plot()

    @classmethod
    def from_discovery_info(cls, info: Dict[str, str]) -> 'Device':
        """Create Device instance from discovery information."""
        device = cls(
            manufacturer=info.get('manufacturer'),
            model=info.get('model'),
            serial_number=info.get('serial'),
            firmware=info.get('firmware'),
            resource=info.get('resource')
        )
        return device

    def _create_default_plot(self):
        """Create default plot for device data."""
        plot = self.state.create_model(Plot, 
            name=f"{self.get_property('model')} Plot",
            title=f"{self.get_property('model')} Data"
        )
        self.state.link_models(self.id, plot.id)
        self.set_property('default_plot_id', plot.id)

    @property
    def default_plot(self):
        """Get default plot for device data."""
        plot_id = self.get_property('default_plot_id')
        if plot_id:
            return self.state.get_model(plot_id)
        return None

    def _handle_acquisition(self):
        """Handle timer-based acquisition."""
        if not self.get_property('is_acquiring'):
            self._acquisition_timer.stop()
            return

        mode = AcquisitionMode(self.get_property('acquisition_mode'))
        plot = self.default_plot
        if not plot:
            return

        try:
            traces = self.instrument.fetch_trace()
            if not traces:
                return

            for trace in traces:
                name = trace.get_property('name')
                x_data, y_data = trace.data

                if mode == AcquisitionMode.MAX_HOLD:
                    # Update live trace
                    plot.set_trace(name, trace.data)
                    
                    # Update max hold trace
                    if name not in self._max_hold_data:
                        self._max_hold_data[name] = (x_data, y_data.copy())
                    else:
                        _, max_y = self._max_hold_data[name]
                        np.maximum(max_y, y_data, out=max_y)
                    
                    # Display max hold trace
                    max_data = (x_data, self._max_hold_data[name][1])
                    plot.set_trace(f"{name}_Max", max_data, 
                                 color='#FFA500', style='dash')

                elif mode == AcquisitionMode.ROLLING_AVG:
                    # Update rolling buffer
                    avg_count = self.get_property('averaging_count', 10)
                    if name not in self._rolling_buffers:
                        self._rolling_buffers[name] = deque(maxlen=avg_count)
                    
                    self._rolling_buffers[name].append(y_data)
                    
                    # Update live trace
                    plot.set_trace(name, trace.data)
                    
                    # Calculate and display rolling average
                    avg_y = np.mean(self._rolling_buffers[name], axis=0)
                    plot.set_trace(f"{name}_Avg", (x_data, avg_y),
                                 color='#4169E1', width=2)

                elif mode == AcquisitionMode.CONTINUOUS:
                    plot.set_trace(name, trace.data)

                elif mode == AcquisitionMode.AVERAGE:
                    if name not in self._avg_data:
                        self._avg_data[name] = (1, trace.data)
                    else:
                        count, (avg_x, avg_y) = self._avg_data[name]
                        avg_y = (avg_y * count + y_data) / (count + 1)
                        self._avg_data[name] = (count + 1, (avg_x, avg_y))

                    count, avg_data = self._avg_data[name]
                    plot.set_trace(f'{name}_avg', avg_data,
                                 color='#4169E1', width=2)

                    if count >= self.get_property('averaging_count', 10):
                        del self._avg_data[name]
                        if not self._avg_data:
                            self.stop_acquisition()

        except Exception as e:
            self.set_property('error_message', str(e))
            self.stop_acquisition()

    def _acquire_single(self):
        """Handle single/stack acquisition."""
        try:
            traces = self.instrument.fetch_trace()
            if not traces:
                return

            plot = self.default_plot
            if not plot:
                return

            mode = AcquisitionMode(self.get_property('acquisition_mode'))

            if mode == AcquisitionMode.SINGLE:
                # Get current trace names
                existing_traces = set()
                for trace in traces:
                    name = trace.get_property('name')
                    existing_traces.add(name)
                    plot.set_trace(name, trace.data)

                # Remove any traces that weren't updated
                for child in plot.get_children():
                    if (isinstance(child, Trace) and 
                        child.get_property('name') not in existing_traces):
                        self.state.remove_model(child.id)

            else:  # STACK mode
                timestamp = time.strftime('%H:%M:%S')
                for trace in traces:
                    name = f"{trace.get_property('name')}_{timestamp}"
                    plot.set_trace(name, trace.data)

        except Exception as e:
            self.set_property('error_message', str(e))
        finally:
            self.stop_acquisition()

    def start_acquisition(self):
        """Start acquisition based on current mode."""
        if not self.get_property('is_connected'):
            return

        mode = AcquisitionMode(self.get_property('acquisition_mode'))
        
        # Clear appropriate state data
        if mode == AcquisitionMode.MAX_HOLD:
            self._max_hold_data.clear()
        elif mode == AcquisitionMode.ROLLING_AVG:
            self._rolling_buffers.clear()
        elif mode == AcquisitionMode.AVERAGE:
            self._avg_data.clear()

        self.set_property('is_acquiring', True)

        if mode in [AcquisitionMode.SINGLE, AcquisitionMode.STACK]:
            self._acquire_single()
        else:
            self._acquisition_timer.start(100)

    def stop_acquisition(self):
        """Stop any ongoing acquisition."""
        self._acquisition_timer.stop()
        self.set_property('is_acquiring', False)
            
    @classmethod
    def from_discovery_info(cls, info: Dict[str, str]) -> 'Device':
        """Create Device instance from discovery information."""
        logger.debug(f"Device.from_discovery_info: Creating device from {info}")
        device = cls(
            manufacturer=info.get('manufacturer'),
            model=info.get('model'),
            serial_number=info.get('serial'),
            firmware=info.get('firmware'),
            resource=info.get('resource')
        )
        logger.debug(f"Device.from_discovery_info: Created device {device.id}")
        return device

    def _load_driver_info(self) -> None:
        """Load driver information and build parameter tree."""
        try:
            model = self.get_property('model')
            logger.debug(f"Device._load_driver_info: Starting to load driver info for model '{model}'")
            
            # Get driver info from registry
            driver_info = get_driver_info(model)
            logger.debug(f"Device._load_driver_info: Retrieved driver info: {driver_info}")
            self._driver_info = driver_info
            
            # Import driver module
            module_name = driver_info['module']
            logger.debug(f"Device._load_driver_info: Importing module '{module_name}'")
            module = importlib.import_module(module_name)
            logger.debug(f"Device._load_driver_info: Module '{module_name}' imported successfully")
            
            # Retrieve driver class
            class_name = driver_info['class']
            logger.debug(f"Device._load_driver_info: Retrieving driver class '{class_name}'")
            driver_class = getattr(module, class_name)
            logger.debug(f"Device._load_driver_info: Driver class '{class_name}' retrieved successfully")
            
            # Use InstrumentFactory to build the UI-friendly configuration.
            from pymetr.core.factory import InstrumentFactory
            factory = InstrumentFactory()
            logger.debug("Device._load_driver_info: Retrieving driver source code")
            driver_source = inspect.getsource(driver_class)
            logger.debug("Device._load_driver_info: Creating UI configuration from driver source")
            ui_config = factory.create_ui_configuration_from_source(driver_source)
            logger.debug(f"Device._load_driver_info: UI configuration: {ui_config}")
            
            # We expect ui_config to contain a 'parameter_tree' key which is a list.
            self._parameter_tree = ui_config.get('parameter_tree', [])
            logger.debug(f"Device._load_driver_info: UI parameter tree set to: {self._parameter_tree}")
            
            self.set_property('parameter_tree', self._parameter_tree)
            logger.debug("Device._load_driver_info: Parameter tree set as property")
            
        except Exception as e:
            logger.error(f"Device._load_driver_info: Error loading driver info: {e}")
            self.error_message = f"Failed to load driver: {str(e)}"

    def connect_device(self):
        """Connect device and load driver."""
        try:
            logger.debug("Device.connect_device: Initiating connection sequence")
            
            # Load driver info first
            self._load_driver_info()
            
            if not self._driver_info:
                raise ValueError("No driver info loaded")
                
            # Create and connect instrument
            from pymetr.core.registry import get_registry
            registry = get_registry()
            
            connection = self._create_connection()
            self.instrument = registry.create_driver_instance(
                self,
                connection
            )
            
            # Connect to instrument signals
            self._connect_instrument_signals()
            
            # Store parameter tree for UI
            self.set_property('parameter_tree', self._parameter_tree)
            
            # Set connection state
            self.set_property('is_connected', True)
            self.connection_changed.emit(True)
            
        except Exception as e:
            self.error_message = str(e)
            raise

    def disconnect(self):
        """Disconnect instrument."""
        try:
            if self.instrument:
                self._disconnect_instrument_signals()
                self.instrument.close()
                self.instrument = None
            self.set_property('is_connected', False)
            self.connection_changed.emit(False)
        except Exception as e:
            self.error_message = str(e)
            raise

    @property
    def driver_info(self) -> Dict[str, Any]:
        """Get driver information dictionary."""
        return self._driver_info.copy()

    @property
    def parameter_tree(self) -> Any:
        """Get parameter tree structure (UI configuration)."""
        return self._parameter_tree

    @property
    def error_message(self) -> Optional[str]:
        """Get current error message, if any."""
        return self._error_message

    @error_message.setter
    def error_message(self, value: Optional[str]):
        """Set error message and update property."""
        self._error_message = value
        self.set_property('error_message', value)
        if value:
            self.error_occurred.emit(value)

    def update_parameter(self, path: str, value: Any) -> None:
        """
        Update a parameter value in the device's state.
        """
        try:
            logger.debug(f"Device.update_parameter: Updating parameter '{path}' with value '{value}'")
            parts = path.split('.')
            current = self._parameter_tree
            for part in parts[:-1]:
                if part not in current:
                    current[part] = {}
                    logger.debug(f"Device.update_parameter: Created intermediate node for '{part}'")
                current = current[part]
            current[parts[-1]] = value
            logger.debug(f"Device.update_parameter: Parameter '{path}' updated to '{value}'")
            self.property_changed.emit(self.id, self.model_type, path, value)
        except Exception as e:
            logger.error(f"Device.update_parameter: Error updating parameter {path}: {e}")
            self.error_message = f"Failed to update {path}: {str(e)}"

    def set_connection_state(self, connected: bool) -> None:
        """
        Update device connection state.
        """
        if self.get_property('is_connected') != connected:
            self.set_property('is_connected', connected)
            self.connection_changed.emit(connected)
            if not connected:
                self.error_message = None

    def refresh_parameters(self) -> None:
        """
        Refresh parameter tree from driver.
        """
        if self._driver_info:
            logger.debug("Device.refresh_parameters: Refreshing parameters from driver")
            self._load_driver_info()

    def reset_state(self) -> None:
        """Reset device state to defaults."""
        self.set_connection_state(False)
        self.error_message = None
        self._parameter_tree = {}
        self.set_property('parameter_tree', self._parameter_tree)

    def _connect_instrument_signals(self):
        """Connect to instrument property changes."""
        if self.instrument:
            # Clear any existing connections
            self._disconnect_instrument_signals()
            
            # Connect property changes
            self._instrument_connections.extend([
                self.instrument.commandSent.connect(self._handle_command),
                self.instrument.responseReceived.connect(self._handle_response),
                self.instrument.exceptionOccured.connect(self._handle_error),
                self.instrument.property_changed.connect(self._handle_instrument_property)
            ])

    def _disconnect_instrument_signals(self):
        """Clean up instrument signal connections."""
        for connection in self._instrument_connections:
            try:
                connection.disconnect()
            except:
                pass
        self._instrument_connections.clear()

    def _handle_instrument_property(self, prop: str, value: Any):
        """Propagate instrument property changes to parameter tree."""
        # Update parameter tree if needed
        if prop in self._parameter_tree:
            self.update_parameter(prop, value)

    def _create_connection(self) -> 'ConnectionInterface':
        """Create appropriate connection based on resource string."""
        from pymetr.drivers.base.connections import PyVisaConnection, RawSocketConnection
        
        resource = self.get_property('resource')
        if not resource:
            raise ValueError("No resource string available")
            
        # Determine connection type from resource string
        if resource.startswith('TCPIP') and '::SOCKET' in resource:
            return RawSocketConnection(resource)
        else:
            return PyVisaConnection(resource)
        
    def cleanup(self):
        """Clean up resources."""
        try:
            if self.instrument:
                self.disconnect()
            self._disconnect_instrument_signals()
        except:
            pass
        super().cleanup()

    def _handle_command(self, command: str):
        """Handle SCPI command sent."""
        logger.debug(f"Command sent: {command}")

    def _handle_response(self, command: str, response: str):
        """Handle SCPI command response."""
        logger.debug(f"Response to {command}: {response}")

    def _handle_error(self, error: str):
        """Handle SCPI command error."""
        logger.error(f"SCPI error: {error}")
        self.error_message = error



================================================================================
*** marker.py ***
### src/pymetr/models/marker.py ###
================================================================================

from typing import Optional, Tuple, TYPE_CHECKING
import numpy as np
from scipy import interpolate

from PySide6.QtCore import QThread, Qt, QMetaObject, Q_ARG

from pymetr.models.base import BaseModel
from pymetr.core.logging import logger


class Marker(BaseModel):
    """
    A marker on the plot, typically a scatter point or set of points,
    plus optional text annotation.
    
    Properties:
        x (float): X-coordinate of the marker
        y (float): Y-coordinate of the marker
        name (str): Text name for the marker
        color (str): Marker color (e.g., 'yellow', '#FFFF00')
        size (int): Marker size in pixels
        symbol (str): Marker symbol ('o' for circle, 't' for triangle, etc.)
        visible (bool): Whether the marker is visible
    """

    def __init__(
        self, 
        x: float = 0, 
        y: float = 0,
        name: str = "",
        color: str = "yellow",
        size: int = 8,
        symbol: str = "o",
        visible: bool = True,
        model_id: Optional[str] = None,
    ):
        super().__init__(model_type='Marker', model_id=model_id, name=name)
        self._init_properties(x, y, name, color, size, symbol, visible)

    def _init_properties(self, x, y, name, color, size, symbol, visible):
        """Initialize all marker properties."""
        self.set_property("x", x)
        self.set_property("y", y)
        self.set_property("name", name)
        self.set_property("color", color)
        self.set_property("size", size)
        self.set_property("symbol", symbol)
        self.set_property("visible", visible)

    # --- Property Accessors ---

    @property
    def x(self) -> float:
        """Get marker x-coordinate."""
        return self.get_property("x")

    @x.setter
    def x(self, value: float):
        self.set_property("x", value)

    @property
    def y(self) -> float:
        """Get marker y-coordinate."""
        return self.get_property("y")

    @y.setter
    def y(self, value: float):
        self.set_property("y", value)

    @property
    def name(self) -> str:
        """Get marker name text."""
        return self.get_property("name")

    @name.setter
    def name(self, value: str):
        self.set_property("name", value)

    @property
    def color(self) -> str:
        """Get marker color."""
        return self.get_property("color")

    @color.setter
    def color(self, value: str):
        self.set_property("color", value)

    @property
    def size(self) -> int:
        """Get marker size."""
        return self.get_property("size")

    @size.setter
    def size(self, value: int):
        self.set_property("size", value)

    @property
    def symbol(self) -> str:
        """Get marker symbol."""
        return self.get_property("symbol")

    @symbol.setter
    def symbol(self, value: str):
        self.set_property("symbol", value)

    @property
    def visible(self) -> bool:
        """Get marker visibility."""
        return self.get_property("visible")

    @visible.setter
    def visible(self, value: bool):
        self.set_property("visible", value)

    @property
    def position(self) -> Tuple[float, float]:
        """Get marker position as (x, y) tuple."""
        return (self.x, self.y)

    @property
    def bound_to_trace(self) -> bool:
        """Check if marker is bound to a trace."""
        if not self.state:
            return False
        parent = self.state.get_parent(self.id)
        # Check type by name instead of using isinstance
        return parent is not None and parent.model_type == 'Trace'
    
    def _get_interpolated_y(self, x: float) -> Optional[float]:
        """Get interpolated y-value from parent trace at x position."""
        if not self.bound_to_trace:
            return None
            
        parent = self.state.get_parent(self.id)
        if not parent:
            return None
            
        # Get trace data
        x_data = parent.get_property('x_data', [])
        y_data = parent.get_property('y_data', [])
        if len(x_data) == 0 or len(y_data) == 0:
            return None
            
        # Get interpolation mode
        mode = self.get_property('interpolation_mode', 'linear')
        
        try:
            if mode == 'nearest':
                # Find nearest point
                idx = np.abs(np.array(x_data) - x).argmin()
                return y_data[idx]
                
            elif mode == 'linear':
                # Linear interpolation
                if x < min(x_data) or x > max(x_data):
                    return None
                f = interpolate.interp1d(x_data, y_data, 
                                       bounds_error=False,
                                       fill_value=np.nan)
                return float(f(x))
                
        except Exception as e:
            logger.error(f"Error interpolating marker value: {e}")
            return None
            
        return None
    
    def get_position(self) -> Tuple[float, float]:
        """
        Get marker position, computing y from trace if bound.
        Returns (x, y) tuple.
        """
        x = self.get_property('x', 0.0)
        
        if self.bound_to_trace:
            # Get y from trace interpolation
            y = self._get_interpolated_y(x)
            if y is not None:
                return (x, y)
        
        # Free marker or interpolation failed
        return (x, self.get_property('y', 0.0))
    
    def get_uncertainty_bounds(self) -> Tuple[Optional[float], Optional[float]]:
        """
        Get uncertainty bounds if enabled.
        Returns (lower, upper) tuple or (None, None) if disabled.
        """
        if not self.get_property('uncertainty_visible', False):
            return (None, None)
            
        _, y = self.get_position()
        lower = y - self.get_property('uncertainty_lower', 0.0)
        upper = y + self.get_property('uncertainty_upper', 0.0)
        return (lower, upper)
    
    def follows_parent_isolation(self) -> bool:
        """
        Determine if marker should follow parent into isolation.
        True if bound to a trace.
        """
        return self.bound_to_trace
    
    # --- Public Methods ---

    def set_position(self, x: float, y: float):
        """Set marker position with thread safety."""
        if QThread.currentThread() != self.thread():
            QMetaObject.invokeMethod(
                self,
                "_set_position_internal",
                Qt.QueuedConnection,
                Q_ARG(float, x),
                Q_ARG(float, y)
            )
        else:
            self._set_position_internal(x, y)

    # --- Internal Methods ---

    def _set_position_internal(self, x: float, y: float):
        """Internal method to update position."""
        self.set_property("x", x)
        self.set_property("y", y)
        logger.debug(f"Marker {self.id} moved to ({x}, {y}).")


================================================================================
*** measurement.py ***
### src/pymetr/models/measurement.py ###
================================================================================

from typing import Optional
from pymetr.models.base import BaseModel
from pymetr.core.logging import logger

class Measurement(BaseModel):
    """
    A single measurement value with optional limits for validation.
    """
    def __init__(self, name: str, value: float, units: str = "", model_id: Optional[str] = None):
        super().__init__(model_type='Measurement', model_id=model_id)
        self.set_property("name", name)
        self.set_property("value", value)
        self.set_property("units", units)
        self.set_property("timestamp", None)
        self.set_property("limits", None)  # Optional (min, max) tuple
        self.set_property("status", "Valid")  # 'Valid', 'Invalid', or 'Warning'

    @property
    def name(self) -> str:
        return self.get_property("name")

    @property
    def value(self) -> float:
        return self.get_property("value")

    @value.setter
    def value(self, val: float):
        self.set_property("value", val)
        # Check limits if present
        limits = self.get_property("limits")
        if limits:
            min_val, max_val = limits
            if not (min_val <= val <= max_val):
                self.set_property("status", "Invalid")
            else:
                self.set_property("status", "Valid")

    @property
    def units(self) -> str:
        return self.get_property("units")

    def set_limits(self, min_val: float, max_val: float):
        """Set measurement limits and validate current value."""
        self.set_property("limits", (min_val, max_val))
        # Re-check current value
        curr_val = self.value
        if not (min_val <= curr_val <= max_val):
            self.set_property("status", "Invalid")

    def to_string(self) -> str:
        """Simple string representation (e.g. '12.34 V')."""
        if self.units:
            return f"{self.value} {self.units}"
        return str(self.value)



================================================================================
*** plot.py ***
### src/pymetr/models/plot.py ###
================================================================================

from typing import Optional, List, Dict, Any, Tuple, TYPE_CHECKING, Union
import numpy as np
from pymetr.models.base import BaseModel
from pymetr.core.logging import logger

if TYPE_CHECKING:
    from pymetr.models.trace import Trace
    from pymetr.models.marker import Marker
    from pymetr.models.cursor import Cursor
    from pymetr.models.measurement import Measurement

class Plot(BaseModel):
    """
    A plot container with comprehensive plotting properties.
    
    Properties:
        Basic Properties:
            title (str): Plot title
            x_label (str): X-axis label
            y_label (str): Y-axis label
            x_unit (str): X-axis units
            y_unit (str): Y-axis units
            
        Display Properties:
            grid_enabled (bool): Show/hide grid
            legend_enabled (bool): Show/hide legend
            roi_visible (bool): Show/hide ROI panel
            background_color (str): Plot background color
            foreground_color (str): Text and axis color
            grid_color (str): Grid line color
            grid_alpha (float): Grid transparency
            legend_position (str): Legend placement ('right', 'top', 'bottom', 'left')
            
        Axis Properties:
            x_log (bool): X-axis logarithmic scaling
            y_log (bool): Y-axis logarithmic scaling
            x_inverted (bool): X-axis direction
            y_inverted (bool): Y-axis direction
            x_ticks (List[float]): Custom X-axis tick positions
            y_ticks (List[float]): Custom Y-axis tick positions
            x_tick_labels (List[str]): Custom X-axis tick labels
            y_tick_labels (List[str]): Custom Y-axis tick labels
            
        Range Properties:
            x_lim (Tuple[float, float]): X-axis limits (min, max)
            y_lim (Tuple[float, float]): Y-axis limits (min, max)
    """

    def __init__(self, title: str, model_id: Optional[str] = None):
        super().__init__(model_type='Plot', model_id=model_id, name=title)
        self._init_properties(title)

    def _init_properties(self, title: str):
        """Initialize all plot properties with defaults."""
        # Basic properties
        self.set_property("title", title)
        self.set_property("x_label", "")
        self.set_property("y_label", "")
        self.set_property("x_unit", "")
        self.set_property("y_unit", "")

        # Display properties
        self.set_property("grid_enabled", True)
        self.set_property("legend_enabled", True)
        self.set_property("roi_visible", True)
        self.set_property("background_color", "#1E1E1E")
        self.set_property("foreground_color", "#FFFFFF")
        self.set_property("grid_color", "#404040")
        self.set_property("grid_alpha", 0.3)
        self.set_property("legend_position", "right")

        # Axis properties
        self.set_property("x_log", False)
        self.set_property("y_log", False)
        self.set_property("x_inverted", False)
        self.set_property("y_inverted", False)
        self.set_property("x_ticks", None)
        self.set_property("y_ticks", None)
        self.set_property("x_tick_labels", None)
        self.set_property("y_tick_labels", None)

        # Range properties
        self.set_property("x_lim", None)
        self.set_property("y_lim", None)

        # ROI properties
        self.set_property("roi", None)  # Will be set when ROI is first shown
        self.set_property("roi_visible", False)

    # --- Basic Property Accessors ---

    @property
    def title(self) -> str:
        return self.get_property("title")

    @title.setter
    def title(self, value: str):
        self.set_property("title", value)

    @property
    def x_label(self) -> str:
        return self.get_property("x_label")

    @x_label.setter
    def x_label(self, value: str):
        self.set_property("x_label", value)

    @property
    def y_label(self) -> str:
        return self.get_property("y_label")

    @y_label.setter
    def y_label(self, value: str):
        self.set_property("y_label", value)

    @property
    def x_unit(self) -> str:
        return self.get_property("x_unit")

    @x_unit.setter
    def x_unit(self, value: str):
        self.set_property("x_unit", value)

    @property
    def y_unit(self) -> str:
        return self.get_property("y_unit")

    @y_unit.setter
    def y_unit(self, value: str):
        self.set_property("y_unit", value)

    # --- Display Property Accessors ---

    @property
    def grid_enabled(self) -> bool:
        return self.get_property("grid_enabled")

    @grid_enabled.setter
    def grid_enabled(self, value: bool):
        self.set_property("grid_enabled", bool(value))

    @property
    def legend_enabled(self) -> bool:
        return self.get_property("legend_enabled")

    @legend_enabled.setter
    def legend_enabled(self, value: bool):
        self.set_property("legend_enabled", bool(value))

    @property
    def roi(self) -> Optional[List[float]]:
        """Get the ROI region as [start, end]."""
        return self.get_property("roi")

    @roi.setter
    def roi(self, value: Optional[List[float]]):
        """Set the ROI region."""
        if value is not None:
            if not isinstance(value, (list, tuple)) or len(value) != 2:
                raise ValueError("ROI must be a list/tuple of [start, end] or None")
            value = [float(x) for x in value]
        self.set_property("roi", value)

    @property
    def roi_visible(self) -> bool:
        """Get ROI visibility state."""
        return self.get_property("roi_visible", True)

    @roi_visible.setter
    def roi_visible(self, value: bool):
        """Set ROI visibility."""
        self.set_property("roi_visible", bool(value))

    @property
    def background_color(self) -> str:
        return self.get_property("background_color")

    @background_color.setter
    def background_color(self, value: str):
        self.set_property("background_color", value)

    @property
    def foreground_color(self) -> str:
        return self.get_property("foreground_color")

    @foreground_color.setter
    def foreground_color(self, value: str):
        self.set_property("foreground_color", value)

    @property
    def grid_color(self) -> str:
        return self.get_property("grid_color")

    @grid_color.setter
    def grid_color(self, value: str):
        self.set_property("grid_color", value)

    @property
    def grid_alpha(self) -> float:
        return self.get_property("grid_alpha")

    @grid_alpha.setter
    def grid_alpha(self, value: float):
        self.set_property("grid_alpha", float(value))

    @property
    def legend_position(self) -> str:
        return self.get_property("legend_position")

    @legend_position.setter
    def legend_position(self, value: str):
        if value not in ("right", "top", "bottom", "left"):
            raise ValueError("Legend position must be 'right', 'top', 'bottom', or 'left'")
        self.set_property("legend_position", value)

    # --- Axis Property Accessors ---

    @property
    def x_log(self) -> bool:
        return self.get_property("x_log")

    @x_log.setter
    def x_log(self, value: bool):
        self.set_property("x_log", bool(value))

    @property
    def y_log(self) -> bool:
        return self.get_property("y_log")

    @y_log.setter
    def y_log(self, value: bool):
        self.set_property("y_log", bool(value))

    @property
    def x_inverted(self) -> bool:
        return self.get_property("x_inverted")

    @x_inverted.setter
    def x_inverted(self, value: bool):
        self.set_property("x_inverted", bool(value))

    @property
    def y_inverted(self) -> bool:
        return self.get_property("y_inverted")

    @y_inverted.setter
    def y_inverted(self, value: bool):
        self.set_property("y_inverted", bool(value))

    @property
    def x_ticks(self) -> Optional[List[float]]:
        return self.get_property("x_ticks")

    @x_ticks.setter
    def x_ticks(self, value: Optional[List[float]]):
        if value is not None:
            value = [float(x) for x in value]
        self.set_property("x_ticks", value)

    @property
    def y_ticks(self) -> Optional[List[float]]:
        return self.get_property("y_ticks")

    @y_ticks.setter
    def y_ticks(self, value: Optional[List[float]]):
        if value is not None:
            value = [float(y) for y in value]
        self.set_property("y_ticks", value)

    @property
    def x_tick_labels(self) -> Optional[List[str]]:
        return self.get_property("x_tick_labels")

    @x_tick_labels.setter
    def x_tick_labels(self, value: Optional[List[str]]):
        if value is not None:
            value = [str(x) for x in value]
        self.set_property("x_tick_labels", value)

    @property
    def y_tick_labels(self) -> Optional[List[str]]:
        return self.get_property("y_tick_labels")

    @y_tick_labels.setter
    def y_tick_labels(self, value: Optional[List[str]]):
        if value is not None:
            value = [str(y) for y in value]
        self.set_property("y_tick_labels", value)

    # --- Range Property Accessors ---

    @property
    def x_lim(self) -> Optional[Tuple[float, float]]:
        return self.get_property("x_lim")

    @x_lim.setter
    def x_lim(self, value: Optional[Tuple[float, float]]):
        if value is not None:
            if not isinstance(value, (tuple, list)) or len(value) != 2:
                raise ValueError("x_lim must be a tuple/list of (min, max) or None")
            value = (float(value[0]), float(value[1]))
        self.set_property("x_lim", value)

    @property
    def y_lim(self) -> Optional[Tuple[float, float]]:
        return self.get_property("y_lim")

    @y_lim.setter
    def y_lim(self, value: Optional[Tuple[float, float]]):
        if value is not None:
            if not isinstance(value, (tuple, list)) or len(value) != 2:
                raise ValueError("y_lim must be a tuple/list of (min, max) or None")
            value = (float(value[0]), float(value[1]))
        self.set_property("y_lim", value)

    def add(self, item: Union['BaseModel', List['BaseModel']]) -> None:
        """
        Add an existing Trace, Marker, or Cursor to the plot.
        Accepts a single model or a list of models.
        If a model already has a parent, it will be moved to this plot.
        
        Args:
            item: A Trace, Marker, or Cursor instance or a list of such instances
            
        Raises:
            TypeError: If any item is not a valid plot item type.
        """
        from pymetr.models import Trace, Marker, Cursor

        # Wrap single model into a list for uniform processing
        items = item if isinstance(item, list) else [item]
        
        for model in items:
            if not isinstance(model, (Trace, Marker, Cursor)):
                raise TypeError(
                    f"Can only add Trace, Marker, or Cursor objects, got {type(model).__name__}"
                )
            # Unlink from the current parent if it exists
            current_parent = self.state.get_parent(model.id)
            if current_parent:
                self.state.unlink_models(current_parent.id, model.id)
                
            # Add the model as a child of this plot
            self.add_child(model)
            logger.debug(f"Added {type(model).__name__} {model.id} to Plot {self.id}")


# --- Trace Management Methods ---

    def create_trace(
        self,
        x_data: np.ndarray,
        y_data: np.ndarray,
        name: str = "",
        **kwargs
    ) -> 'Trace':
        """
        Create and register a new Trace model.
        
        Args:
            x_data: X-axis data points
            y_data: Y-axis data points
            name: Display name for the trace
            **kwargs: Additional trace properties (color, style, etc.)
            
        Returns:
            Trace: The created trace object
        """
        from pymetr.models import Trace
        trace = self.state.create_model(
            Trace,
            x_data=x_data,
            y_data=y_data,
            name=name,
            **kwargs
        )
        self.add(trace)
        return trace

    def set_trace(
        self,
        trace_name: str,
        x_data: np.ndarray,
        y_data: np.ndarray,
        mode: Optional[str] = None,
        color: Optional[str] = None,
        style: Optional[str] = None,
        width: Optional[int] = None,
        marker_style: Optional[str] = None,
        visible: Optional[bool] = None,
        opacity: Optional[float] = None,
    ) -> 'Trace':
        """
        Create or update a trace by name. Only updates properties that are explicitly passed.
        
        Args:
            trace_name: Name to identify the trace
            x_data: X-axis data points
            y_data: Y-axis data points
            mode: Optional - 'Group' or 'Isolate'
            color: Optional - Trace color (hex or name)
            style: Optional - Line style ('solid', 'dash', 'dot', etc.)
            width: Optional - Line width
            marker_style: Optional - Point marker style
            visible: Optional - Visibility flag
            opacity: Optional - Opacity value (0.0 to 1.0)
            
        Returns:
            Trace: The created or updated trace object
        """
        from pymetr.models import Trace

        # Look for existing trace
        existing_trace = None
        for t in self.get_traces():
            if t.name == trace_name:
                existing_trace = t
                break

        if existing_trace is None:
            # For new traces, collect only the non-None properties
            props = {
                'x_data': x_data,
                'y_data': y_data,
                'name': trace_name
            }
            
            # Only add optional properties if they were explicitly set
            optional_props = {
                'mode': mode,
                'color': color,
                'style': style,
                'width': width,
                'marker_style': marker_style,
                'visible': visible,
                'opacity': opacity
            }
            
            # Add only non-None optional properties
            props.update({k: v for k, v in optional_props.items() if v is not None})
            
            # Create new trace with collected properties
            logger.debug(f"Creating new trace '{trace_name}' in Plot '{self.title}'.")
            new_trace = self.state.create_model(Trace, **props)
            self.add_child(new_trace)
            return new_trace
        else:
            # Always update data
            existing_trace.data = (x_data, y_data)

            # Only update properties that were explicitly passed (not None)
            if mode is not None:
                existing_trace.set_property('mode', mode)
            if color is not None:
                existing_trace.set_property('color', color)
            if style is not None:
                existing_trace.set_property('style', style)
            if width is not None:
                existing_trace.set_property('width', width)
            if marker_style is not None:
                existing_trace.set_property('marker_style', marker_style)
            if visible is not None:
                existing_trace.set_property('visible', visible)
            if opacity is not None:
                existing_trace.set_property('opacity', opacity)
                
            return existing_trace

    def get_traces(self) -> List['Trace']:
        """Return all Trace children."""
        from pymetr.models import Trace
        return [child for child in self.get_children() if isinstance(child, Trace)]

    def get_markers(self) -> List['Marker']:
        """Return all Marker children."""
        from pymetr.models import Marker
        return [child for child in self.get_children() if isinstance(child, Marker)]

    def get_cursors(self) -> List['Cursor']:
        """Return all Cursor children."""
        from pymetr.models import Cursor
        return [child for child in self.get_children() if isinstance(child, Cursor)]

    def create_marker(
        self, 
        x: float,
        y: float,
        name: str = "",
        **kwargs
    ) -> 'Marker':
        """
        Create and register a new Marker model.
        
        Args:
            x: X-coordinate
            y: Y-coordinate
            name: Optional marker name (auto-generated if empty)
            **kwargs: Additional marker properties
                Defaults handled by Marker class:
                - color: "yellow"
                - size: 8
                - symbol: "o"
                - visible: True
        """
        from pymetr.models import Marker
        if not name:
            current_markers = self.get_markers()
            name = f"Marker {len(current_markers) + 1}"
            
        marker = self.state.create_model(
            Marker,
            x=x,
            y=y,
            name=name,
            **kwargs
        )
        self.add_child(marker)
        return marker

    def set_marker(
        self,
        name: str,
        x: float,
        y: float,
        color: Optional[str] = None,
        size: Optional[int] = None,
        symbol: Optional[str] = None,
        visible: Optional[bool] = None
    ) -> 'Marker':
        """
        Create or update a marker by name.
        Only updates properties that are explicitly passed.
        """
        existing_marker = None
        for marker in self.get_markers():
            if marker.name == name:
                existing_marker = marker
                break

        if existing_marker is None:
            # For new markers, only include non-None properties
            props = {'x': x, 'y': y}
            if color is not None: props['color'] = color
            if size is not None: props['size'] = size
            if symbol is not None: props['symbol'] = symbol
            if visible is not None: props['visible'] = visible
            
            return self.create_marker(name=name, **props)
        else:
            # Always update position
            existing_marker.x = x
            existing_marker.y = y
            
            # Only update properties that were explicitly passed
            if color is not None:
                existing_marker.color = color
            if size is not None:
                existing_marker.size = size
            if symbol is not None:
                existing_marker.symbol = symbol
            if visible is not None:
                existing_marker.visible = visible
            
            return existing_marker

    def create_cursor(
        self,
        position: float,
        axis: str = "x",
        name: str = "",
        **kwargs
    ) -> 'Cursor':
        """
        Create and register a new Cursor model.
        
        Args:
            position: Position along the axis
            axis: 'x' for vertical, 'y' for horizontal
            name: Optional cursor name (auto-generated if empty)
            **kwargs: Additional cursor properties
                Defaults handled by Cursor class:
                - color: "yellow"
                - style: "solid"
                - width: 1
                - visible: True
        """
        from pymetr.models import Cursor
        if not name:
            current_cursors = self.get_cursors()
            name = f"Cursor {len(current_cursors) + 1}"
            
        cursor = self.state.create_model(
            Cursor,
            position=position,
            axis=axis,
            name=name,
            **kwargs
        )
        self.add_child(cursor)
        return cursor

    def set_cursor(
        self,
        name: str,
        position: float,
        axis: Optional[str] = None,
        color: Optional[str] = None,
        style: Optional[str] = None,
        width: Optional[int] = None,
        visible: Optional[bool] = None
    ) -> 'Cursor':
        """
        Create or update a cursor by name.
        Only updates properties that are explicitly passed.
        """
        existing_cursor = None
        for cursor in self.get_cursors():
            if cursor.name == name:
                existing_cursor = cursor
                break

        if existing_cursor is None:
            # For new cursors, only include non-None properties
            props = {'position': position}
            if axis is not None: props['axis'] = axis
            if color is not None: props['color'] = color
            if style is not None: props['style'] = style
            if width is not None: props['width'] = width
            if visible is not None: props['visible'] = visible
            
            return self.create_cursor(name=name, **props)
        else:
            # Always update position
            existing_cursor.position = position
            
            # Only update properties that were explicitly passed
            if axis is not None:
                existing_cursor.axis = axis
            if color is not None:
                existing_cursor.color = color
            if style is not None:
                existing_cursor.style = style
            if width is not None:
                existing_cursor.width = width
            if visible is not None:
                existing_cursor.visible = visible
            
            return existing_cursor
    
    def clear(self):
        """Remove all child items (traces, markers, cursors)."""
        children = self.get_children()
        for child in children:
            self.state.unlink_models(self.id, child.id)
            self.state.remove_model(child.id)
        logger.debug(f"Cleared all items from Plot {self.id} ('{self.title}').")


================================================================================
*** table.py ***
### src/pymetr/models/table.py ###
================================================================================

import pandas as pd
from typing import Optional, List, Any
from pymetr.models.base import BaseModel
from pymetr.core.logging import logger

class DataTable(BaseModel):
    """
    Represents a tabular dataset with columns and rows.
    Stores data as a pandas DataFrame.
    """
    def __init__(
        self,
        title: str,
        columns: Optional[List[str]] = None,
        model_id: Optional[str] = None
    ):
        super().__init__(model_type='DataTable', model_id=model_id, name=title)
        self.set_property("title", title)
        # Store column names and create an empty DataFrame with those columns.
        columns = columns or []
        self.set_property("columns", columns)
        self.set_property("data", pd.DataFrame(columns=columns))
        logger.debug(f"DataTable '{title}' created with id {self.id}")

    # --- Pythonic Property Accessors ---

    @property
    def columns(self) -> List[str]:
        """Get the list of column names."""
        return self.get_property("columns", [])

    @columns.setter
    def columns(self, column_names: List[str]):
        self.set_columns(column_names)

    @property
    def data(self) -> pd.DataFrame:
        """Get the data as a pandas DataFrame."""
        return self.get_data()

    @data.setter
    def data(self, new_data: pd.DataFrame):
        self.set_property("data", new_data)

    # --- Existing Methods ---

    def get_columns(self) -> List[str]:
        return self.get_property("columns", [])

    def set_columns(self, column_names: List[str]):
        df = self.get_property("data")
        if not isinstance(df, pd.DataFrame):
            df = pd.DataFrame()
        # Reindex the DataFrame to the new columns, filling missing values with None.
        df = df.reindex(columns=column_names)
        self.set_property("columns", column_names)
        self.set_property("data", df)

    def add_column(self, column_name: str):
        df = self.get_property("data")
        if not isinstance(df, pd.DataFrame):
            df = pd.DataFrame()
        df[column_name] = None
        self.set_property("columns", list(df.columns))
        self.set_property("data", df)

    def row_count(self) -> int:
        df = self.get_property("data")
        if isinstance(df, pd.DataFrame):
            return len(df)
        return 0

    def col_count(self) -> int:
        df = self.get_property("data")
        if isinstance(df, pd.DataFrame):
            return len(df.columns)
        return 0

    def add_row(self, row_data: Optional[List[Any]] = None) -> int:
        df = self.get_property("data").copy()  # Create a copy
        columns = self.get_property("columns", [])
        col_count = len(columns)
        if row_data is None:
            row_data = [None] * col_count
        else:
            if len(row_data) < col_count:
                row_data += [None] * (col_count - len(row_data))
            elif len(row_data) > col_count:
                row_data = row_data[:col_count]
        # Create new DataFrame with added row
        new_df = pd.concat([df, pd.DataFrame([row_data], columns=df.columns)], 
                        ignore_index=True)
        self.set_property("data", new_df)
        return len(new_df) - 1

    def remove_row(self, index: int):
        df = self.get_property("data")
        if 0 <= index < len(df):
            df = df.drop(index=index).reset_index(drop=True)
            self.set_property("data", df)

    def get_data(self) -> pd.DataFrame:
        data = self.get_property("data")
        if isinstance(data, pd.DataFrame):
            return data
        return pd.DataFrame()

    def set_data(self, new_data: List[List[Any]]):
        columns = self.get_property("columns", [])
        col_count = len(columns)
        adjusted_rows = []
        for row in new_data:
            if len(row) < col_count:
                row = row + [None] * (col_count - len(row))
            elif len(row) > col_count:
                row = row[:col_count]
            adjusted_rows.append(row)
        df = pd.DataFrame(adjusted_rows, columns=columns)
        self.set_property("data", df)

    def get_value(self, row: int, col: int) -> Any:
        df = self.get_property("data")
        if isinstance(df, pd.DataFrame):
            try:
                return df.iat[row, col]
            except Exception:
                return None
        return None

    def set_value(self, row: int, col: int, value: Any):
        df = self.get_property("data")
        if isinstance(df, pd.DataFrame):
            try:
                df.iat[row, col] = value
                self.set_property("data", df)
            except Exception:
                pass



================================================================================
*** test.py ***
### src/pymetr/models/test.py ###
================================================================================

# pymetr/models/test.py
from pathlib import Path
from datetime import datetime
from typing import Optional, List, Dict

from PySide6.QtCore import Slot
from pymetr.models.base import BaseModel
from pymetr.core.logging import logger

from enum import Enum, auto

class TestStatus(Enum):
    """
    Test script status states.
    
    Flow:
    READY -> RUNNING -> (PASS | FAIL | ERROR | COMPLETE)
    
    READY: Initial state, script can be run
    RUNNING: Script is currently executing
    PASS: All test results passed
    FAIL: At least one test result failed
    ERROR: Script execution error
    COMPLETE: Script completed without any test results
    """
    READY = auto()      # Initial state
    RUNNING = auto()    # Currently executing
    PASS = auto()       # All results passed
    FAIL = auto()       # At least one result failed
    ERROR = auto()      # Script error
    COMPLETE = auto()   # Completed without results

class ResultStatus(Enum):
    """
    Test result status states.
    
    PASS: Test passed its criteria
    FAIL: Test failed its criteria
    ERROR: Error during test execution
    """
    PASS = auto()
    FAIL = auto()
    ERROR = auto()

    @classmethod
    def from_bool(cls, success: bool) -> 'ResultStatus':
        """Convert a boolean success value to ResultStatus."""
        return cls.PASS if success else cls.FAIL


class RunConfig(BaseModel):
    """
    Defines a configuration of scripts to run and their order.
    """
    def __init__(self, **kwargs):
        super().__init__("runconfig", **kwargs)
        
        # Initialize properties
        self.set_property('name', kwargs.get('name', 'Default Config'))
        self.set_property('description', kwargs.get('description', ''))
        self.set_property('is_default', kwargs.get('is_default', False))
        
        # Script execution map: script_id -> order
        self._script_map: Dict[str, int] = {}
    
    def add_script(self, script_id: str, order: int):
        """Add script to this configuration."""
        self._script_map[script_id] = order
    
    def remove_script(self, script_id: str):
        """Remove script from configuration."""
        if script_id in self._script_map:
            del self._script_map[script_id]
    
    def get_execution_order(self) -> List[str]:
        """Get script IDs in execution order."""
        return [
            script_id for script_id, _ in 
            sorted(self._script_map.items(), key=lambda x: x[1])
        ]
    
class TestScript(BaseModel):
    """
    Represents a test script and its execution state.
    Links to TestResults created during execution (if any).
    """
    def __init__(self, script_path: Path, model_id: Optional[str] = None, name: Optional[str] = None):
        # If no name is provided, default to the stem of the script file.
        if name is None:
            name = script_path.stem

        super().__init__(model_type='TestScript', model_id=model_id, name=name)
        
        self.set_property('script_path', script_path)
        self.set_property('status', 'READY')
        self.set_property('start_time', None)
        self.set_property('elapsed_time', 0)
        self.set_property('progress', 0.0)
        # Now, the 'name' property is automatically set in BaseModel.

    @property
    def script_path(self) -> Path:
        return self.get_property('script_path')
        
    @property
    def status(self) -> str:
        return self.get_property('status')
        
    @status.setter
    def status(self, value: str):
        allowed = ['READY', 'RUNNING', 'COMPLETE', 'ERROR', 'STOPPED', 'PASS', 'FAIL']
        if value not in allowed:
            raise ValueError(f"Invalid status: {value}")
        self.set_property('status', value)
        
    @property
    def start_time(self) -> Optional[datetime]:
        return self.get_property('start_time')
        
    @property
    def elapsed_time(self) -> int:
        return self.get_property('elapsed_time')
        
    @elapsed_time.setter
    def elapsed_time(self, value: int):
        self.set_property('elapsed_time', value)
        
    @property
    def progress(self) -> float:
        return self.get_property('progress')
        
    @progress.setter
    def progress(self, value: float):
        if not 0 <= value <= 100:
            raise ValueError("Progress must be between 0 and 100.")
        self.set_property('progress', value)
        
    @Slot()
    def on_started(self):
        """Handle script start."""
        self.set_property('start_time', datetime.now())
        self.status = 'Running'
        self.progress = 0.0
        logger.info(f"Script {self.name} started.")
        
    @Slot(bool, str)
    def on_finished(self, success: bool, error_msg: str = ""):
        """Handle script completion."""
        if success:
            self.status = 'Complete'
            self.progress = 100.0
        else:
            self.status = 'Error'
            self.set_property('error', error_msg)
        logger.info(f"Script {self.name} finished: {self.status}")

class TestSuite(BaseModel):
    """
    Container for test scripts and their execution configurations.
    Scripts can be added/removed dynamically.
    """
    def __init__(self, model_id: Optional[str] = None, name: Optional[str] = None):
        super().__init__(model_type='TestSuite', model_id=model_id, name=name)
        
        # Initialize with default properties
        self.set_property('status', TestStatus.READY.name)
        self.set_property('failure_behavior', 'stop')  # or 'continue'
        
    def add_script(self, script: TestScript):
        """Add a test script to this suite."""
        self.add_child(script)
        
    def remove_script(self, script_id: str):
        """Remove a script from this suite."""
        if self.state:
            self.state.remove_model(script_id)
            
    def get_scripts(self) -> List[TestScript]:
        """Get all test scripts in this suite."""
        return [
            model for model in self.get_children()
            if isinstance(model, TestScript)
        ]
    
    def get_run_configs(self) -> List[RunConfig]:
        """Get all run configurations."""
        return [
            model for model in self.get_children()
            if isinstance(model, RunConfig)
        ]
    
    def get_default_config(self) -> Optional[RunConfig]:
        """Get default run configuration."""
        for config in self.get_run_configs():
            if config.get_property('is_default', False):
                return config
        return None

class TestGroup(BaseModel):
    """
    A generic container model that can hold child data models.
    Users can add children (plots, measurements, etc.) to organize data.
    """
    def __init__(self, state=None, name="", **kwargs):
        # Generate a unique name if necessary.
        if state:
            name = self._get_unique_name(state, name)
        
        # Pass model_type explicitly and remove it from kwargs if present
        kwargs.pop('model_type', None)
        super().__init__(model_type='TestGroup', state=state, name=name, **kwargs)
        
        logger.debug(f"TestGroup '{self.name}' created with id {self.id}.")

    def _get_unique_name(self, state, base_name: str) -> str:
        """Generate a unique name by appending an incrementing number if needed."""
        existing_groups = state.get_models_by_type(TestGroup)
        existing_names = {group.get_property("name") for group in existing_groups}
        
        if base_name not in existing_names:
            return base_name
            
        counter = 1
        while f"{base_name}_{counter}" in existing_names:
            counter += 1
        return f"{base_name}_{counter}"

    def add(self, child_or_children):
        """
        Add one or more child models to this group.
        If a child is already linked to another parent, it is re-parented here.
        """
        if not isinstance(child_or_children, list):
            child_or_children = [child_or_children]
        for child in child_or_children:
            # If child has another parent, unlink it first.
            if self.state:
                current_parent = self.state.get_parent(child.id)
                if current_parent and current_parent.id != self.id:
                    self.state.unlink_models(current_parent.id, child.id)
            self.add_child(child)


class TestResult(TestGroup):
    """
    A specialized container for test results. Inherits from TestGroup so it
    can contain child models and adds status, timestamps, and error handling.
    """
    def __init__(self, state=None, name="", **kwargs):
        # Remove model_type from kwargs if present
        kwargs.pop('model_type', None)
        super().__init__(state=state, name=name, **kwargs)
        
        # Specify model type as 'TestResult' 
        self.model_type = 'TestResult'
        
        self.set_property("created_time", datetime.now())
        self.set_property("completed_time", None)
        
        logger.debug(f"TestResult '{self.name}' created with id {self.id}.")

    @property
    def progress(self) -> float:
        """Get result progress."""
        return self.get_property('progress', 0.0)
    
    @progress.setter 
    def progress(self, value: float):
        """Set result progress."""
        value = max(0.0, min(100.0, float(value)))
        self.set_property('progress', value)
    
    @property
    def status(self) -> Optional[ResultStatus]:
        """Get result status. Returns None if not reported."""
        status_str = self.get_property('status', None)
        if status_str is None:
            return None
        try:
            return ResultStatus[status_str.upper()]
        except KeyError:
            return None

    @status.setter
    def status(self, value: Optional[ResultStatus]):
        """Set result status. Allow None to indicate not reported."""
        if value is None:
            self.set_property('status', None)
        else:
            if isinstance(value, str):
                value = ResultStatus[value.upper()]
            self.set_property('status', value.name)

    def add(self, child_or_children):
        """
        Add one or more child models to this group.
        If a child is already linked to another parent, it is re-parented here.
        """
        if not isinstance(child_or_children, list):
            child_or_children = [child_or_children]
        for child in child_or_children:
            # # If child has another parent, unlink it first.
            # if self.state:
            #     current_parent = self.state.get_parent(child.id)
            #     if current_parent and current_parent.id != self.id:
            #         self.state.unlink_models(current_parent.id, child.id)
            self.add_child(child)



================================================================================
*** trace.py ***
### src/pymetr/models/trace.py ###
================================================================================

from typing import Optional
import numpy as np
from pymetr.models.base import BaseModel
from pymetr.core.logging import logger

class Trace(BaseModel):
    """
    A single data trace within a plot.

    Properties include:
      - x_data / y_data: Arrays of numeric data
      - name: Display name
      - color: Color of the trace (None => default)
      - style: Line style (e.g., 'solid', 'dash', 'dot', 'dash-dot')
      - width: Line width
      - marker_style: Marker style ('' => none, 'o' => circle, etc.)
      - mode: 'Group' or 'Isolate' (whether trace is on main axis or its own)
      - visible: Whether the trace is drawn
      - opacity: For future dimming/selection (0.0 => invisible, 1.0 => opaque)
    """

    def __init__(
        self,
        x_data: np.ndarray,
        y_data: np.ndarray,
        name: str = "",
        model_id: Optional[str] = None,
        **kwargs
    ):
        super().__init__(model_type='Trace', model_id=model_id)
        # Store data arrays directly (converted to numpy arrays)
        self._x_data = np.asarray(x_data)
        self._y_data = np.asarray(y_data)

        # Basic trace properties
        self.set_property("name", name)
        self.set_property("color", kwargs.get("color", None))  # Let view pick default if None
        self.set_property("style", kwargs.get("style", "solid"))  # 'solid', 'dash', 'dot', 'dash-dot'
        self.set_property("width", kwargs.get("width", 1))
        self.set_property("marker_style", kwargs.get("marker_style", ""))  # e.g. 'o' for circles
        self.set_property("mode", kwargs.get("mode", "Group"))  # or "Isolate"
        self.set_property("visible", kwargs.get("visible", True))
        self.set_property("opacity", kwargs.get("opacity", 1.0))  # 1.0 => fully opaque

    # -- Pythonic Property Accessors --

    @property
    def name(self) -> str:
        return self.get_property("name")

    @name.setter
    def name(self, value: str):
        self.set_property("name", value)

    @property
    def x_data(self) -> np.ndarray:
        return self._x_data

    @property
    def y_data(self) -> np.ndarray:
        return self._y_data

    @property
    def data(self):
        """Return a tuple (x_data, y_data)."""
        return (self._x_data, self._y_data)

    @data.setter
    def data(self, new_data):
        x_data, y_data = new_data
        self._x_data = np.asarray(x_data)
        self._y_data = np.asarray(y_data)
        # Emit a property change event for 'data'
        self.set_property("data", (x_data, y_data))  # Will emit for you

    @property
    def color(self) -> Optional[str]:
        return self.get_property("color")

    @color.setter
    def color(self, value: str):
        self.set_property("color", value)

    @property
    def style(self) -> str:
        return self.get_property("style", "solid")

    @style.setter
    def style(self, value: str):
        self.set_property("style", value)

    @property
    def width(self) -> int:
        return self.get_property("width", 1)

    @width.setter
    def width(self, value: int):
        self.set_property("width", value)

    @property
    def marker_style(self) -> str:
        return self.get_property("marker_style", "")

    @marker_style.setter
    def marker_style(self, value: str):
        self.set_property("marker_style", value)

    @property
    def mode(self) -> str:
        return self.get_property("mode", "Group")

    @mode.setter
    def mode(self, value: str):
        self.set_property("mode", value)

    @property
    def visible(self) -> bool:
        return self.get_property("visible", True)

    @visible.setter
    def visible(self, value: bool):
        self.set_property("visible", value)

    @property
    def opacity(self) -> float:
        return self.get_property("opacity", 1.0)

    @opacity.setter
    def opacity(self, value: float):
        self.set_property("opacity", value)

    def update_data(self, x_data: np.ndarray, y_data: np.ndarray):
        """Update the underlying arrays and emit a property change."""
        x_data = np.asarray(x_data)
        y_data = np.asarray(y_data)
        self._x_data = x_data
        self._y_data = y_data
        self.set_property("data", (x_data, y_data))  # Will emit for you



================================================================================
*** A1 - Simple Plot.py ***
### src/pymetr/scripts/A1 - Simple Plot.py ###
================================================================================

import numpy as np
def run_test(test):
    """
    Minimal test with single plot
    """
    
    # Create a single plot
    plot = test.create_plot("Simple Sine Wave")
    plot.x_label = "Time"
    plot.y_label = "Amplitude"
    plot.show()
    
    # Create x points
    x = np.linspace(0, 10, 100)
    y = np.sin(x)
    plot.set_trace("Sine", x, y, color="#4CAF50")

    return True


================================================================================
*** A2 - Real Time Plot.py ***
### src/pymetr/scripts/A2 - Real Time Plot.py ###
================================================================================

import numpy as np

def run_test(test):
    """
    Frame Rate Test
    Creates a single noise trace and continuously updates it.
    """
    
    # Create plot with basic setup
    plot = test.create_plot("Noise Plot")
    plot.show()
    plot.x_label = "Sample"
    plot.y_label = "Amplitude"
    
    # Generate initial x points
    x_points = np.arange(5000)
    
    # Run for 1000 frames
    for frame in range(1000):
        # Generate new noise data
        y_points = np.random.normal(0, 1, 5000)
        
        # This method can be used to create and/or update traces by name
        plot.set_trace("Noise", x_points, y_points, color="#FF9535")
        
        # Small wait to prevent overwhelming the UI
        test.wait(5)  # 1ms wait
    
    return True


================================================================================
*** A3 - Test Results.py ***
### src/pymetr/scripts/A3 - Test Results.py ###
================================================================================

import numpy as np

def run_test(test):
    """
    Simple test creating a plot that's shown both directly and in a result view.
    """

    # Now create a test result object with a name
    result = test.create_result("Test Result")

    # Create a plot with a name
    plot = test.create_plot("Test Plot")

    # Add the plot to this test result
    result.add(plot)

    # Tell the UI to show the result.
    result.show()

    # Create some test data
    x = np.linspace(0, 10, 100)
    y1 = np.sin(x)
    y2 = np.cos(x)
    
    # Use the set_trace method to create and/or update plot traces
    plot.set_trace("Sine", x, y1, color="#FF0000")
    plot.set_trace("Cosine", x, y2, color="#00FF00")
    
    # Set the result status to 'PASS' or 'FAIL'
    result.status = "PASS"

    # Returning False from the test script would flag the test with an error.
    return True


================================================================================
*** A4 - Multiple Plots.py ***
### src/pymetr/scripts/A4 - Multiple Plots.py ###
================================================================================

import numpy as np
def run_test(test):
    """
    Test script to analyze model linking behavior.
    Creates a hierarchy of models and monitors registration/linking.
    """
    # Create a result for our test
    result = test.create_result("Model Link Analysis")
    
    # Create a few plots in sequence
    plot1 = test.create_plot("Plot 1")
    plot2 = test.create_plot("Plot 2")
    
    # Add some traces to the plots
    x = np.linspace(0, 10, 100)

    # Set the trace on plot1
    y1 = np.sin(x)
    plot1.set_trace("Sine", x, y1)
    
    # Create another trace on plot2
    y2 = np.cos(x)
    plot2.set_trace("Cosine", x, y2)
    
    # Add both plots to the same result
    result.add(plot1)
    result.add(plot2)

    # Tell the UI you want to see this right away
    result.show()

    # Return a status for the result
    result.status = "PASS"

    # Return True if the script finished successfully
    return True


================================================================================
*** A5 - Multiple Results.py ***
### src/pymetr/scripts/A5 - Multiple Results.py ###
================================================================================

import numpy as np

def run_test(test):
    """
    A more in-depth test demonstrating:
      - Two separate Result containers
      - Multiple plots in the first Result
      - Multiple traces per plot
      - A single plot + a table in the second Result
      - Animated data updates and progress changes
    """

    # -------------------------
    # 1) FIRST RESULT: 2 PLOTS
    # -------------------------
    result1 = test.create_result("First Result")
    result1.show()

    # -- Plot A --
    plotA = test.create_plot("Plot A")
    plotA.x_label = "Time (s)"
    plotA.y_label = "Voltage (V)"
    plotA.title = "Plot A (Sine/Cosine)"
    result1.add(plotA)

    # -- Plot B --
    plotB = test.create_plot("Plot B")
    plotB.x_label = "Time (s)"
    plotB.y_label = "Amplitude"
    plotB.title = "Plot B (Random Data)"
    result1.add(plotB)

    # We'll animate each plot for 50 frames
    x = np.linspace(0, 10, 1000)

    for frame in range(50):
        # --- Plot A: Sine & Cosine ---
        phase = frame * 0.2
        y_sine = np.sin(x + phase)
        y_cosine = np.cos(x + phase)

        plotA.set_trace("Sine A", x, y_sine, color="#FF0000")   # Red
        plotA.set_trace("Cosine A", x, y_cosine, color="#00FF00")  # Green

        # --- Plot B: Random data ---
        y_rand1 = np.random.normal(0, 0.1, len(x)) + (frame * 0.01)
        y_rand2 = np.random.normal(0, 0.1, len(x)) - (frame * 0.01)

        plotB.set_trace("Random1 B", x, y_rand1, color="#0000FF")   # Blue
        plotB.set_trace("Random2 B", x, y_rand2, color="#FFA500")   # Orange

        # Update progress for the first result
        pct = int((frame / 49) * 50)  # e.g. goes from 0 to ~50
        result1.progress = pct

        # Wait a bit to see updates
        test.wait(20)

    # Final status for result #1
    result1.progress = 100
    result1.status = "PASS"

    # ----------------------------------
    # 2) SECOND RESULT: 1 PLOT + 1 TABLE
    # ----------------------------------
    result2 = test.create_result("Second Result")
    result2.show()

    # -- Single Plot C --
    plotC = test.create_plot("Plot C")
    plotC.x_label = "Sample"
    plotC.y_label = "Value"
    plotC.title = "Plot C (Random Sine)"
    result2.add(plotC)

    # -- One Table --
    table = test.create_table("Data Table")
    table.columns = ["Index", "Random A", "Random B"]
    result2.add(table)

    x2 = np.arange(1000)
    for frame in range(50):
        # Generate random sine data
        y_sine_rand = np.sin((x2 * 0.05) + frame * 0.2) + np.random.normal(0, 0.1, len(x2))

        plotC.set_trace("Random Sine C", x2, y_sine_rand, color="#4CAF50")

        # Insert a row in the table
        row = [
            f"{frame}",
            f"{np.random.uniform(0, 1):.3f}",
            f"{np.random.uniform(0, 1):.3f}"
        ]
        table.add_row(row)

        # Update progress for the second result
        pct = int((frame / 49) * 100)
        result2.progress = pct

        test.wait(20)

    result2.progress = 100
    result2.status = "PASS"

    return True



================================================================================
*** A6 - Advanced.py ***
### src/pymetr/scripts/A6 - Advanced.py ###
================================================================================

import numpy as np

def run_test(test):
    """
    Enhanced Plot Animation Test with evolving mathematical patterns.
    
    This test creates two resultseach with one plot and one analysis table.
    Each result is updated over four sections (each ~5 seconds long), showing
    real-time plot updates and table updates. The first result finishes as PASS,
    while the second is marked as FAIL.
    
    Color scheme for traces:
      - "#02FEE4"
      - "#4BFF36"
      - "#FF9535"
      - "#F23CA6"
      - "#5E57FF"
    """
    colors = ["#02FEE4", "#4BFF36", "#FF9535", "#F23CA6", "#5E57FF"]
    x_points = np.linspace(0, 10, 1000)
    frames_per_section = 150  # Approximately 5 seconds if wait time is 30 ms
    
    # --- Helper Pattern Functions ---
    def harmonic_pattern(idx, frame, x):
        harmonic = idx + 1
        amplitude = 1.0 / harmonic
        phase = frame * 0.02 * harmonic
        y = amplitude * np.sin(harmonic * x + phase)
        return y * np.exp(-0.1 * x)
    
    def interference_pattern(idx, frame, x):
        freq1 = 1 + idx * 0.5
        freq2 = 2 + idx * 0.3
        y = np.sin(freq1 * x + frame * 0.05) + np.sin(freq2 * x - frame * 0.03)
        return y * np.cos(0.5 * x + frame * 0.02)
    
    def lissajous_pattern(idx, frame, x):
        t = frame * 0.02
        freq = 1 + idx * 0.2
        y = np.sin(freq * x + t) * np.cos((idx + 1) * x - t)
        envelope = 1 - 0.5 * np.cos(0.2 * x)
        return y * envelope
    
    def convergence_pattern(idx, frame, x):
        convergence = frame / frames_per_section
        base_freq = 2 + idx * 0.5
        phase = frame * 0.03
        complex_pattern = np.sin(base_freq * x + phase) * np.cos((5-idx) * x - phase)
        simple_pattern = np.sin(base_freq * x + phase)
        y = (1 - convergence) * complex_pattern + convergence * simple_pattern
        return y * (1 + 0.5 * np.sin(0.1 * x + phase))
    
    # --- Create and update Result 1 (expected PASS) ---
    result1 = test.create_result("Evolving Plot Test - Result 1")
    result1.show()
    
    plot1 = test.create_plot("Symphony 1")
    plot1.x_label = "Time (s)"
    plot1.y_label = "Amplitude"
    plot1.title = "Symphony 1"
    plot1.x_unit = "s"
    plot1.y_unit = "A.U."
    plot1.grid_enabled = True
    plot1.legend_enabled = True
    plot1.roi_visible = True
    result1.add(plot1)
    
    table1 = test.create_table("Analysis 1")
    table1.columns = ["Section", "Pattern Type", "Max Amplitude", "Frequency"]
    result1.add(table1)
    
    # Initialize traces in plot1
    for idx, col in enumerate(colors):
        plot1.set_trace(f"Trace{idx+1}", x_points, np.zeros_like(x_points), color=col)
    
    result1.progress = 0
    
    # Section 1: Harmonic Series Evolution
    for frame in range(frames_per_section):
        progress = frame / frames_per_section
        for idx, col in enumerate(colors):
            y = harmonic_pattern(idx, frame, x_points)
            plot1.set_trace(f"Trace{idx+1}", x_points, y, color=col)
        test.wait(30)
        result1.progress = int(progress * 25)
    table1.add_row(["Section 1", "Harmonic Series", "1.0", "1-5 Hz"])
    
    # Section 2: Interference Patterns
    for frame in range(frames_per_section):
        progress = frame / frames_per_section
        for idx, col in enumerate(colors):
            y = interference_pattern(idx, frame, x_points)
            plot1.set_trace(f"Trace{idx+1}", x_points, y, color=col)
        test.wait(30)
        result1.progress = 25 + int(progress * 25)
    table1.add_row(["Section 2", "Interference", "2.0", "1.5-3.5 Hz"])
    
    # Section 3: Lissajous-inspired Patterns
    for frame in range(frames_per_section):
        progress = frame / frames_per_section
        for idx, col in enumerate(colors):
            y = lissajous_pattern(idx, frame, x_points)
            plot1.set_trace(f"Trace{idx+1}", x_points, y, color=col)
        test.wait(30)
        result1.progress = 50 + int(progress * 25)
    table1.add_row(["Section 3", "Lissajous", "1.0", "1.2-2.0 Hz"])
    
    # Section 4: Final Convergence
    for frame in range(frames_per_section):
        progress = frame / frames_per_section
        for idx, col in enumerate(colors):
            y = convergence_pattern(idx, frame, x_points)
            plot1.set_trace(f"Trace{idx+1}", x_points, y, color=col)
        test.wait(30)
        result1.progress = 75 + int(progress * 25)
    table1.add_row(["Section 4", "Convergence", "1.5", "2.0-4.5 Hz"])
    
    result1.progress = 100
    result1.status = "PASS"
    
    # --- Create and update Result 2 (expected FAIL) ---
    result2 = test.create_result("Evolving Plot Test - Result 2")
    result2.show()
    
    plot2 = test.create_plot("Symphony 2")
    plot2.x_label = "Time (s)"
    plot2.y_label = "Amplitude"
    plot2.title = "Symphony 2"
    plot2.x_unit = "s"
    plot2.y_unit = "A.U."
    plot2.grid_enabled = True
    plot2.legend_enabled = True
    plot2.roi_visible = True
    result2.add(plot2)
    
    table2 = test.create_table("Analysis 2")
    table2.columns = ["Section", "Pattern Type", "Max Amplitude", "Frequency"]
    result2.add(table2)
    
    # Initialize traces in plot2
    for idx, col in enumerate(colors):
        plot2.set_trace(f"Trace{idx+1}", x_points, np.zeros_like(x_points), color=col)
    
    result2.progress = 0
    
    # Section 1: Harmonic Series Evolution
    for frame in range(frames_per_section):
        progress = frame / frames_per_section
        for idx, col in enumerate(colors):
            y = harmonic_pattern(idx, frame, x_points)
            plot2.set_trace(f"Trace{idx+1}", x_points, y, color=col)
        test.wait(30)
        result2.progress = int(progress * 25)
    table2.add_row(["Section 1", "Harmonic Series", "1.0", "1-5 Hz"])
    
    # Section 2: Interference Patterns
    for frame in range(frames_per_section):
        progress = frame / frames_per_section
        for idx, col in enumerate(colors):
            y = interference_pattern(idx, frame, x_points)
            plot2.set_trace(f"Trace{idx+1}", x_points, y, color=col)
        test.wait(30)
        result2.progress = 25 + int(progress * 25)
    table2.add_row(["Section 2", "Interference", "2.0", "1.5-3.5 Hz"])
    
    # Section 3: Lissajous-inspired Patterns
    for frame in range(frames_per_section):
        progress = frame / frames_per_section
        for idx, col in enumerate(colors):
            y = lissajous_pattern(idx, frame, x_points)
            plot2.set_trace(f"Trace{idx+1}", x_points, y, color=col)
        test.wait(30)
        result2.progress = 50 + int(progress * 25)
    table2.add_row(["Section 3", "Lissajous", "1.0", "1.2-2.0 Hz"])
    
    # Section 4: Final Convergence (simulate failure by slightly distorting the pattern)
    for frame in range(frames_per_section):
        progress = frame / frames_per_section
        for idx, col in enumerate(colors):
            t = frame * 0.02
            base_freq = 2 + idx * 0.5
            # Introduce a phase error to simulate a failure.
            phase = frame * 0.05  
            complex_pattern = np.sin(base_freq * x_points + phase) * np.cos((5-idx) * x_points - phase)
            simple_pattern = np.sin(base_freq * x_points + phase)
            y = 0.5 * complex_pattern + 0.5 * simple_pattern
            plot2.set_trace(f"Trace{idx+1}", x_points, y, color=col)
        test.wait(30)
        result2.progress = 75 + int(progress * 25)
    table2.add_row(["Section 4", "Convergence", "1.5", "2.0-4.5 Hz"])
    
    result2.progress = 100
    result2.status = "PASS"
    
    return True



================================================================================
*** Frame_Rate_Plus.py ***
### src/pymetr/scripts/bak/Frame_Rate_Plus.py ###
================================================================================

import numpy as np

def run_test(test):
    """
    Frame Rate Test
    Creates a single noise trace with a marker at peak and cursor at minimum.
    """
    # Create plot with basic setup
    plot = test.create_plot("Noise Plot")
    plot.show()
    plot.x_label = "Sample"
    plot.y_label = "Amplitude"

    # Generate initial x points
    x_points = np.arange(5000)

    # Initial setup for marker and cursor
    plot.set_marker("Peak", x=0, y=0, color="#FF0000")  # Red marker

    # Run for 1000 frames
    for frame in range(1000):
        # Generate new noise data
        y_points = np.random.normal(0, 1, 5000)
        
        # Find max and min positions
        max_idx = np.argmax(y_points)
        min_idx = np.argmin(y_points)
        
        # Update the trace
        plot.set_trace("Noise", x_points, y_points, color="#FF9535")
        
        # Update marker to peak
        plot.set_marker("Peak", x=float(x_points[max_idx]), y=float(y_points[max_idx]))

        # Small wait to prevent overwhelming the UI
        test.wait(10)  # 1ms wait

    return True


================================================================================
*** Simple_Context_2.py ***
### src/pymetr/scripts/bak/Simple_Context_2.py ###
================================================================================

import numpy as np

def run_test(test):
    """
    Test that creates two results. The first result loops and finishes as PASS,
    and the second loops and finishes as FAIL. The overall test script status should
    aggregate to FAIL.
    """
    # --- First Result: Expected to PASS ---
    result1 = test.create_result("Sine Wave Test 1")
    result1.show()
    
    # Create a plot for the first result.
    plot1 = test.create_plot("Sine Wave 1")
    plot1.x_label = "Time"
    plot1.y_label = "Amplitude"
    result1.add(plot1)
    
    # Create x points.
    x = np.linspace(0, 10, 5000)
    
    # Update loop for first result.
    for i in range(50):
        y = np.sin(x + i)
        plot1.set_trace("Sine", x, y, color="#4CAF50")
        test.wait(10)  # 10 ms between updates
        result1.progress = (i + 1) * 2  # progress goes from 2 to 100%
    result1.progress = 100
    result1.status = "PASS"
    
    # --- Second Result: Expected to FAIL ---
    result2 = test.create_result("Sine Wave Test 2")
    result2.show()
    
    # Create a plot for the second result.
    plot2 = test.create_plot("Sine Wave 2")
    plot2.x_label = "Time"
    plot2.y_label = "Amplitude"
    result2.add(plot2)
    
    # Update loop for second result.
    for i in range(50):
        y = np.sin(x - i)
        plot2.set_trace("Sine", x, y, color="#F44336")
        test.wait(10)  # 10 ms between updates
        result2.progress = (i + 1) * 2  # progress goes from 2 to 100%
    result2.progress = 100
    result2.status = "FAIL"
    
    # Overall, if any child result fails, the test script should be marked as FAIL.
    # Returning False indicates the test script did not fully pass.
    return True



================================================================================
*** Simple_Context_3.py ***
### src/pymetr/scripts/bak/Simple_Context_3.py ###
================================================================================

import numpy as np

def run_test(test):
    """
    Enhanced Plot Animation Test with evolving mathematical patterns.
    
    This test creates two resultseach with one plot and one analysis table.
    Each result is updated over four sections (each ~5 seconds long), showing
    real-time plot updates and table updates. The first result finishes as PASS,
    while the second is marked as FAIL.
    
    Color scheme for traces:
      - "#02FEE4"
      - "#4BFF36"
      - "#FF9535"
      - "#F23CA6"
      - "#5E57FF"
    """
    colors = ["#02FEE4", "#4BFF36", "#FF9535", "#F23CA6", "#5E57FF"]
    x_points = np.linspace(0, 10, 1000)
    frames_per_section = 150  # Approximately 5 seconds if wait time is 30 ms
    
    # --- Helper Pattern Functions ---
    def harmonic_pattern(idx, frame, x):
        harmonic = idx + 1
        amplitude = 1.0 / harmonic
        phase = frame * 0.02 * harmonic
        y = amplitude * np.sin(harmonic * x + phase)
        return y * np.exp(-0.1 * x)
    
    def interference_pattern(idx, frame, x):
        freq1 = 1 + idx * 0.5
        freq2 = 2 + idx * 0.3
        y = np.sin(freq1 * x + frame * 0.05) + np.sin(freq2 * x - frame * 0.03)
        return y * np.cos(0.5 * x + frame * 0.02)
    
    def lissajous_pattern(idx, frame, x):
        t = frame * 0.02
        freq = 1 + idx * 0.2
        y = np.sin(freq * x + t) * np.cos((idx + 1) * x - t)
        envelope = 1 - 0.5 * np.cos(0.2 * x)
        return y * envelope
    
    def convergence_pattern(idx, frame, x):
        convergence = frame / frames_per_section
        base_freq = 2 + idx * 0.5
        phase = frame * 0.03
        complex_pattern = np.sin(base_freq * x + phase) * np.cos((5-idx) * x - phase)
        simple_pattern = np.sin(base_freq * x + phase)
        y = (1 - convergence) * complex_pattern + convergence * simple_pattern
        return y * (1 + 0.5 * np.sin(0.1 * x + phase))
    
    # --- Create and update Result 1 (expected PASS) ---
    result1 = test.create_result("Evolving Plot Test - Result 1")
    result1.show()
    
    plot1 = test.create_plot("Symphony 1")
    plot1.x_label = "Time (s)"
    plot1.y_label = "Amplitude"
    plot1.title = "Symphony 1"
    plot1.x_unit = "s"
    plot1.y_unit = "A.U."
    plot1.grid_enabled = True
    plot1.legend_enabled = True
    plot1.roi_visible = True
    result1.add(plot1)
    
    table1 = test.create_table("Analysis 1")
    table1.columns = ["Section", "Pattern Type", "Max Amplitude", "Frequency"]
    result1.add(table1)
    
    # Initialize traces in plot1
    for idx, col in enumerate(colors):
        plot1.set_trace(f"Trace{idx+1}", x_points, np.zeros_like(x_points), color=col)
    
    result1.progress = 0
    
    # Section 1: Harmonic Series Evolution
    for frame in range(frames_per_section):
        progress = frame / frames_per_section
        for idx, col in enumerate(colors):
            y = harmonic_pattern(idx, frame, x_points)
            plot1.set_trace(f"Trace{idx+1}", x_points, y, color=col)
        test.wait(30)
        result1.progress = int(progress * 25)
    table1.add_row(["Section 1", "Harmonic Series", "1.0", "1-5 Hz"])
    
    # Section 2: Interference Patterns
    for frame in range(frames_per_section):
        progress = frame / frames_per_section
        for idx, col in enumerate(colors):
            y = interference_pattern(idx, frame, x_points)
            plot1.set_trace(f"Trace{idx+1}", x_points, y, color=col)
        test.wait(30)
        result1.progress = 25 + int(progress * 25)
    table1.add_row(["Section 2", "Interference", "2.0", "1.5-3.5 Hz"])
    
    # Section 3: Lissajous-inspired Patterns
    for frame in range(frames_per_section):
        progress = frame / frames_per_section
        for idx, col in enumerate(colors):
            y = lissajous_pattern(idx, frame, x_points)
            plot1.set_trace(f"Trace{idx+1}", x_points, y, color=col)
        test.wait(30)
        result1.progress = 50 + int(progress * 25)
    table1.add_row(["Section 3", "Lissajous", "1.0", "1.2-2.0 Hz"])
    
    # Section 4: Final Convergence
    for frame in range(frames_per_section):
        progress = frame / frames_per_section
        for idx, col in enumerate(colors):
            y = convergence_pattern(idx, frame, x_points)
            plot1.set_trace(f"Trace{idx+1}", x_points, y, color=col)
        test.wait(30)
        result1.progress = 75 + int(progress * 25)
    table1.add_row(["Section 4", "Convergence", "1.5", "2.0-4.5 Hz"])
    
    result1.progress = 100
    result1.status = "PASS"
    
    # --- Create and update Result 2 (expected FAIL) ---
    result2 = test.create_result("Evolving Plot Test - Result 2")
    result2.show()
    
    plot2 = test.create_plot("Symphony 2")
    plot2.x_label = "Time (s)"
    plot2.y_label = "Amplitude"
    plot2.title = "Symphony 2"
    plot2.x_unit = "s"
    plot2.y_unit = "A.U."
    plot2.grid_enabled = True
    plot2.legend_enabled = True
    plot2.roi_visible = True
    result2.add(plot2)
    
    table2 = test.create_table("Analysis 2")
    table2.columns = ["Section", "Pattern Type", "Max Amplitude", "Frequency"]
    result2.add(table2)
    
    # Initialize traces in plot2
    for idx, col in enumerate(colors):
        plot2.set_trace(f"Trace{idx+1}", x_points, np.zeros_like(x_points), color=col)
    
    result2.progress = 0
    
    # Section 1: Harmonic Series Evolution
    for frame in range(frames_per_section):
        progress = frame / frames_per_section
        for idx, col in enumerate(colors):
            y = harmonic_pattern(idx, frame, x_points)
            plot2.set_trace(f"Trace{idx+1}", x_points, y, color=col)
        test.wait(30)
        result2.progress = int(progress * 25)
    table2.add_row(["Section 1", "Harmonic Series", "1.0", "1-5 Hz"])
    
    # Section 2: Interference Patterns
    for frame in range(frames_per_section):
        progress = frame / frames_per_section
        for idx, col in enumerate(colors):
            y = interference_pattern(idx, frame, x_points)
            plot2.set_trace(f"Trace{idx+1}", x_points, y, color=col)
        test.wait(30)
        result2.progress = 25 + int(progress * 25)
    table2.add_row(["Section 2", "Interference", "2.0", "1.5-3.5 Hz"])
    
    # Section 3: Lissajous-inspired Patterns
    for frame in range(frames_per_section):
        progress = frame / frames_per_section
        for idx, col in enumerate(colors):
            y = lissajous_pattern(idx, frame, x_points)
            plot2.set_trace(f"Trace{idx+1}", x_points, y, color=col)
        test.wait(30)
        result2.progress = 50 + int(progress * 25)
    table2.add_row(["Section 3", "Lissajous", "1.0", "1.2-2.0 Hz"])
    
    # Section 4: Final Convergence (simulate failure by slightly distorting the pattern)
    for frame in range(frames_per_section):
        progress = frame / frames_per_section
        for idx, col in enumerate(colors):
            t = frame * 0.02
            base_freq = 2 + idx * 0.5
            # Introduce a phase error to simulate a failure.
            phase = frame * 0.05  
            complex_pattern = np.sin(base_freq * x_points + phase) * np.cos((5-idx) * x_points - phase)
            simple_pattern = np.sin(base_freq * x_points + phase)
            y = 0.5 * complex_pattern + 0.5 * simple_pattern
            plot2.set_trace(f"Trace{idx+1}", x_points, y, color=col)
        test.wait(30)
        result2.progress = 75 + int(progress * 25)
    table2.add_row(["Section 4", "Convergence", "1.5", "2.0-4.5 Hz"])
    
    result2.progress = 100
    result2.status = "PASS"
    
    return True



================================================================================
*** context_test.py ***
### src/pymetr/scripts/bak/context_test.py ###
================================================================================

import numpy as np

def run_test(test):
    """
    Comprehensive Plot and Animation Test
    Combines static elements with dynamic trace animation, markers (using names),
    cursors, and a table with analysis data.
    """
    # Create a result container and show it
    result = test.create_result("Test Result")
    result.show()

    # Create a plot and add it to the result
    plot = test.create_plot("Test Plot")
    plot.x_label = "Time (s)"
    plot.y_label = "Voltage (V)"
    result.add(plot)
    
    # Set basic plot properties
    plot.title = "Test Plot"
    plot.x_unit = "s"
    plot.y_unit = "V"
    plot.grid_enabled = True
    plot.legend_enabled = True
    
    
    # Create a table with 10 rows of analysis data and add it to the result
    table = test.create_table("Test Data Table")
    result.add(table)
    table.columns = ["Index", "Value1", "Value2", "Value3"]
    
    # Animate 5 traces on the plot with the specified colors
    colors = ["#02FEE4", "#4BFF36", "#FF9535", "#F23CA6", "#5E57FF"]
    x_points = np.linspace(0, 10, 1000)
    
    # Initialize traces for each color
    for idx, col in enumerate(colors):
        plot.set_trace(f"Test Trace{idx+1}", x_points, np.zeros_like(x_points), color=col)
    
    # Animate for 500 frames
    for frame in range(200):
        for idx, col in enumerate(colors):
            phase = frame * 0.1
            # Generate sine data with a phase shift and small noise
            y_data = np.sin(x_points + phase + idx) + np.random.normal(0, 0.05, len(x_points))
            plot.set_trace(f"Test Trace{idx+1}", x_points, y_data, color=col)

        # Generate example random data for each row
        row = [frame, f"{np.random.uniform(0,1):.2f}",
                  f"{np.random.uniform(0,1):.2f}",
                  f"{np.random.uniform(0,1):.2f}"]
        table.add_row(row)
        result.progress = int((frame+1)/200)*100
        test.wait(20)  

    
    # Final progress update and set test status
    result.progress = 100
    result.status = "PASS"
    return True



================================================================================
*** context_test_complete.py ***
### src/pymetr/scripts/bak/context_test_complete.py ###
================================================================================

import numpy as np

def run_test(test):
    """
    Demonstrates two results with just a few key updates.
    """
    # ---- First Result: Two Plots ----
    result1 = test.create_result("First Result")
    result1.show()

    # Setup plots
    plotA = test.create_plot("Plot A")
    plotA.x_label, plotA.y_label = "Time (s)", "Voltage (V)"
    plotA.title = "Plot A: Sine & Cosine with Marker"
    
    plotB = test.create_plot("Plot B")
    plotB.x_label, plotB.y_label = "Time (s)", "Amplitude"
    plotB.title = "Plot B: Random Data with Cursor"
    
    result1.add(plotA)
    result1.add(plotB)

    x = np.linspace(0, 10, 1000)
    
    # Initial state
    plotA.set_trace("Sine A", x, np.sin(x), color="#FF0000")
    plotA.set_trace("Cosine A", x, np.cos(x), color="#00FF00")
    plotA.set_marker("Marker A", x=5.0, y=0.0)
    
    plotB.set_trace("Random 1 B", x, np.random.normal(0, 0.1, len(x)), color="#0000FF")
    plotB.set_trace("Random 2 B", x, np.random.normal(0, 0.1, len(x)), color="#FFA500")
    plotB.set_cursor("Cursor B", position=2.0, axis="x", color="#00FFFF")
    
    result1.progress = 50
    test.wait(500)

    # Final state
    plotA.set_trace("Sine A", x, np.sin(x + np.pi), color="#FF0000")
    plotA.set_trace("Cosine A", x, np.cos(x + np.pi), color="#00FF00")
    plotA.set_marker("Marker A", x=5.0, y=0.5)
    
    plotB.set_trace("Random 1 B", x, np.random.normal(0.5, 0.1, len(x)), color="#0000FF")
    plotB.set_trace("Random 2 B", x, np.random.normal(-0.5, 0.1, len(x)), color="#FFA500")
    plotB.set_cursor("Cursor B", position=4.0)
    
    result1.progress = 100
    result1.status = "PASS"

    # ---- Second Result: Plot and Table ----
    result2 = test.create_result("Second Result")
    result2.show()

    plotC = test.create_plot("Plot C")
    plotC.x_label, plotC.y_label = "Sample", "Value"
    plotC.title = "Plot C: Random Sine"
    
    table = test.create_table("Data Table")
    table.columns = ["Index", "Value 1", "Value 2", "Value 3"]
    
    result2.add(plotC)
    result2.add(table)

    # Initial state
    x2 = np.arange(1000)
    plotC.set_trace("Random Sine C", x2, np.sin(x2 * 0.05), color="#4CAF50")
    
    # Add just a few rows
    for i in range(3):
        table.add_row([str(i)] + [f"{np.random.uniform(0,1):.3f}" for _ in range(3)])
    
    result2.progress = 50
    test.wait(500)

    # Final state
    plotC.set_trace("Random Sine C", x2, np.sin(x2 * 0.05 + np.pi) + np.random.normal(0, 0.1, len(x2)), color="#4CAF50")
    for i in range(3):
        table.add_row([str(i+3)] + [f"{np.random.uniform(0,1):.3f}" for _ in range(3)])
    
    result2.progress = 100
    result2.status = "PASS"
    
    return True


================================================================================
*** celestial.py ***
### src/pymetr/scripts/fun/celestial.py ###
================================================================================

import numpy as np

def run_test(test):
    """
    Celestial Dance
    An intricate animation of celestial bodies dancing through space,
    incorporating orbital mechanics and golden ratio harmonies.
    """
    # Create and configure the result container
    result = test.create_result("Celestial Dance")
    plot = test.create_plot("Celestial Dance")
    plot.x_label = "Space (AU)"
    plot.y_label = "Space (AU)"
    plot.xlim = (-5, 5)
    plot.ylim = (-5, 5)

    result.add(plot)
    
    # Create analysis table with celestial themes
    table = test.create_table("Celestial Analysis")
    table.columns = ["Celestial Phase", "Mathematical Theme", "Cosmic Energy", "Complexity"]
    
    # Add initial phase
    table.add_row([
        "Solar Birth",
        "Golden Spiral Genesis",
        "Primordial Creation",
        "Emerging"
    ])
    
    result.show()
    
    # Celestial color scheme
    colors = ["#02FEE4", "#4BFF36", "#FF9535", "#F23CA6", "#5E57FF"]
    points = 1000
    golden_ratio = (1 + np.sqrt(5)) / 2
    
    # Initialize traces
    for idx, color in enumerate(colors):
        plot.set_trace(f"Celestial{idx+1}", np.zeros(points), np.zeros(points), color=color)
    
    def create_spiral_orbit(t, base_radius, frequency, phase, evolution):
        """Generate evolving spiral patterns with orbital mechanics"""
        angle = np.linspace(0, t * 2 * np.pi, points)
        radius = base_radius * (1 + 0.3 * np.sin(frequency * angle + phase))
        spiral = 0.1 * angle * np.exp(evolution * np.cos(angle / golden_ratio))
        return radius * spiral
        
    def create_planetary_orbit(t, a, e, phase):
        """Generate elliptical orbit using orbital mechanics"""
        theta = np.linspace(0, 2 * np.pi, points)
        r = a * (1 - e**2) / (1 + e * np.cos(theta + phase))
        return r
        
    total_frames = 1200
    for frame in range(total_frames):
        t = frame * 0.02
        progress = frame / total_frames
        
        # Add new phases to the table at key moments
        if frame == 250:
            table.add_row([
                "Orbital Harmony",
                "Kepler's Waltz",
                "Gravitational Dance",
                "Resonant"
            ])
        elif frame == 500:
            table.add_row([
                "Galactic Spin",
                "Spiral Arm Evolution",
                "Cosmic Rotation",
                "Dynamic"
            ])
        elif frame == 750:
            table.add_row([
                "Nebula Weaving",
                "Quantum Harmonics",
                "Stellar Winds",
                "Complex"
            ])
        elif frame == 1000:
            table.add_row([
                "Cosmic Unity",
                "Universal Harmony",
                "Transcendent Flow",
                "Infinite"
            ])
        
        # Phase transitions
        phase1 = np.clip(frame / 250, 0, 1)
        phase2 = np.clip((frame - 250) / 250, 0, 1)
        phase3 = np.clip((frame - 500) / 250, 0, 1)
        phase4 = np.clip((frame - 750) / 250, 0, 1)
        phase5 = np.clip((frame - 1000) / 200, 0, 1)
        
        for idx, color in enumerate(colors):
            # Base parameters unique to each celestial body
            body_phase = idx * 2 * np.pi / len(colors)
            frequency = 1 + idx * 0.5
            
            # Time-varying parameters
            theta = np.linspace(0, 2 * np.pi * (idx + 1), points)
            evolution = 0.1 + 0.05 * np.sin(t * frequency)
            
            # Phase 1: Spiral Genesis
            spiral = create_spiral_orbit(t, 1 + 0.2 * idx, frequency, body_phase, evolution)
            x1 = spiral * np.cos(theta + t)
            y1 = spiral * np.sin(theta + t)
            
            # Phase 2: Orbital Harmony
            orbit = create_planetary_orbit(t, 2 + 0.5 * idx, 0.3, body_phase)
            x2 = orbit * np.cos(theta + t * frequency)
            y2 = orbit * np.sin(theta + t * frequency)
            
            # Phase 3: Galactic Spin
            r3 = (3 + idx * 0.5) * np.exp(-0.1 * theta)
            x3 = r3 * np.cos(theta + t + body_phase)
            y3 = r3 * np.sin(theta + t + body_phase)
            
            # Phase 4: Nebula Weaving
            r4 = 2 + np.sin(3 * theta + t + body_phase)
            x4 = r4 * np.cos(theta * golden_ratio + t)
            y4 = r4 * np.sin(theta * golden_ratio + t)
            
            # Phase 5: Cosmic Unity
            r5 = 3 * np.sin(theta * frequency + t)
            x5 = r5 * np.cos(theta * golden_ratio + t + body_phase)
            y5 = r5 * np.sin(theta * golden_ratio + t + body_phase)
            
            # Blend all phases smoothly
            x = x1 * (1 - phase2) + x2 * phase2 * (1 - phase3) + \
                x3 * phase3 * (1 - phase4) + x4 * phase4 * (1 - phase5) + x5 * phase5
            y = y1 * (1 - phase2) + y2 * phase2 * (1 - phase3) + \
                y3 * phase3 * (1 - phase4) + y4 * phase4 * (1 - phase5) + y5 * phase5
            
            # Add harmonic modulation
            modulation = 1 + 0.2 * np.sin(5 * theta + t * frequency)
            x *= modulation
            y *= modulation
            
            # Update trace
            plot.set_trace(f"Celestial{idx+1}", x, y, color=color)
        
        test.wait(20)
        result.progress = int((frame + 1) / total_frames * 100)
    
    result.status = "PASS"
    return True


================================================================================
*** evolution.py ***
### src/pymetr/scripts/fun/evolution.py ###
================================================================================

import numpy as np

def run_test(test):
    """
    Enhanced Plot Animation Test with continuously evolving mathematical patterns
    Features smooth transitions between sections and progressive table updates
    """
    # Create a result container and show it
    result = test.create_result("Continuous Evolution")

   
    # Create a plot and add it to the result
    plot = test.create_plot("Mathematical Symphony")
    plot.x_label = "Time (s)"
    plot.y_label = "Amplitude"
    plot.ylim = (-3, 3)
    result.add(plot)

    # Create analysis table with poetic descriptions
    table = test.create_table("Pattern Symphony Analysis")
    result.add(table)
    result.show()

    # Initialize table with headers
    table.columns = ["Movement", "Mathematical Theme", "Emotional Quality", "Peak Complexity"]

    # Define our color scheme
    colors = ["#02FEE4", "#4BFF36", "#FF9535", "#F23CA6", "#5E57FF"]
    x_points = np.linspace(0, 10, 1000)

    # Initialize traces
    for idx, col in enumerate(colors):
        plot.set_trace(f"Voice{idx+1}", x_points, np.zeros_like(x_points), color=col)

    def transition_weight(frame, start_frame, end_frame):
        """Smooth transition function using cosine"""
        if frame < start_frame:
            return 0.0
        if frame > end_frame:
            return 1.0
        progress = (frame - start_frame) / (end_frame - start_frame)
        return 0.5 * (1 - np.cos(np.pi * progress))

    # Animation loop with continuous transitions
    total_frames = 1500  # Extended for more elaborate patterns
    
    # Add first movement to table immediately
    table.add_row([
        "Opening Movement",
        "Harmonic Series with Exponential Decay",
        "Awakening, Emergence",
        "Medium"
    ])

    for frame in range(total_frames):
        # Calculate various transition weights
        w1 = transition_weight(frame, 0, 350)
        w2 = transition_weight(frame, 250, 600)
        w3 = transition_weight(frame, 500, 850)
        w4 = transition_weight(frame, 750, 1100)
        w5 = transition_weight(frame, 1000, total_frames)

        # Add table rows at transition points
        if frame == 250:
            table.add_row([
                "Second Movement",
                "Quantum Interference Patterns",
                "Complexity, Interaction",
                "High"
            ])
        elif frame == 500:
            table.add_row([
                "Third Movement",
                "Fractal Self-Similarity",
                "Reflection, Recursion",
                "Very High"
            ])
        elif frame == 750:
            table.add_row([
                "Fourth Movement",
                "Chaotic Attractor Patterns",
                "Tension, Resolution",
                "Extreme"
            ])
        elif frame == 1000:
            table.add_row([
                "Final Movement",
                "Golden Ratio Harmonics",
                "Transcendence, Unity",
                "Ultimate"
            ])

        for idx, col in enumerate(colors):
            # Enhanced parameters that evolve throughout
            t = frame * 0.03  # Increased base frequency
            base_freq = 2.5 + idx * 0.7  # More spread between frequencies
            harmonic = idx + 1
            
            # Pattern 1: Enhanced Harmonic Awakening
            p1 = (1.0 / harmonic) * np.sin(harmonic * x_points * 1.2 + t) * \
                 np.exp(-0.15 * x_points * (1 - w1))
            
            # Pattern 2: Complex Quantum Interference
            p2 = np.sin(base_freq * x_points + t) * \
                 np.cos((idx + 1) * 0.8 * x_points - t * 1.2) * \
                 (1 + 0.7 * np.sin(0.3 * x_points))
            
            # Pattern 3: Intricate Fractal Echoes
            p3 = np.sin(base_freq * x_points + t) * \
                 np.cos(2.5 * x_points - t * 1.3) * \
                 np.sin(0.7 * x_points + t * 0.8)
            
            # Pattern 4: Enhanced Chaotic Harmony
            p4 = np.sin(base_freq * x_points + np.sin(t * 0.15) * x_points * 1.5) * \
                 (1 + 0.8 * np.cos(0.4 * x_points - t * 0.9))
            
            # Pattern 5: Complex Mathematical Transcendence
            golden_ratio = (1 + np.sqrt(5)) / 2
            p5 = np.sin(base_freq * x_points * 1.2 + t) * \
                 np.cos(golden_ratio * x_points * 1.1 - t) * \
                 (1 + 0.5 * np.sin(0.2 * x_points + t)) + \
                 0.7 * np.sin(harmonic * golden_ratio * x_points - t * 0.7) * \
                 np.exp(-0.08 * x_points) * \
                 (1 + 0.3 * np.cos(0.4 * x_points + t * 1.2))

            # Combine patterns with smooth transitions
            y_data = p1 * (1 - w1) + \
                    p2 * (w1 * (1 - w2)) + \
                    p3 * (w2 * (1 - w3)) + \
                    p4 * (w3 * (1 - w4)) + \
                    p5 * w4

            # Enhanced final modulation
            modulation = 1 + 0.4 * w5 * np.sin(0.15 * x_points + t * harmonic * 0.15)
            y_data *= modulation

            # Dynamic amplitude envelope
            envelope = 1 - 0.4 * np.cos(0.25 * x_points + t * 0.15)
            y_data *= envelope

            plot.set_trace(f"Voice{idx+1}", x_points, y_data, color=col)
            
        test.wait(20) 
        result.progress = int((frame + 1) / total_frames * 100)

    result.progress = 100
    result.status = "PASS"
    return True


================================================================================
*** quantum.py ***
### src/pymetr/scripts/fun/quantum.py ###
================================================================================

import numpy as np

def run_test(test):
    """
    Celestial Dance: Cosmic Symphony
    An intricate animation of celestial bodies weaving through spacetime,
    incorporating advanced orbital mechanics, quantum harmonics, and cosmic resonances.
    """
    # Create and configure the result container
    result = test.create_result("Celestial Symphony")
    plot = test.create_plot("Cosmic Dance")
    plot.x_label = "Spacetime Dimension "
    plot.y_label = "Spacetime Dimension "
    plot.xlim = (-6, 6)
    plot.ylim = (-6, 6)
    plot.grid_enabled = True
    plot.grid_alpha = 0.15
    plot.background_color = "#050510"  # Deep cosmic void
    plot.grid_color = "#101030"
    plot.foreground_color = "#FFFFFF"
    result.add(plot)
    
    # Create analysis table with celestial themes
    table = test.create_table("Cosmic Analysis")
    table.columns = ["Celestial Phase", "Mathematical Theme", "Cosmic Energy", "Complexity"]
    
    # Add initial phase
    table.add_row([
        "Quantum Genesis",
        "Planck Scale Harmonics",
        "Vacuum Fluctuation",
        "Foundational"
    ])
    result.add(table)
    result.show()
    
    # Enhanced celestial color scheme
    colors = ["#02FEE4", "#4BFF36", "#FF9535", "#F23CA6", "#5E57FF"]
    points = 1500  # More points for smoother curves
    golden_ratio = (1 + np.sqrt(5)) / 2
    silver_ratio = 1 + np.sqrt(2)  # Adding another irrational number for complexity
    
    # Initialize traces
    for idx, color in enumerate(colors):
        plot.set_trace(f"Cosmic{idx+1}", np.zeros(points), np.zeros(points), color=color)
    
    def quantum_spiral(t, base_radius, frequency, phase, evolution):
        """Generate quantum-inspired spiral patterns"""
        angle = np.linspace(0, t * 2 * np.pi, points)
        # Complex radius modulation
        radius = base_radius * (1 + 0.4 * np.sin(frequency * angle + phase) * 
                              np.cos(angle * golden_ratio) * 
                              np.sin(angle / silver_ratio))
        # Spiral evolution with multiple harmonics
        spiral = 0.15 * angle * np.exp(evolution * (np.cos(angle / golden_ratio) + 
                                                   np.sin(angle / silver_ratio)))
        return radius * spiral
        
    def relativistic_orbit(t, a, e, phase, modulation):
        """Generate relativistic orbital patterns with precession"""
        theta = np.linspace(0, 2 * np.pi, points)
        # Complex orbital evolution
        r = a * (1 - e**2) / (1 + e * np.cos(theta + phase))
        # Add relativistic precession and quantum effects
        r *= 1 + 0.3 * np.sin(modulation * theta + t)
        return r
        
    def cosmic_weave(t, radius, frequency, phase):
        """Generate complex cosmic weaving patterns"""
        theta = np.linspace(0, 4 * np.pi, points)
        r = radius * (1 + 0.5 * np.sin(frequency * theta + phase))
        # Add multiple harmonics
        r *= 1 + 0.3 * np.cos(theta * golden_ratio) * np.sin(theta / silver_ratio)
        return r
        
    total_frames = 1500  # Extended animation
    for frame in range(total_frames):
        t = frame * 0.03  # Faster base evolution
        progress = frame / total_frames
        
        # Add new phases to the table at key moments
        if frame == 300:
            table.add_row([
                "Quantum Orbital Dance",
                "Schrdinger's Waltz",
                "Wave-Particle Duality",
                "Probabilistic"
            ])
        elif frame == 600:
            table.add_row([
                "Relativistic Weaving",
                "Einstein's Symphony",
                "Spacetime Curvature",
                "Non-Euclidean"
            ])
        elif frame == 900:
            table.add_row([
                "Cosmic String Theory",
                "M-Brane Oscillations",
                "Dimensional Resonance",
                "Hyperdimensional"
            ])
        elif frame == 1200:
            table.add_row([
                "Universal Harmony",
                "Grand Unification",
                "Cosmic Consciousness",
                "Transcendent"
            ])
        
        # Enhanced phase transitions with overlap
        phase1 = np.clip(frame / 300, 0, 1)
        phase2 = np.clip((frame - 250) / 300, 0, 1)
        phase3 = np.clip((frame - 500) / 300, 0, 1)
        phase4 = np.clip((frame - 750) / 300, 0, 1)
        phase5 = np.clip((frame - 1000) / 300, 0, 1)
        
        for idx, color in enumerate(colors):
            # Complex base parameters
            body_phase = idx * 2 * np.pi / len(colors)
            frequency = (1 + idx * 0.5) * (1 + 0.2 * np.sin(t * 0.1))
            
            # Time-varying parameters with multiple harmonics
            theta = np.linspace(0, 2 * np.pi * (idx + 1.5), points)
            evolution = 0.15 + 0.08 * np.sin(t * frequency) * np.cos(t * 0.2)
            
            # Phase 1: Quantum Genesis
            spiral = quantum_spiral(t, 1 + 0.3 * idx, frequency, body_phase, evolution)
            x1 = spiral * np.cos(theta + t * (1 + 0.1 * np.sin(t * 0.2)))
            y1 = spiral * np.sin(theta + t * (1 + 0.1 * np.cos(t * 0.2)))
            
            # Phase 2: Quantum Orbital Dance
            orbit = relativistic_orbit(t, 2 + 0.5 * idx, 0.3 + 0.1 * np.sin(t), 
                                     body_phase, frequency)
            x2 = orbit * np.cos(theta + t * frequency * (1 + 0.2 * np.sin(t * 0.3)))
            y2 = orbit * np.sin(theta + t * frequency * (1 + 0.2 * np.cos(t * 0.3)))
            
            # Phase 3: Relativistic Weaving
            r3 = (3 + idx * 0.5) * np.exp(-0.1 * theta * (1 + 0.2 * np.sin(t)))
            phase_mod = t + body_phase * (1 + 0.3 * np.sin(t * 0.4))
            x3 = r3 * np.cos(theta + phase_mod) * (1 + 0.2 * np.sin(theta * golden_ratio))
            y3 = r3 * np.sin(theta + phase_mod) * (1 + 0.2 * np.cos(theta * silver_ratio))
            
            # Phase 4: Cosmic String Vibrations
            r4 = cosmic_weave(t, 2 + 0.5 * np.sin(t), frequency, body_phase)
            string_phase = theta * golden_ratio + t * (1 + 0.3 * np.sin(t * 0.2))
            x4 = r4 * np.cos(string_phase) * (1 + 0.3 * np.sin(theta * silver_ratio))
            y4 = r4 * np.sin(string_phase) * (1 + 0.3 * np.cos(theta * golden_ratio))
            
            # Phase 5: Universal Harmony
            r5 = 3 * np.sin(theta * frequency + t * (1 + 0.2 * np.sin(t * 0.3)))
            harmony_phase = theta * silver_ratio + t + body_phase
            x5 = r5 * np.cos(harmony_phase) * (1 + 0.4 * np.sin(theta / golden_ratio))
            y5 = r5 * np.sin(harmony_phase) * (1 + 0.4 * np.cos(theta / silver_ratio))
            
            # Enhanced blending with modulation
            blend_mod = 1 + 0.2 * np.sin(5 * theta + t * frequency)
            x = (x1 * (1 - phase2) + x2 * phase2 * (1 - phase3) + 
                 x3 * phase3 * (1 - phase4) + x4 * phase4 * (1 - phase5) + 
                 x5 * phase5) * blend_mod
            y = (y1 * (1 - phase2) + y2 * phase2 * (1 - phase3) + 
                 y3 * phase3 * (1 - phase4) + y4 * phase4 * (1 - phase5) + 
                 y5 * phase5) * blend_mod
            
            # Final harmonic modulation with multiple frequencies
            modulation = (1 + 0.3 * np.sin(5 * theta + t * frequency) * 
                        np.cos(3 * theta + t * 0.5) * 
                        np.sin(theta * golden_ratio + t * 0.3))
            x *= modulation
            y *= modulation
            
            # Update trace with temporal smoothing
            plot.set_trace(f"Cosmic{idx+1}", x, y, color=color)
        
        test.wait(10)
        result.progress = int((frame + 1) / total_frames * 100)
    
    result.status = "PASS"
    return True


================================================================================
*** symphony.py ***
### src/pymetr/scripts/fun/symphony.py ###
================================================================================

import numpy as np

def run_test(test):
    """
    Enhanced Plot Animation Test with evolving mathematical patterns
    Features multiple sections with different mathematical behaviors
    """
    # Create a result container and show it
    result = test.create_result("Complex Evolving Plot Test")
    result.show()
    
    # Create a plot and add it to the result
    plot = test.create_plot("Symphony")
    plot.x_label = "Time (s)"
    plot.y_label = "Amplitude"
    result.add(plot)

    # Set plot properties
    plot.title = "Symphony"
    plot.x_unit = "s"
    plot.y_unit = "A.U."
    plot.grid_enabled = True
    plot.legend_enabled = True
    plot.roi_visible = True

    # Create analysis table
    table = test.create_table("Pattern Analysis")
    result.add(table)
    table.columns = ["Section", "Pattern Type", "Max Amplitude", "Frequency"]

    # Define our color scheme
    colors = ["#02FEE4", "#4BFF36", "#FF9535", "#F23CA6", "#5E57FF"]
    x_points = np.linspace(0, 10, 1000)

    # Initialize traces
    for idx, col in enumerate(colors):
        plot.set_trace(f"Trace{idx+1}", x_points, np.zeros_like(x_points), color=col)

    # Section 1: Harmonic Series Evolution (0-250 frames)
    for frame in range(250):
        progress = frame / 250
        for idx, col in enumerate(colors):
            harmonic = idx + 1
            amplitude = 1.0 / harmonic
            phase = frame * 0.02 * harmonic
            y_data = amplitude * np.sin(harmonic * x_points + phase)
            y_data *= np.exp(-0.1 * x_points)  # Decay envelope
            plot.set_trace(f"Trace{idx+1}", x_points, y_data, color=col)
        test.wait(30)
        result.progress = int(progress * 25)

    # Section 2: Interference Patterns (250-500 frames)
    for frame in range(250):
        progress = frame / 250
        for idx, col in enumerate(colors):
            freq1 = 1 + idx * 0.5
            freq2 = 2 + idx * 0.3
            y_data = np.sin(freq1 * x_points + frame * 0.05) + \
                     np.sin(freq2 * x_points - frame * 0.03)
            y_data *= np.cos(0.5 * x_points + frame * 0.02)  # Modulation
            plot.set_trace(f"Trace{idx+1}", x_points, y_data, color=col)
        test.wait(30)
        result.progress = 25 + int(progress * 25)

    # Section 3: Lissajous-inspired Patterns (500-750 frames)
    for frame in range(250):
        progress = frame / 250
        for idx, col in enumerate(colors):
            t = frame * 0.02
            freq = 1 + idx * 0.2
            y_data = np.sin(freq * x_points + t) * \
                     np.cos((idx + 1) * x_points - t)
            envelope = 1 - 0.5 * np.cos(0.2 * x_points)
            y_data *= envelope
            plot.set_trace(f"Trace{idx+1}", x_points, y_data, color=col)
        test.wait(30)
        result.progress = 50 + int(progress * 25)

    # Section 4: Final Convergence (750-1000 frames)
    for frame in range(250):
        progress = frame / 250
        convergence = frame / 250.0  # Goes from 0 to 1
        for idx, col in enumerate(colors):
            base_freq = 2 + idx * 0.5
            phase = frame * 0.03
            # Start with complex pattern and converge to simple sine
            complex_pattern = np.sin(base_freq * x_points + phase) * \
                            np.cos((5-idx) * x_points - phase)
            simple_pattern = np.sin(base_freq * x_points + phase)
            y_data = (1 - convergence) * complex_pattern + \
                     convergence * simple_pattern
            # Add final flourish
            y_data *= (1 + 0.5 * np.sin(0.1 * x_points + phase))
            plot.set_trace(f"Trace{idx+1}", x_points, y_data, color=col)
        test.wait(30)
        result.progress = 75 + int(progress * 25)

    # Update analysis table with section information
    table.add_row(["Section 1", "Harmonic Series", "1.0", "1-5 Hz"])
    table.add_row(["Section 2", "Interference", "2.0", "1.5-3.5 Hz"])
    table.add_row(["Section 3", "Lissajous", "1.0", "1.2-2.0 Hz"])
    table.add_row(["Section 4", "Convergence", "1.5", "2.0-4.5 Hz"])

    result.progress = 100
    result.status = "PASS"
    return True


================================================================================
*** file_services.py ***
### src/pymetr/services/file_services.py ###
================================================================================

from pathlib import Path
from typing import Dict, Any, Optional, Tuple
from PySide6.QtWidgets import QWidget, QFileDialog
import yaml

from pymetr.core.logging import logger
from pymetr.models.test import TestSuite, TestScript

class FileService:
    """Service for importing/exporting model data and handling files."""
    
    @staticmethod
    def export_model_data(model_id: str, state, path: Path) -> bool:
        """Export model and its children to YAML."""
        try:
            model = state.get_model(model_id)
            if not model:
                return False
                
            data = FileService._export_model(model, state)
                
            # Write to file
            with open(path, 'w') as f:
                yaml.dump(data, f)
            return True
            
        except Exception as e:
            logger.error(f"Error exporting model data: {e}")
            return False

    @staticmethod
    def _export_model(model, state) -> Dict:
        """Recursively export a model and its children."""
        data = {
            'type': type(model).__name__,
            'properties': model._properties,
            'children': []
        }
        
        # Export children recursively
        for child in state.get_children(model.id):
            child_data = FileService._export_model(child, state)
            data['children'].append(child_data)
            
        return data

    @staticmethod
    def import_model_data(path: Path, state) -> Optional[str]:
        """Import model data from YAML, returns root model ID."""
        try:
            with open(path) as f:
                data = yaml.safe_load(f)
            
            return FileService._import_model(data, state)
            
        except Exception as e:
            logger.error(f"Error importing model data: {e}")
            return None

    @staticmethod
    def _import_model(data: Dict, state) -> Optional[str]:
        """Recursively import a model and its children."""
        try:
            # Import model based on type
            model_type = data['type']
            properties = data.get('properties', {})
            
            # Create model instance
            if model_type == 'TestSuite':
                model = state.create_model(TestSuite)
            elif model_type == 'TestScript':
                script_path = properties.get('script_path')
                if script_path:
                    script_path = Path(script_path)
                    model = state.create_model(TestScript, script_path=script_path)
                else:
                    logger.error("TestScript missing script_path")
                    return None
            else:
                # Handle other model types...
                return None
                
            # Set properties
            for key, value in properties.items():
                model.set_property(key, value)
                
            # Import children recursively
            for child_data in data.get('children', []):
                child_id = FileService._import_model(child_data, state)
                if child_id:
                    state.link_models(model.id, child_id)
                    
            return model.id
            
        except Exception as e:
            logger.error(f"Error importing model: {e}")
            return None

    @staticmethod
    def open_suite(parent: Optional[QWidget] = None) -> Tuple[bool, Optional[Path], str]:
        """Handle suite opening UI and file operations."""
        if parent:
            file_path, _ = QFileDialog.getOpenFileName(
                parent,
                "Open Test Suite",
                str(Path.home()),
                "YAML Files (*.yaml)"
            )
            if file_path:
                try:
                    path = Path(file_path)
                    if path.exists():
                        return True, path, ""
                except Exception as e:
                    logger.error(f"Error opening suite: {e}")
                    return False, None, str(e)
                    
        return False, None, "No parent widget provided"

    @staticmethod
    def save_suite(suite: TestSuite, parent: Optional[QWidget] = None) -> Tuple[bool, Optional[Path], str]:
        """Handle suite saving UI and file operations."""
        if not parent:
            return False, None, "No parent widget provided"
            
        try:
            file_path, _ = QFileDialog.getSaveFileName(
                parent,
                "Save Test Suite",
                str(Path.home()),
                "YAML Files (*.yaml)"
            )
            
            if file_path:
                path = Path(file_path)
                if not path.suffix:
                    path = path.with_suffix('.yaml')
                    
                success = FileService.export_model_data(suite.id, suite.state, path)
                if success:
                    return True, path, ""
                else:
                    return False, None, "Failed to export suite data"
                    
        except Exception as e:
            logger.error(f"Error saving suite: {e}")
            return False, None, str(e)
            
        return False, None, "Operation cancelled"


================================================================================
*** script.py ***
### src/pymetr/services/script.py ###
================================================================================

from pathlib import Path
from typing import Optional, Tuple
from PySide6.QtWidgets import QWidget, QFileDialog, QMessageBox

from pymetr.models.test import TestScript
from pymetr.core.logging import logger

class ScriptService:
    """Handles script-related operations."""
    
    @staticmethod
    def create_script(parent: Optional[QWidget] = None) -> Tuple[bool, Optional[Path], str]:
        """
        Handle script creation UI and file operations.
        Returns: (success, path, error_message)
        """
        if parent:
            file_path, _ = QFileDialog.getSaveFileName(
                parent,
                "Create New Script",
                str(Path.home()),
                "Python Files (*.py)"
            )
            if file_path:
                path = Path(file_path)
                if not path.suffix:
                    path = path.with_suffix('.py')
                    
                try:
                    if not path.exists():
                        path.write_text(
                            "def run_test():\n"
                            "    # Your test code here\n"
                            "    pass\n"
                        )
                    return True, path, ""
                    
                except Exception as e:
                    logger.error(f"Error creating script: {e}")
                    return False, None, str(e)
                    
        return False, None, "No parent widget provided"

    @staticmethod
    def open_script(parent: Optional[QWidget] = None) -> Tuple[bool, Optional[Path], str]:
        """
        Handle script opening UI and file operations.
        Returns: (success, path, error_message)
        """
        if parent:
            file_path, _ = QFileDialog.getOpenFileName(
                parent,
                "Open Script",
                str(Path.home()),
                "Python Files (*.py)"
            )
            if file_path:
                try:
                    path = Path(file_path)
                    if path.exists():
                        return True, path, ""
                except Exception as e:
                    logger.error(f"Error opening script: {e}")
                    return False, None, str(e)
                    
        return False, None, "No parent widget provided"


================================================================================
*** main_window.py ***
### src/pymetr/ui/main_window.py ###
================================================================================

from typing import Optional, Dict, Type, Tuple
from pathlib import Path

from PySide6.QtCore import Qt, QSettings, QSize, QTimer
from PySide6.QtGui import (
    QPainter, QPainterPath, QColor, QIcon, QAction,
    QPaintEvent, QKeySequence
)
from PySide6.QtWidgets import (
    QMainWindow, QWidget, QVBoxLayout, QDockWidget,
    QToolBar, QLabel, QApplication, QStyle
)

from pymetr.ui.views.title_bar import TitleBar
from pymetr.ui.views.test_tree_view import ModelTreeView
from pymetr.ui.views.device_tree_view import DeviceTreeView
from pymetr.ui.views.base import BaseWidget
from pymetr.ui.views.status_bar import StatusBar
from pymetr.models.test import TestScript
from pymetr.models.plot import Plot
from pymetr.ui.tabs.script_tab import ScriptTab
from pymetr.ui.tabs.plot_tab import PlotTab
from pymetr.ui.tabs.result_tab import ResultTab
from pymetr.ui.tabs.table_tab import TableTab
from pymetr.core.logging import logger

class MainWindow(QMainWindow):
    """
    Main application window with dockable views and tabbed content.
    
    Key behaviors:
    - Manages dockable test explorer and instrument panels
    - Provides tabbed content area for test results, plots, etc.
    - Synchronizes model selection with visible content
    - Maintains window state between sessions
    """
    def __init__(self, state):
        logger.debug("Initializing MainWindow")
        super().__init__()
        self.state = state
        self.state.set_parent(self)
        
        # Track content views and docks
        self._content_docks: Dict[str, QDockWidget] = {}
        self._content_views: Dict[str, BaseWidget] = {}
        self._welcome_dock: Optional[QDockWidget] = None
        
        # Create inner window for content management
        self.content_window = QMainWindow(self)
        self.content_window.setWindowFlags(Qt.Widget)
        self.content_window.setDockOptions(
            QMainWindow.AnimatedDocks |
            QMainWindow.AllowNestedDocks |
            QMainWindow.AllowTabbedDocks
        )
        self.setCentralWidget(self.content_window)
        
        self._setup_window()
        self._setup_title_bar()
        self._setup_quick_tools()
        self._setup_docks()
        self._setup_status_bar()
        
        self.show_welcome()
        self._connect_signals()
        self._restore_state()

    def _setup_window(self):
        """Configure main window properties."""
        self.setWindowFlags(Qt.FramelessWindowHint | Qt.WindowSystemMenuHint)
        self.setAttribute(Qt.WA_TranslucentBackground, True)
        self.resize(1200, 800)
        self.setDockOptions(
            QMainWindow.AnimatedDocks |
            QMainWindow.AllowNestedDocks |
            QMainWindow.AllowTabbedDocks
        )

    def _setup_quick_tools(self):
        """Set up quick access toolbar with common actions."""
        self.quick_tools = QToolBar("QuickTools")
        self.quick_tools.setMovable(False)
        self.quick_tools.setIconSize(QSize(28, 28))
        
        # File Explorer
        explorer_action = QAction(
            QIcon(str(Path(__file__).parent / 'icons' / 'folder.png')),
            "File Explorer",
            self
        )
        explorer_action.setShortcut(QKeySequence("Ctrl+E"))
        explorer_action.triggered.connect(self._toggle_file_explorer)
        
        # Run Selected Test
        run_test_action = QAction(
            QIcon(str(Path(__file__).parent / 'icons' / 'run.png')),
            "Run Test",
            self
        )
        run_test_action.setShortcut(QKeySequence("F5"))
        run_test_action.triggered.connect(self._on_run_test)
        
        # Stop Test
        stop_test_action = QAction(
            QIcon(str(Path(__file__).parent / 'icons' / 'stop.png')),
            "Stop Test",
            self
        )
        stop_test_action.setShortcut(QKeySequence("F6"))
        stop_test_action.triggered.connect(self._on_stop_test)
        
        # Toggle Instrument Panel
        toggle_instruments_action = QAction(
            QIcon(str(Path(__file__).parent / 'icons' / 'instruments.png')),
            "Instruments",
            self
        )
        toggle_instruments_action.setShortcut(QKeySequence("Ctrl+I"))
        toggle_instruments_action.triggered.connect(
            lambda: self.instrument_dock.setVisible(
                not self.instrument_dock.isVisible()
            )
        )
        
        # New Script
        new_script_action = QAction(
            QIcon(str(Path(__file__).parent / 'icons' / 'new_script.png')),
            "New Script",
            self
        )
        new_script_action.setShortcut(QKeySequence("Ctrl+N"))
        new_script_action.triggered.connect(self._on_new_script)
        
        # Add actions to toolbar
        self.quick_tools.addAction(explorer_action)
        self.quick_tools.addAction(new_script_action)
        self.quick_tools.addSeparator()
        self.quick_tools.addAction(run_test_action)
        self.quick_tools.addAction(stop_test_action)
        self.quick_tools.addSeparator()
        self.quick_tools.addAction(toggle_instruments_action)
        
        self.addToolBar(Qt.TopToolBarArea, self.quick_tools)

    def _setup_docks(self):
        """Set up test explorer and instrument docks."""
        # Test Explorer
        self.test_dock = QDockWidget("Test Explorer", self)
        self.test_dock.setObjectName("TestExplorerDock")
        self.test_dock.setMinimumWidth(250)
        self.test_dock.setFeatures(
            QDockWidget.DockWidgetMovable | 
            QDockWidget.DockWidgetFloatable
        )
        self.test_tree_view = ModelTreeView(self.state, parent=self.test_dock)
        self.test_dock.setWidget(self.test_tree_view)
        self.addDockWidget(Qt.LeftDockWidgetArea, self.test_dock)
        
        # Instruments
        self.instrument_dock = QDockWidget("Instruments", self)
        self.instrument_dock.setObjectName("InstrumentsDock")
        self.instrument_dock.setMinimumWidth(200)
        self.instrument_dock.setFeatures(
            QDockWidget.DockWidgetMovable | 
            QDockWidget.DockWidgetFloatable
        )
        self.device_view = DeviceTreeView(self.state, None, parent=self.instrument_dock)
        self.instrument_dock.setWidget(self.device_view)
        self.addDockWidget(Qt.RightDockWidgetArea, self.instrument_dock)

    def _handle_model_registered(self, model_id: str):
        """Handle new model registration."""
        logger.debug(f"Model {model_id} registered")
        # Views are created on-demand when activated

    def _handle_active_model(self, model_id: str):
        """
        Handle model activation by showing appropriate view.
        Views are created on first activation if they don't exist.
        """
        logger.debug(f"Handling activation of model {model_id}")
        
        if model_id:
            if model_id in self._content_docks:
                dock = self._content_docks[model_id]
                if not dock.isVisible():
                    dock.show()
                dock.raise_()
                
                # Handle tabbed docks
                if self.content_window.tabifiedDockWidgets(dock):
                    dock.show()
                    dock.raise_()
            else:
                self.open_content(model_id)
            
            self.hide_welcome()
        else:
            self.show_welcome()

    def open_content(self, model_id: str) -> bool:
        """Open or show content for the given model."""
        model = self.state.get_model(model_id)
        if not model:
            return False

        # Create view if needed
        if model_id not in self._content_views:
            view_class = self._get_view_class(model)
            if not view_class:
                return False
                
            view = view_class(self.state, model_id, self)
            dock = QDockWidget(model.get_property('name', str(model_id)), self.content_window)
            dock.setWidget(view)
            
            self._content_views[model_id] = view
            self._content_docks[model_id] = dock
            
            # Add to content window
            self.content_window.addDockWidget(Qt.RightDockWidgetArea, dock)
            
            # Tabify with existing content
            existing_docks = [d for mid, d in self._content_docks.items() if mid != model_id]
            if existing_docks:
                self.content_window.tabifyDockWidget(existing_docks[-1], dock)
                
        dock = self._content_docks[model_id]
        dock.show()
        dock.raise_()
        
        return True

    def _on_run_test(self):
        """Run the currently selected test."""
        active_model = self.state.get_active_model()
        if isinstance(active_model, TestScript):
            logger.debug(f"Running test: {active_model.get_property('name')}")
            self.state.engine.run_test(active_model.id)

    def _on_stop_test(self):
        """Stop the currently running test."""
        active_model = self.state.get_active_model()
        if isinstance(active_model, TestScript):
            logger.debug(f"Stopping test: {active_model.get_property('name')}")
            self.state.engine.stop_test(active_model.id)

    def _connect_signals(self):
        """Connect to ApplicationState signals."""
        self.state.model_registered.connect(self._handle_model_registered)
        self.state.active_model_changed.connect(self._handle_active_model)
        self.state.model_changed.connect(self._handle_model_changed)
        self.state.model_removed.connect(self._handle_model_removed)
        
    def _setup_title_bar(self):
        """Set up custom frameless window title bar."""
        self.title_bar = TitleBar(self, state=self.state)
        self.setMenuWidget(self.title_bar)
        self.title_bar.windowMinimizeRequested.connect(self.showMinimized)
        self.title_bar.windowMaximizeRequested.connect(self._toggle_maximize)
        self.title_bar.windowCloseRequested.connect(self.close)

    def _setup_status_bar(self):
        """Set up status bar for application messages."""
        self.status_bar = StatusBar(self.state)
        self.setStatusBar(self.status_bar)

    def show_welcome(self):
        """Show welcome screen when no content is open."""
        if self._welcome_dock is None:
            welcome = WelcomeWidget(self.state, self)
            self._welcome_dock = QDockWidget("Welcome", self.content_window)
            self._welcome_dock.setWidget(welcome)
            self._welcome_dock.setFeatures(
                QDockWidget.DockWidgetMovable | 
                QDockWidget.DockWidgetFloatable
            )
            self.content_window.addDockWidget(Qt.RightDockWidgetArea, self._welcome_dock)
        else:
            self._welcome_dock.show()
            self._welcome_dock.raise_()

    def hide_welcome(self):
        """Hide welcome screen when content is shown."""
        if self._welcome_dock is not None:
            self._welcome_dock.hide()

    def _get_view_class(self, model) -> Optional[Type[BaseWidget]]:
        """Get the appropriate view class for a given model type."""
        model_type = type(model).__name__
        return {
            'TestScript': ScriptTab,
            'TestResult': ResultTab,
            'Plot': PlotTab,
            'DataTable': TableTab
        }.get(model_type)

    def _handle_model_changed(self, model_id: str, prop: str, value: object):
        """Update dock title when model name changes."""
        if prop == 'name' and model_id in self._content_docks:
            self._content_docks[model_id].setWindowTitle(str(value))

    def _handle_model_removed(self, model_id: str):
        """Clean up views and docks when a model is removed."""
        if model_id in self._content_docks:
            dock = self._content_docks.pop(model_id)
            view = self._content_views.pop(model_id, None)
            
            # Clean up view if it has a cleanup method
            if view and hasattr(view, 'cleanup'):
                view.cleanup()
            
            dock.setParent(None)
            dock.deleteLater()
            
            # Show welcome if no content remains
            if not self._content_docks:
                self.show_welcome()

    def _toggle_maximize(self):
        """Toggle between maximized and normal window state."""
        if self.isMaximized():
            self.showNormal()
        else:
            self.showMaximized()

    def _toggle_file_explorer(self):
        """Toggle file explorer visibility."""
        pass  # TODO: Implement file explorer toggle

    def _on_new_script(self):
        """Handle new script creation."""
        pass  # TODO: Implement new script creation

    def _restore_state(self):
        """Restore window geometry and dock states from settings."""
        settings = QSettings("PyMetr", "PyMetr")
        
        # Restore window geometry
        geometry = settings.value("geometry")
        if geometry:
            self.restoreGeometry(geometry)
            
        # Restore dock and toolbar states
        state = settings.value("windowState")
        if state:
            self.restoreState(state)
            
        # Restore content window state
        content_state = settings.value("contentState")
        if content_state:
            self.content_window.restoreState(content_state)

    def paintEvent(self, event: QPaintEvent):
        """Custom paint for rounded window corners."""
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        
        # Create rounded rect path
        path = QPainterPath()
        path.addRoundedRect(self.rect(), 10, 10)
        
        # Clip to path and fill
        painter.setClipPath(path)
        painter.fillRect(self.rect(), QColor("#2A2A2A"))

    def closeEvent(self, event):
        """Save window state before closing."""
        settings = QSettings("PyMetr", "PyMetr")
        settings.setValue("geometry", self.saveGeometry())
        settings.setValue("windowState", self.saveState())
        settings.setValue("contentState", self.content_window.saveState())
        
        # Clean up all views
        for view in self._content_views.values():
            if hasattr(view, 'cleanup'):
                view.cleanup()
                
        super().closeEvent(event)

class WelcomeWidget(QWidget):
    """Welcome screen shown when no content is open."""
    def __init__(self, state, parent=None):
        super().__init__(parent)
        self.state = state
        self._setup_ui()
        
    def _setup_ui(self):
        """Set up welcome screen UI."""
        layout = QVBoxLayout(self)
        layout.setAlignment(Qt.AlignCenter)
        
        welcome_text = (
            "<h1>Welcome to PyMetr</h1>"
            "<p>Start by opening a script or connecting an instrument.</p>"
            "<p>Use the ribbon actions above to get started.</p>"
        )
        
        label = QLabel(welcome_text)
        label.setStyleSheet("""
            QLabel {
                color: #CCCCCC;
                font-size: 14px;
            }
            h1 {
                color: #FFFFFF;
                margin-bottom: 20px;
            }
        """)
        
        layout.addWidget(label)


================================================================================
*** status_bar.py ***
### src/pymetr/ui/status_bar.py ###
================================================================================

# views/widgets/status_bar.py
from typing import Optional, Dict
from PySide6.QtWidgets import (
    QStatusBar, QWidget, QHBoxLayout, 
    QLabel, QProgressBar
)
from PySide6.QtCore import Qt, Signal, QTimer
from PySide6.QtGui import QIcon, QColor

class StatusIndicator(QWidget):
    """Individual status indicator widget."""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self._setup_ui()
        self._timer = QTimer(self)
        self._timer.timeout.connect(self._clear_message)
        
    def _setup_ui(self):
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(4)
        
        self.icon_label = QLabel()
        layout.addWidget(self.icon_label)
        
        self.text_label = QLabel()
        self.text_label.setStyleSheet("color: #D4D4D4;")
        layout.addWidget(self.text_label)
        
    def show_message(self, message: str, icon: Optional[QIcon] = None, 
                    color: Optional[str] = None, timeout: int = 0):
        """Show a message with optional icon and timeout."""
        if icon:
            self.icon_label.setPixmap(icon.pixmap(16, 16))
        
        self.text_label.setText(message)
        if color:
            self.text_label.setStyleSheet(f"color: {color};")
            
        if timeout > 0:
            self._timer.start(timeout)
            
    def _clear_message(self):
        """Clear the current message."""
        self.icon_label.clear()
        self.text_label.clear()
        self._timer.stop()

class StatusBar(QStatusBar):
    """Advanced status bar with multiple indicators."""
    
    def __init__(self, state, parent=None):
        super().__init__(parent)
        self.state = state
        self._setup_ui()
        self._connect_signals()
        
    def _setup_ui(self):
        # Main status indicator
        self.main_status = StatusIndicator()
        self.addWidget(self.main_status, 1)  # Stretch to take available space
        
        # Progress bar (initially hidden)
        self.progress_bar = QProgressBar()
        self.progress_bar.setMaximumHeight(15)
        self.progress_bar.setMaximumWidth(100)
        self.progress_bar.hide()
        self.addPermanentWidget(self.progress_bar)
        
        # Error/warning indicator
        self.alert_status = StatusIndicator()
        self.addPermanentWidget(self.alert_status)
        
        # Additional indicators can be added as needed
        self.info_status = StatusIndicator()
        self.addPermanentWidget(self.info_status)
        
    def _connect_signals(self):
        """Connect to state signals."""
        self.state.status_changed.connect(self._handle_status)
        self.state.status_progress.connect(self._handle_progress)
        self.state.status_error.connect(self._handle_error)
        self.state.status_warning.connect(self._handle_warning)
        self.state.status_info.connect(self._handle_info)
        
    def _handle_status(self, message: str):
        """Handle main status updates."""
        self.main_status.show_message(message)
        
    def _handle_progress(self, percent: float, message: str):
        """Handle progress updates."""
        if percent > 0:
            self.progress_bar.show()
            self.progress_bar.setValue(int(percent))
            if message:
                self.main_status.show_message(message)
        else:
            self.progress_bar.hide()
            
    def _handle_error(self, message: str):
        """Handle error messages."""
        self.alert_status.show_message(
            message,
            # icon=QIcon("path/to/error.png"),
            color="#F14C4C",
            timeout=5000
        )
        
    def _handle_warning(self, message: str):
        """Handle warning messages."""
        self.alert_status.show_message(
            message,
            # icon=QIcon("path/to/warning.png"),
            color="#FFA500",
            timeout=5000
        )
        
    def _handle_info(self, message: str):
        """Handle info messages."""
        self.info_status.show_message(
            message,
            # icon=QIcon("path/to/info.png"),
            color="#4EC9B0",
            timeout=3000
        )


================================================================================
*** title_bar.py ***
### src/pymetr/ui/title_bar.py ###
================================================================================

import logging
import os
from PySide6.QtWidgets import (
    QWidget, QHBoxLayout, QToolButton, QSpacerItem, 
    QSizePolicy, QMenu
)
from PySide6.QtCore import Signal, Qt, QPoint, QSize
from PySide6.QtGui import QIcon

from pymetr.core.actions import STANDARD_ACTIONS

logger = logging.getLogger(__name__)

class TitleBar(QWidget):
    """
    A custom, frameless title bar with:
      - Menu buttons (File, Edit, Instrument, Report, Window, Options)
      - Minimize, Maximize, Close buttons
      - Window dragging support
    """
    
    windowMinimizeRequested = Signal()
    windowMaximizeRequested = Signal()
    windowCloseRequested = Signal()

    def __init__(self, parent=None, state=None):
        super().__init__(parent)
        
        self.state = state
        self._pressing = False
        self._start_pos = None
        
        self.setObjectName("TitleBar")
        self.layout = QHBoxLayout(self)
        self.layout.setContentsMargins(5, 5, 5, 5)
        self.layout.setSpacing(10)

        # Build absolute path to icons
        base_dir = os.path.dirname(os.path.abspath(__file__))
        self.icons_dir = os.path.join(base_dir, "icons")

        self._setup_menu_buttons()
        self._setup_window_controls()

    def _setup_menu_buttons(self):
        """Set up the menu buttons on the left side."""
        # File menu
        self.file_button = QToolButton(self)
        self.file_button.setText("File")
        self.file_button.clicked.connect(self._show_file_menu)
        self.layout.addWidget(self.file_button)

        # Edit menu
        self.edit_button = QToolButton(self)
        self.edit_button.setText("Edit")
        self.edit_button.clicked.connect(self._show_edit_menu)
        self.layout.addWidget(self.edit_button)

        # Instrument menu
        self.instrument_button = QToolButton(self)
        self.instrument_button.setText("Instrument")
        self.instrument_button.clicked.connect(self._show_instrument_menu)
        self.layout.addWidget(self.instrument_button)

        # Report menu
        self.report_button = QToolButton(self)
        self.report_button.setText("Report")
        self.report_button.clicked.connect(self._show_report_menu)
        self.layout.addWidget(self.report_button)

        # Window menu
        self.window_button = QToolButton(self)
        self.window_button.setText("Window")
        self.window_button.clicked.connect(self._show_window_menu)
        self.layout.addWidget(self.window_button)

        # Options menu
        self.options_button = QToolButton(self)
        self.options_button.setText("Options")
        self.options_button.clicked.connect(self._show_options_menu)
        self.layout.addWidget(self.options_button)

        # Add expanding spacer to push window controls right
        spacer = QSpacerItem(40, 20, QSizePolicy.Expanding, QSizePolicy.Minimum)
        self.layout.addSpacerItem(spacer)

    def _setup_window_controls(self):
        """Set up the window control buttons on the right side."""
        # Minimize button
        minimize_icon = os.path.join(self.icons_dir, "minimize.png")
        self.minimize_button = QToolButton()
        self.minimize_button.setIcon(QIcon(minimize_icon))
        self.minimize_button.setIconSize(QSize(24, 24))
        self.minimize_button.clicked.connect(self.on_minimize_clicked)
        self.layout.addWidget(self.minimize_button)

        # Maximize button
        maximize_icon = os.path.join(self.icons_dir, "maximize.png")
        self.maximize_button = QToolButton()
        self.maximize_button.setIcon(QIcon(maximize_icon))
        self.maximize_button.setIconSize(QSize(24, 24))
        self.maximize_button.clicked.connect(self.on_maximize_clicked)
        self.layout.addWidget(self.maximize_button)

        # Close button
        close_icon = os.path.join(self.icons_dir, "close.png")
        self.close_button = QToolButton()
        self.close_button.setIcon(QIcon(close_icon))
        self.close_button.setIconSize(QSize(24, 24))
        self.close_button.clicked.connect(self.on_close_clicked)
        self.layout.addWidget(self.close_button)

    def _show_file_menu(self):
        menu = QMenu(self)
        
        # New submenu
        new_menu = menu.addMenu("New")
        new_menu.addAction("Suite", lambda: self._trigger_action('new_suite'))
        new_menu.addAction("Script", lambda: self._trigger_action('new_script'))
        
        # Open submenu
        open_menu = menu.addMenu("Open")
        open_menu.addAction("Suite", lambda: self._trigger_action('open_suite'))
        open_menu.addAction("Script", lambda: self._trigger_action('open_script'))
        
        menu.addSeparator()
        
        # Save actions
        menu.addAction("Save", lambda: self._trigger_action('save_script'))
        menu.addAction("Save Suite", lambda: self._trigger_action('save_suite'))
        
        menu.addSeparator()
        
        # Data submenu
        data_menu = menu.addMenu("Data")
        data_menu.addAction("Load Data")
        data_menu.addAction("Save Data")
        
        # State submenu
        state_menu = menu.addMenu("State")
        state_menu.addAction("Load State")
        state_menu.addAction("Save State")
        
        menu.exec_(self.file_button.mapToGlobal(QPoint(0, self.file_button.height())))

    def _show_edit_menu(self):
        menu = QMenu(self)
        menu.addAction("Create Result")
        menu.addAction("Create Plot")
        
        markers_menu = menu.addMenu("Markers")
        markers_menu.addAction("Create Marker")
        markers_menu.addAction("Create Cursor")
        
        menu.exec_(self.edit_button.mapToGlobal(QPoint(0, self.edit_button.height())))

    def _show_instrument_menu(self):
        menu = QMenu(self)
        menu.addAction("Discover", lambda: self._trigger_action('discover_instruments'))
        menu.addAction("Load Driver")
        menu.addAction("Mock Instrument")
        
        menu.exec_(self.instrument_button.mapToGlobal(QPoint(0, self.instrument_button.height())))

    def _show_report_menu(self):
        menu = QMenu(self)
        menu.addAction("Generate")
        menu.addAction("Load Template")
        menu.addAction("New Template")
        menu.addSeparator()
        menu.addAction("Preferences")
        
        menu.exec_(self.report_button.mapToGlobal(QPoint(0, self.report_button.height())))

    def _show_window_menu(self):
        menu = QMenu(self)
        menu.addAction("Default Layout")
        menu.addSeparator()
        menu.addAction("Show/Hide Instrument Dock")
        menu.addAction("Show/Hide Console")
        
        menu.exec_(self.window_button.mapToGlobal(QPoint(0, self.window_button.height())))

    def _show_options_menu(self):
        menu = QMenu(self)
        menu.addAction("Settings")
        
        menu.exec_(self.options_button.mapToGlobal(QPoint(0, self.options_button.height())))

    def _trigger_action(self, action_id: str):
        """Trigger a standard action if available and executable."""
        if not self.state:
            logger.warning("TitleBar has no 'state'; cannot run action.")
            return

        action_obj = STANDARD_ACTIONS.get(action_id)
        if not action_obj:
            logger.warning(f"No STANDARD_ACTIONS entry for '{action_id}'")
            return

        if not action_obj.can_execute(self.state):
            logger.warning(f"Action '{action_id}' cannot execute in current state.")
            return

        logger.debug(f"TitleBar: calling handler for '{action_id}'")
        action_obj.handler(self.state)

    # Window control handlers
    def on_minimize_clicked(self):
        self.windowMinimizeRequested.emit()

    def on_maximize_clicked(self):
        self.windowMaximizeRequested.emit()

    def on_close_clicked(self):
        self.windowCloseRequested.emit()

    # Window dragging support
    def mousePressEvent(self, event):
        if event.button() == Qt.LeftButton:
            self._pressing = True
            self._start_pos = event.globalPosition().toPoint()

    def mouseMoveEvent(self, event):
        if self._pressing and event.buttons() & Qt.LeftButton:
            parent = self.window()
            if parent:
                delta = event.globalPosition().toPoint() - self._start_pos
                new_pos = parent.pos() + delta
                parent.move(new_pos)
                self._start_pos = event.globalPosition().toPoint()

    def mouseReleaseEvent(self, event):
        self._pressing = False


================================================================================
*** discovery.py ***
### src/pymetr/ui/dialogs/discovery.py ###
================================================================================




================================================================================
*** settings.py ***
### src/pymetr/ui/dialogs/settings.py ###
================================================================================




================================================================================
*** device_tree_view.py ***
### src/pymetr/ui/docks/device_tree_view.py ###
================================================================================

from typing import Dict, Any, Optional
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, 
    QPushButton, QLabel, QHeaderView, QSizePolicy
)
from PySide6.QtCore import Signal, Qt
from pyqtgraph.parametertree import Parameter, ParameterTree

from pymetr.models.device import Device
from pymetr.ui.views.base import BaseWidget
from pymetr.core.logging import logger

class DeviceTreeView(BaseWidget):
    """
    Widget for device control and monitoring.
    Uses a ParameterTree for property control and updates.
    """
    
    property_changed = Signal(str, str, object)  # model_id, prop_path, value
    
    def __init__(self, state, model_id: Optional[str], parent=None):
        super().__init__(state, parent)
        self.state = state
        self._parameter_tree = None
        self._parameters: Dict[str, Parameter] = {}
        self._setup_ui()

        # Listen for instrument connection signals.
        self.state.instrument_connected.connect(self._on_instrument_connected)
        
        if model_id:
            self.set_model(model_id)

    def _setup_ui(self):
        """Initialize the UI components."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Create control bar.
        control_bar = QWidget()
        control_layout = QHBoxLayout(control_bar)
        control_layout.setContentsMargins(4, 4, 4, 4)
        
        self.connect_button = QPushButton("Connect")
        self.connect_button.clicked.connect(self._handle_connect_click)
        control_layout.addWidget(self.connect_button)
        
        self.status_label = QLabel()
        control_layout.addWidget(self.status_label)
        
        control_layout.addStretch()
        layout.addWidget(control_bar)
        
        # Create ParameterTree widget.
        self._parameter_tree = ParameterTree()
        self._parameter_tree.setAlternatingRowColors(False)
        header = self._parameter_tree.header()
        header.setMinimumSectionSize(100)
        header.setDefaultSectionSize(120)
        header.setStretchLastSection(True)
        header.setSectionResizeMode(0, QHeaderView.Interactive)
        header.setSectionResizeMode(1, QHeaderView.Interactive)
        
        self._parameter_tree.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self._parameter_tree.setMinimumWidth(200)
        self._parameter_tree.setColumnWidth(0, 120)
        self._parameter_tree.setColumnWidth(1, 120)
        layout.addWidget(self._parameter_tree)

    def _on_instrument_connected(self, device_id: str):
        logger.debug(f"DeviceTreeView received instrument_connected signal for device ID: {device_id}")
        self.set_model(device_id)

    def _handle_model_property_changed(self, model_id, model_type, prop, value):
        if prop == 'parameter_tree':
            self.update_from_model(self.model)

    def _handle_property_update(self, prop: str, value: Any):
        if prop == 'is_connected':
            self._update_connection_state(value)
        elif prop == 'error_message':
            self._update_error_state(value)
        elif prop in self._parameters:
            param = self._parameters[prop]
            param.setValue(value, blockSignal=self._handle_parameter_change)

    def _update_connection_state(self, is_connected: bool):
        self._parameter_tree.setEnabled(is_connected)
        if is_connected:
            self.connect_button.setText("Disconnect")
            self.status_label.setText("Connected")
            self.status_label.setStyleSheet("color: #2ECC71;")
        else:
            self.connect_button.setText("Connect")
            self.status_label.setText("Disconnected")
            self.status_label.setStyleSheet("color: #95A5A6;")

    def _update_error_state(self, error: Optional[str]):
        if error:
            self.status_label.setText(f"Error: {error}")
            self.status_label.setStyleSheet("color: #E74C3C;")

    def _handle_connect_click(self):
        if not self.model:
            return
        if self.model.get_property('is_connected'):
            self.model.disconnect()
        else:
            self.model.connect()

    def _handle_parameter_change(self, param: Parameter, value: Any):
        if self.model and not param.opts.get('readonly', False):
            prop_path = param.opts.get('property_path')
            if prop_path:
                self.model.update_parameter(prop_path, value)

    def update_from_model(self, model: Device):
        if not model:
            return
        
        logger.debug("DeviceTreeView.update_from_model: Updating view from model data.")
        # Retrieve the UI-friendly parameter tree from the device.
        instrument_config = model.get_property('parameter_tree', [])
        logger.debug("DeviceTreeView.update_from_model: Retrieved instrument_config: %s", instrument_config)
        
        # Expect instrument_config to be a list (as produced by the factory).
        if instrument_config and isinstance(instrument_config, list):
            # Use the first group as the root.
            root_data = instrument_config[0]
            logger.debug("DeviceTreeView.update_from_model: Using first group as root: %s", root_data)
        else:
            root_data = {'children': []}
            logger.debug("DeviceTreeView.update_from_model: No valid instrument_config found; using empty root.")
        
        root = Parameter.create(
            name=model.get_property('name', 'Device'),
            type='group',
            children=root_data.get('children', [])
        )
        logger.debug("DeviceTreeView.update_from_model: Created root parameter: %s", root)
        
        self._parameters.clear()
        for param in root.children():
            self._store_parameters(param)
            logger.debug("DeviceTreeView.update_from_model: Stored parameter: %s", param)
        
        self._parameter_tree.setParameters(root)
        logger.debug("DeviceTreeView.update_from_model: Set parameters in the tree widget.")
        
        root.sigTreeStateChanged.connect(self._handle_tree_state_changed)
        logger.debug("DeviceTreeView.update_from_model: Connected root sigTreeStateChanged signal.")
        
        is_connected = model.get_property('is_connected', False)
        self._update_connection_state(is_connected)
        logger.debug("DeviceTreeView.update_from_model: Updated connection state to %s.", is_connected)
        
        error = model.get_property('error_message')
        if error:
            self._update_error_state(error)
            logger.debug("DeviceTreeView.update_from_model: Updated error state with error: %s", error)

    def _store_parameters(self, param: Parameter):
        if not param.hasChildren():
            prop_path = param.opts.get('property_path')
            if prop_path:
                self._parameters[prop_path] = param
        else:
            for child in param.children():
                self._store_parameters(child)

    def _handle_tree_state_changed(self, param: Parameter, changes):
        for param, change, data in changes:
            if change == 'value':
                self._handle_parameter_change(param, data)

    def _update_parameters(self, parameters: Dict[str, Any]):
        for path, value in parameters.items():
            if path in self._parameters:
                param = self._parameters[path]
                param.setValue(value, blockSignal=self._handle_parameter_change)



================================================================================
*** test_tree_view.py ***
### src/pymetr/ui/docks/test_tree_view.py ###
================================================================================

from typing import Dict, Any, Optional, TypeVar
from pathlib import Path
from PySide6.QtWidgets import (
    QHeaderView, QSizePolicy, QVBoxLayout, QAbstractItemView
)
from PySide6.QtCore import Signal, Qt, QTimer
from PySide6.QtGui import QIcon

import pyqtgraph.parametertree as pt
from pyqtgraph.parametertree import Parameter, ParameterTree

from ..parameters.device_parameter import DeviceParameter
from ..parameters.trace_parameter import TraceParameter
from ..parameters.plot_parameter import PlotParameter
from ..parameters.marker_parameter import MarkerParameter
from ..parameters.cursor_parameter import CursorParameter
from ..parameters.data_table_parameter import DataTableParameter
from ..parameters.test_script_parameter import TestScriptParameter
from ..parameters.test_result_parameter import TestResultParameter
from ..parameters.test_suite_parameter import TestSuiteParameter
from ..parameters.base import ModelParameter

from .base import BaseWidget
from pymetr.core.logging import logger
from pymetr.models.base import BaseModel

T = TypeVar('T', bound=BaseModel)

class ModelTreeView(BaseWidget):
    """
    Tree view for displaying and controlling model hierarchy.
    Implements observer pattern for state updates and provides
    efficient update batching.
    """
    
    # Register parameter types
    PARAMETER_TYPES = {
        'device': DeviceParameter,
        'trace': TraceParameter,
        'plot': PlotParameter,
        'marker': MarkerParameter,
        'cursor': CursorParameter,
        'datatable': DataTableParameter,
        'testscript': TestScriptParameter,
        'testresult': TestResultParameter,
        'testsuite': TestSuiteParameter  # Add TestSuite parameter type
    }
    
    # Register parameter types with pyqtgraph
    for name, cls in PARAMETER_TYPES.items():
        pt.registerParameterType(name, cls)
    
    # Signals
    selection_changed = Signal(str)  # Emits selected model_id
    
    # Model type icons
    MODEL_ICONS = {
        'TestSuite': 'test_suite.png',  # Add TestSuite icon
        'TestScript': 'script.png',
        'TestResult': 'result.png',
        'TestGroup': 'folder.png',
        'Device': 'instruments.png',
        'Plot': 'chart.png',
        'Trace': 'waves.png',
        'Cursor': 'cursor.png',
        'Marker': 'markers.png',
        'DataTable': 'table.png',
        'Measurement': 'measure.png',
        'default': 'file_open.png'
    }

    def __init__(self, state, parent=None):
        super().__init__(state, parent)
        
        # Item tracking
        self._items: Dict[str, Parameter] = {}
        self._icon_cache: Dict[str, QIcon] = {}
        
        # Update batching
        self._pending_updates: Dict[str, Dict[str, Any]] = {}
        self._update_timer = QTimer(self)
        self._update_timer.setSingleShot(True)
        self._update_timer.timeout.connect(self._process_pending_updates)
        self._throttle_interval = 33  # ~30fps
        
        # Set up UI and connect signals
        self._setup_ui()
        self._connect_signals()
        self._preload_icons()
    
    def _setup_ui(self):
        """Initialize UI with optimized settings."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        self.tree = ParameterTree(self)
        self.tree.setAlternatingRowColors(False)
        self.tree.setSelectionMode(QAbstractItemView.SingleSelection)
        
        # Configure header
        header = self.tree.header()
        header.setMinimumSectionSize(120)
        header.setDefaultSectionSize(150)
        header.setStretchLastSection(True)
        header.setVisible(False)
        
        # Set size policies
        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.tree.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        
        # Create root parameter
        self.root = Parameter.create(name='Session', type='group', children=[])
        self.tree.setParameters(self.root, showTop=False)
        
        layout.addWidget(self.tree)
    
    def _connect_signals(self):
        """Connect to state signals for updates."""
        # Tree selection
        self.tree.itemSelectionChanged.connect(self._handle_selection_changed)
        
        # State signals
        self.state.model_registered.connect(self._handle_model_registered)
        self.state.models_linked.connect(self._handle_models_linked)
        self.state.model_changed.connect(self._queue_model_change)
        self.state.model_removed.connect(self._handle_model_removed)
    
    def _preload_icons(self):
        """Preload and cache icons for efficiency."""
        try:
            icons_path = Path(__file__).parent.parent / 'icons'
            for model_type, icon_file in self.MODEL_ICONS.items():
                icon_path = str(icons_path / icon_file)
                self._icon_cache[model_type] = QIcon(icon_path)
                logger.debug(f"Loaded icon: {icon_file} for type {model_type} from {icons_path}")
        except Exception as e:
            logger.error(f"Error preloading icons: {e}")
    
    def _get_icon(self, model_type: str) -> QIcon:
        """Get cached icon for model type."""
        return self._icon_cache.get(model_type, self._icon_cache['default'])
    
    def _create_parameter_for_model(self, model: BaseModel) -> Optional[Parameter]:
        """Create appropriate parameter type for model."""
        try:
            # Get model info
            model_type = type(model).__name__
            name = model.get_property('name', 'Unnamed')
            icon = self._get_icon(model_type)
            
            # Base parameter options
            param_opts = {
                'name': model.id,
                'title': name,
                'state': self.state,
                'model_id': model.id,
                'expanded': False,
                'removable': False,
                'renamable': False,
                'icon': icon,
                'default': None
            }
            
            # Create type-specific parameter
            param_type = model_type.lower()
            if param_type in self.PARAMETER_TYPES:
                param_class = self.PARAMETER_TYPES[param_type]
                # Auto-expand suites and scripts
                if param_type in ['testsuite', 'testscript']:
                    param_opts['expanded'] = True
                return param_class(**param_opts)
            
            # Default to group parameter
            param_opts['type'] = 'group'
            return Parameter.create(**param_opts)
            
        except Exception as e:
            logger.error(f"Error creating parameter for model {model.id}-{model_type}-{name}: {e}")
            return None
    
    def _handle_model_registered(self, model_id: str):
        """Handle new model registration."""
        try:
            model = self.state.get_model(model_id)
            if not model:
                return
            
            param = self._create_parameter_for_model(model)
            if param:
                self._items[model_id] = param
                
                # Start batch update if it's a model parameter
                if isinstance(param, ModelParameter):
                    param.begin_update()
                
                # Add to tree
                self.root.addChild(param)
                
                # End batch update
                if isinstance(param, ModelParameter):
                    param.end_update()
                
        except Exception as e:
            logger.error(f"Error registering model {model_id}: {e}")
    
    def _handle_models_linked(self, parent_id: str, child_id: str):
        """Handle model linking."""
        try:
            if parent_id in self._items and child_id in self._items:
                parent_param = self._items[parent_id]
                child_param = self._items[child_id]
                
                if child_param.parent():
                    child_param.remove()
                
                parent_param.addChild(child_param)
                
        except Exception as e:
            logger.error(f"Error linking models: {e}")
    
    def _queue_model_change(self, model_id: str, model_type: str, prop: str, value: Any):
        """Queue model updates for batch processing."""
        if model_id not in self._pending_updates:
            self._pending_updates[model_id] = {}
        self._pending_updates[model_id][prop] = value
        
        if not self._update_timer.isActive():
            self._update_timer.start(self._throttle_interval)
    
    def _process_pending_updates(self):
        """Process all queued model updates."""
        updates = self._pending_updates.copy()
        self._pending_updates.clear()
        
        for model_id, props in updates.items():
            if model_id in self._items:
                param = self._items[model_id]
                
                # Start batch update
                if isinstance(param, ModelParameter):
                    param.begin_update()
                
                # Apply updates
                for prop, value in props.items():
                    if hasattr(param, 'handle_property_update'):
                        param.handle_property_update(prop, value)
                
                # End batch update
                if isinstance(param, ModelParameter):
                    param.end_update()
    
    def _handle_model_removed(self, model_id: str):
        """Clean up when a model is removed."""
        if model_id in self._items:
            param = self._items[model_id]
            
            # Recursively cleanup child parameters
            def cleanup_parameter(p):
                try:
                    for child in p.children():
                        cleanup_parameter(child)
                    if hasattr(p, 'cleanup'):
                        p.cleanup()
                except Exception as e:
                    logger.error(f"Error cleaning up parameter {p.name()}: {e}")
            
            try:
                cleanup_parameter(param)
                param.remove()
                del self._items[model_id]
                
            except Exception as e:
                logger.error(f"Error removing tree item for {model_id}: {e}")
    
    def _handle_selection_changed(self):
        """Handle tree selection changes."""
        try:
            selected = self.tree.selectedItems()
            if not selected or not selected[0].param:
                return
            
            param = selected[0].param
            model_id = getattr(param, 'model_id', param.name())
            
            model = self.state.get_model(model_id)
            if not model:
                return
            
            # Find viewable parent if needed
            if not hasattr(model, 'show'):
                parent = self._find_viewable_parent(model_id)
                if not parent:
                    return
                model = parent
            
            # Show view and emit selection
            model.show()
            self.selection_changed.emit(model.id)
            
        except Exception as e:
            logger.error(f"Error handling selection change: {e}")
    
    def _find_viewable_parent(self, model_id: str) -> Optional[BaseModel]:
        """Find first parent that has a view."""
        parent = self.state.get_parent(model_id)
        while parent:
            if hasattr(parent, 'show'):
                return parent
            parent = self.state.get_parent(parent.id)
        return None
    
    def cleanup(self):
        """Clean up resources."""
        try:
            # Stop timer
            self._update_timer.stop()
            
            # Clean up items
            for item in list(self._items.values()):
                if hasattr(item, 'cleanup'):
                    item.cleanup()
            self._items.clear()
            
            # Clear caches
            self._icon_cache.clear()
            self._pending_updates.clear()
            
        except Exception as e:
            logger.error(f"Error cleaning up tree view: {e}")


================================================================================
*** instrument.py ***
### src/pymetr/ui/factories/instrument.py ###
================================================================================

import json
import os
import ast
from pymetr.core.logging import logger
from .visitor import InstrumentVisitor

class InstrumentFactory:
    def __init__(self):
        self.current_instrument = None

    def create_instrument_data_from_driver(self, path: str) -> dict:
        """
        Reads the driver source code from the given file path,
        extracts the raw instrument data model using the visitor,
        and then transforms that data model into a UI configuration.
        """
        logger.debug(f"Building UI configuration from driver source: {path}")
        with open(path, 'r') as file:
            source = file.read()
        return self.create_ui_configuration_from_source(source)

    def create_ui_configuration_from_source(self, source: str) -> dict:
        """
        Accepts driver source code as a string, builds the raw instrument data model,
        and converts it into a UI-friendly configuration.
        """
        visitor = InstrumentVisitor()
        # Build the raw data model from the source code.
        instrument_data_model = visitor.build_instrument_data_model(source)
        logger.debug(f"Raw instrument data model: {json.dumps(instrument_data_model, indent=2)}")
        
        # Convert the raw model into UI-friendly structures.
        parameter_tree_dict = self.generate_parameter_tree_dict(instrument_data_model)
        gui_methods_dict = self.generate_gui_methods_dict(instrument_data_model)
        other_methods_dict = self.generate_other_methods_dict(instrument_data_model)
        sources_list = self.generate_sources_list(instrument_data_model)
        
        return {
            'parameter_tree': parameter_tree_dict,
            'gui_methods': gui_methods_dict,
            'other_methods': other_methods_dict,
            'sources': sources_list
        }

    def set_current_instrument(self, instrument):
        self.current_instrument = instrument
        logger.debug(f"Current instrument set to: {self.current_instrument}")

    def parse_source_file(self, path: str) -> dict:
        logger.debug(f"Initiating parse of source file: {path}")
        with open(path, 'r') as file:
            source = file.read()
        tree = ast.parse(source, filename=path)
        visitor = InstrumentVisitor()
        visitor.visit(tree)
        logger.debug(f"Completed parsing. Extracted instruments: {list(visitor.instruments.keys())}")
        return visitor.instruments

    def generate_gui_methods_dict(self, instrument_data: dict) -> dict:
        logger.info(" Generating the GUI methods dictionary... ")
        gui_methods_dict = {}
        for class_name, class_info in instrument_data.items():
            for method_name, method_info in class_info.get('gui_methods', {}).items():
                gui_methods_dict[method_name] = method_info
        logger.info(" Finished generating the GUI methods dictionary ")
        return gui_methods_dict

    def generate_other_methods_dict(self, instrument_data: dict) -> dict:
        logger.info(" Generating the other methods dictionary... ")
        other_methods_dict = {}
        for class_name, class_info in instrument_data.items():
            for method_name, method_info in class_info.get('other_methods', {}).items():
                other_methods_dict[method_name] = method_info
        logger.info(" Finished generating the other methods dictionary ")
        return other_methods_dict

    def generate_sources_list(self, instrument_data: dict) -> list:
        logger.info(" Generating sources list... ")
        for class_name, class_info in instrument_data.items():
            if 'sources' in class_info:
                logger.info(f" Sources found for {class_name}: {class_info['sources']} ")
                return class_info['sources']
        logger.warning(" No sources found in the instrument data ")
        return []

    def generate_properties_list(self, properties: list, class_name: str, index: int = None, subsystem: str = None) -> list:
        logger.debug(f" Generating properties list for class '{class_name}' with index '{index}'.")
        properties_list = []
        for prop in properties:
            param_dict = self.construct_param_dict(prop, class_name, index, subsystem=subsystem)
            if param_dict is not None:
                properties_list.append(param_dict)
                logger.debug(f" Added property '{prop.get('name')}' with path '{param_dict.get('property_path')}'.")
        logger.debug(f" Finished generating properties list for '{class_name}': Total properties {len(properties_list)}.")
        return properties_list

    def construct_param_dict(self, prop: dict, class_name: str, index: int = None, subsystem: str = None) -> dict:
        logger.debug(f" Constructing parameter dict for '{prop.get('name')}' in '{class_name}'")
        # Build a UI-friendly property path.
        property_path = f"{class_name.lower()}"
        if subsystem and subsystem.lower() != class_name.lower():
            property_path += f".{subsystem.lower()}"
        if index is not None:
            property_path += f"[{index}]"
            logger.debug(f" Index provided. Appended to property path: [{index}] ")
        property_path += f".{prop.get('name')}"
        logger.debug(f" Property path constructed: {property_path}")

        original_type = prop.get('type', '')
        ui_type = original_type.lower()
        if ui_type == "valueproperty":
            ui_type = "float"
        elif ui_type == "selectproperty":
            ui_type = "list"
        elif ui_type == "switchproperty":
            ui_type = "bool"
        elif ui_type == "stringproperty":
            ui_type = "str"
        param_dict = {
            'name': prop.get('name'),
            'type': ui_type,
            'property_path': property_path,
            'value': None,
            'default': None,
            'readonly': prop.get('access', 'read-write') == 'read',
        }

        if original_type.lower() == 'selectproperty':
            choices = prop.get('choices')
            param_dict.update({
                'type': 'list',
                'limits': choices,
                'value': choices[0] if choices and len(choices) > 0 else None
            })
        elif original_type.lower() == 'valueproperty':
            param_dict.update({
                'type': ui_type,
                'limits': prop.get('range'),
                'value': 0.0
            })
        elif original_type.lower() == 'switchproperty':
            param_dict.update({
                'type': 'bool',
                'value': False
            })
        elif original_type.lower() == 'stringproperty':
            param_dict.update({
                'type': 'str',
                'value': ''
            })
        elif original_type.lower() == 'dataproperty':
            # Skip DataProperty for now.
            return None

        if 'units' in prop:
            param_dict['suffix'] = prop['units']
            param_dict['siPrefix'] = bool(prop['units'])
            logger.debug(f" Setting units for '{prop.get('name')}' to '{prop.get('units')}' ")
        else:
            logger.debug(f" No units found for '{prop.get('name')}' during construction ")

        logger.debug(f" Constructed parameter dict for '{prop.get('name')}': {param_dict} ")
        return param_dict

    def generate_parameter_tree_dict(self, instrument_data: dict) -> list:
        """
        Generates a parameter tree structure (as a list of dictionaries) from the instrument data.
        This structure is meant to be passed to pyqtgraph's Parameter.create().
        """
        logger.debug(" Starting to generate the parameter tree... ")
        tree_dict = []
        for class_name, class_info in instrument_data.items():
            logger.debug(f" Processing class: {class_name}")
            # Create a group for the instrument.
            class_group = {
                'name': class_name,
                'type': 'group',
                'children': []
            }
            # Add a Sources group.
            sources_group = {
                'name': 'Sources',
                'type': 'group',
                'children': []
            }
            sources_list = class_info.get('sources', [])
            for source in sources_list:
                source_param = {
                    'name': source,
                    'type': 'bool',
                    'value': False,
                    'default': None
                }
                sources_group['children'].append(source_param)
            class_group['children'].append(sources_group)
            # Add top-level properties (if any).
            props = class_info.get('properties', [])
            if props:
                props_group = {
                    'name': 'Properties',
                    'type': 'group',
                    'children': self.generate_properties_list(props, class_name)
                }
                class_group['children'].append(props_group)
            # Add each subsystem as its own group.
            for subsystem_name, subsystem_info in class_info.get('subsystems', {}).items():
                logger.debug(f" Creating subsystem group: {subsystem_name}")
                subsystem_group = self.create_subsystem_group(subsystem_name, subsystem_info)
                class_group['children'].append(subsystem_group)
            tree_dict.append(class_group)
            logger.debug(f" Added class group: {class_name} to the tree ")
        logger.debug(f" Generated parameter tree dictionary: {json.dumps(tree_dict, indent=2)} ")
        logger.debug(" Finished generating the parameter tree ")
        return tree_dict

    def create_subsystem_group(self, subsystem_name, subsystem_info: dict) -> dict:
        logger.debug(f" Starting to create subsystem group for: {subsystem_name}")
        if subsystem_info.get('needs_indexing', False):
            logger.debug(f" {subsystem_name} requires indexing ")
            parent_group = {
                'name': subsystem_name,
                'type': 'group',
                'children': []
            }
            # If 'instances' is empty, create groups based on the 'indices' value.
            instances = subsystem_info.get('instances', {})
            if not instances:
                indices = subsystem_info.get('indices', 1)
                for i in range(1, indices + 1):
                    indexed_group = {
                        'name': f"{subsystem_name}{i}",
                        'type': 'group',
                        'children': self.generate_properties_list(subsystem_info.get('properties', []), subsystem_name)
                    }
                    parent_group['children'].append(indexed_group)
                    logger.debug(f" Added indexed group for {subsystem_name}{i} ")
            else:
                for index, instance_info in instances.items():
                    indexed_group = {
                        'name': f"{subsystem_name}{index}",
                        'type': 'group',
                        'children': self.generate_properties_list(instance_info.get('properties', []), subsystem_name, index=index)
                    }
                    parent_group['children'].append(indexed_group)
                    logger.debug(f" Added indexed group for {subsystem_name}{index} ")
            logger.debug(f" Completed indexed groups for {subsystem_name} ")
            return parent_group
        else:
            logger.debug(f" Creating group for non-indexed subsystem: {subsystem_name} ")
            group = {
                'name': subsystem_name,
                'type': 'group',
                'children': self.generate_properties_list(subsystem_info.get('properties', []), subsystem_name)
            }
            logger.debug(f" Finished creating group for non-indexed subsystem: {subsystem_name} ")
            return group

if __name__ == "__main__":
    factory = InstrumentFactory()
    # Construct the path relative to this file.
    current_dir = os.path.dirname(os.path.abspath(__file__))
    path = os.path.join(current_dir, '..', 'drivers', 'instruments', 'hs9000.py')
    path = os.path.abspath(path)
    instrument_data = factory.create_instrument_data_from_driver(path)
    print(json.dumps(instrument_data, indent=2))
    print(instrument_data)



================================================================================
*** analysis_dual_parameter.py ***
### src/pymetr/ui/parameters/analysis_dual_parameter.py ###
================================================================================

from typing import Optional, Any, Dict
from PySide6.QtWidgets import (
    QWidget, QHBoxLayout, QLabel, QComboBox, 
    QPushButton, QMenu
)
from PySide6.QtCore import Qt
from PySide6.QtGui import QPainter, QColor, QBrush, QPen

from pyqtgraph.parametertree import Parameter
from pymetr.models.device.device_model import Device, AcquisitionMode
from pymetr.core.logging import logger
from ..base.base_parameter import ModelParameter, ModelParameterItem, ParameterWidget

class DualAnalysisParameter(AnalysisParameter):
    """Parameter for dual-trace analysis with trace selection."""
    def __init__(self, **opts):
        super().__init__(**opts)
        self.setupParameters()

    def setupParameters(self):
        # Add trace selection parameters
        traces = [
            {'name': t.name, 'id': t.id}
            for t in self.state.get_models_by_type('Trace')
            if t.visible
        ]

        self.addChild({
            'name': 'Reference Trace',
            'type': 'list',
            'values': [t['name'] for t in traces],
            'value': traces[0]['name'] if traces else '',
            'readonly': True
        })


================================================================================
*** analysis_parameter.py ***
### src/pymetr/ui/parameters/analysis_parameter.py ###
================================================================================

from typing import Optional, Any, Dict
from PySide6.QtWidgets import (
    QWidget, QHBoxLayout, QLabel, QComboBox, 
    QPushButton, QMenu
)
from PySide6.QtCore import Qt
from PySide6.QtGui import QPainter, QColor, QBrush, QPen

from pyqtgraph.parametertree import Parameter
from pymetr.models.device.device_model import Device, AcquisitionMode
from pymetr.core.logging import logger
from ..base.base_parameter import ModelParameter, ModelParameterItem, ParameterWidget

class AnalysisParameter(ModelParameter):
    """Base parameter for analysis models."""
    
    ICONS = {
        'Analysis': 'science',  # Base analysis icon
        'TimeMeasurement': 'timer',  # For timing measurements
        'PeakSearch': 'signal_cellular_4_bar',  # For peak detection
        'FFT': 'wave', # For FFT analysis
        'CrossSpectrum': 'compare_arrows',  # For cross-spectral
        'PeriodMeasurement': 'repeat',  # For period/frequency
        'PeakToPeak': 'height',  # For amplitude measurements
        'EdgeMeasurement': 'trending_up',  # For edge timing
        'TraceMath': 'functions',  # For trace math operations
    }

    def __init__(self, **opts):
        opts['type'] = 'analysis'
        super().__init__(**opts)
        self.can_export = True  # Allow analysis results to be exported

class AnalysisStatusWidget(ParameterWidget):
    """Widget showing analysis result/status."""
    def __init__(self, param, parent=None):
        super().__init__(param, parent)
        self._setup_ui()

    def _setup_ui(self):
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        
        # Result label
        self.result_label = QLabel()
        self.result_label.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        
        # Status indicator (could be colored dot/icon)
        self.status_indicator = QLabel()
        self.status_indicator.setFixedSize(8, 8)
        self.status_indicator.setStyleSheet(
            "background-color: #4CAF50; border-radius: 4px;"
        )
        
        layout.addWidget(self.status_indicator)
        layout.addWidget(self.result_label)
        layout.addStretch()

    def _process_pending_update(self):
        """Update display with latest results."""
        try:
            model = self.param.state.get_model(self.param.model_id)
            if not model:
                return

            # Example result formatting based on analysis type
            if isinstance(model, PeriodMeasurement):
                period = abs(model._x2.position - model._x1.position)
                self.result_label.setText(f"{period:.2e}s")
            elif isinstance(model, PeakToPeak):
                pp = abs(model._y_max.position - model._y_min.position)
                self.result_label.setText(f"{pp:.2f}V")
            elif isinstance(model, FFT):
                freq = model._peak.x
                mag = model._peak.y
                self.result_label.setText(f"{freq:.1f}Hz @ {mag:.1f}dB")
                
            # Update status indicator
            self.status_indicator.setStyleSheet(
                "background-color: #4CAF50; border-radius: 4px;"  # Green for valid
            )

        except Exception as e:
            logger.error(f"Error updating analysis status: {e}")
            # Show error state
            self.status_indicator.setStyleSheet(
                "background-color: #F44336; border-radius: 4px;"  # Red for error
            )


================================================================================
*** base.py ***
### src/pymetr/ui/parameters/base.py ###
================================================================================

from pathlib import Path
from typing import Optional, Dict, Any
from PySide6.QtWidgets import QWidget, QMenu, QInputDialog, QFileDialog
from PySide6.QtCore import QTimer
from PySide6.QtGui import QIcon
from pyqtgraph.parametertree import Parameter, ParameterItem

from pymetr.services.file_services import FileService
from pymetr.core.logging import logger


class ParameterWidget(QWidget):
    """Base class for parameter widgets."""
    
    def __init__(self, param, parent=None):
        super().__init__(parent)
        self.param = param
        
        # Update throttling
        self._update_timer = QTimer(self)
        self._update_timer.setSingleShot(True)
        self._update_timer.timeout.connect(self._process_pending_update)
        self._pending_updates: Dict[str, Any] = {}
        self._throttle_interval = 200  # ~30fps
    
    def _setup_ui(self):
        """Set up the widget UI."""
        raise NotImplementedError("Subclass must implement _setup_ui()")
    
    def _process_pending_update(self):
        """Process pending updates."""
        raise NotImplementedError("Subclass must implement _process_pending_update()")
    
    def queue_update(self, **kwargs):
        """Queue updates with throttling."""
        # logger.debug(f"Queueing update for {self.param.title()}: {kwargs}")
        self._pending_updates.update(kwargs)
        if not self._update_timer.isActive():
            self._update_timer.start(self._throttle_interval)
    
    def cleanup(self):
        """Clean up resources."""
        logger.debug(f"Cleaning up ParameterWidget for {self.param.title()}")
        self._update_timer.stop()

    def isDeleted(self):
        """Check if widget has been deleted."""
        try:
            return not self.isVisible()  # This will raise an error if widget is deleted
        except RuntimeError:
            return True


class ModelParameterItem(ParameterItem):
    """
    Base class for all model parameter items. Methods marked with
    NotImplementedError must be implemented by subclasses.
    """
    
    def __init__(self, param, depth, **kwargs):
        # logger.debug(f"Initializing ModelParameterItem for {param.title()}")
        super().__init__(param, depth, **kwargs)
        self.hideWidget = False
        self.widget = None
        self._context_icons = self._load_context_icons()

    def optsChanged(self, param, changes):
        # logger.debug(f"optsChanged called for parameter {param.title()} with changes: {changes}")
        # changes is typically a list of (propertyName, changeType, data)
        for change in changes:
            propName, changeType, data = change
            if propName == 'icon' and (changeType in ('value', 'childAdded')):
                # logger.debug(f"Setting icon for {param.title()}: {data}")
                self.setIcon(data)  # Tell the item to display the icon
        
        super().optsChanged(param, changes)

    def treeWidgetChanged(self) -> None:
        super().treeWidgetChanged()
        
        # Set icon from parameter options if available
        icon = self.param.opts.get('icon')
        if icon is not None:
            self.setIcon(0, icon)
        
        if self.widget is None:
            self.widget = self.makeWidget()
            # Attach the widget to the parameter so that later calls to handle_property_update can find it.
            self.param.widget = self.widget
        tree = self.treeWidget()
        if tree is not None:
            tree.setItemWidget(self, 1, self.widget)

    def makeWidget(self) -> Optional[QWidget]:
        """Create and return the control widget."""
        logger.error("makeWidget() not implemented for parameter %s", self.param.title())
        raise NotImplementedError("Subclass must implement makeWidget()")
    
    def updateWidget(self, **kwargs):
        """Update the widget with new values."""
        logger.error("updateWidget() not implemented for parameter %s", self.param.title())
        raise NotImplementedError("Subclass must implement updateWidget()")
    
    def _load_context_icons(self) -> Dict[str, QIcon]:
        """Load standard context menu icons."""
        # logger.debug("Loading context icons")
        try:
            icons_path = Path(__file__).parent.parent / 'icons'
            icons = {
                'edit': QIcon(str(icons_path / 'edit.png')),
                'delete': QIcon(str(icons_path / 'delete.png')),
                'export': QIcon(str(icons_path / 'export.png')),
                'refresh': QIcon(str(icons_path / 'refresh.png'))
            }
            # logger.debug(f"Context icons loaded: {list(icons.keys())}")
            return icons
        except Exception as e:
            logger.error(f"Error loading context icons: {e}")
            return {}
    
    def contextMenuEvent(self, ev) -> None:
        """Standard context menu with extensibility."""
        logger.debug("contextMenuEvent triggered")
        try:
            menu = QMenu()
            
            # Add parameter-specific actions first
            self.addCustomContextActions(menu)
            
            # Add standard actions
            self.addStandardContextActions(menu)
            
            menu.exec_(ev.globalPos())
        except Exception as e:
            logger.error(f"Error showing context menu: {e}")
    
    def addCustomContextActions(self, menu: QMenu):
        """Add parameter-specific context menu actions."""
        logger.error("addCustomContextActions() not implemented for parameter %s", self.param.title())
        raise NotImplementedError("Subclass must implement addCustomContextActions()")
    
    def addStandardContextActions(self, menu: QMenu):
        """Add standard context menu actions."""
        if not self._context_icons:
            logger.debug("No context icons available for %s", self.param.title())
            return
            
        # Rename action
        rename_action = menu.addAction(
            self._context_icons.get('edit'),
            "Rename"
        )
        rename_action.triggered.connect(self._handleRename)
        
        menu.addSeparator()
        
        # Remove action
        remove_action = menu.addAction(
            self._context_icons.get('delete'),
            "Remove"
        )
        remove_action.triggered.connect(self._handleRemove)
        
        # Export action if supported
        if hasattr(self.param, 'can_export') and self.param.can_export:
            export_action = menu.addAction(
                self._context_icons.get('export'),
                "Export"
            )
            export_action.triggered.connect(self._handleExport)
    
    def _handleRename(self):
        """Handle rename action."""
        logger.debug("Rename action triggered for %s", self.param.title())
        if not hasattr(self.param, 'state') or not hasattr(self.param, 'model_id'):
            logger.debug("Parameter %s missing state or model_id", self.param.title())
            return
        try:
            model = self.param.state.get_model(self.param.model_id)
            if not model:
                logger.debug("No model found for %s", self.param.model_id)
                return
            current_name = model.get_property('name', '')
            new_name, ok = QInputDialog.getText(
                None, 
                "Rename",
                "Enter new name:",
                text=current_name
            )
            if ok and new_name and new_name != current_name:
                logger.debug("Renaming %s from '%s' to '%s'", self.param.title(), current_name, new_name)
                model.set_property('name', new_name)
        except Exception as e:
            logger.error(f"Error renaming parameter: {e}")
    
    def _handleRemove(self):
        """Handle remove action."""
        logger.debug("Remove action triggered for %s", self.param.title())
        if hasattr(self.param, 'remove_model'):
            self.param.remove_model()
    
    def _handleExport(self):
        """Handle export action."""
        logger.debug("Export action triggered for %s", self.param.title())
        if not hasattr(self.param, 'state') or not hasattr(self.param, 'model_id'):
            logger.debug("Parameter %s missing state or model_id", self.param.title())
            return
        try:
            path, _ = QFileDialog.getSaveFileName(
                None, "Export Data", "", "YAML Files (*.yaml)"
            )
            if path:
                FileService.export_model_data(
                    self.param.model_id,
                    self.param.state,
                    Path(path)
                )
        except Exception as e:
            logger.error(f"Error exporting parameter data: {e}")
    
    def cleanup(self):
        """Clean up resources."""
        logger.debug("Cleaning up ModelParameterItem for %s", self.param.title())
        try:
            if self.widget:
                self.widget.cleanup()
                self.widget.deleteLater()
                self.widget = None
            self._context_icons.clear()
        except Exception as e:
            logger.error(f"Error cleaning up parameter item: {e}")

class ModelParameter(Parameter):
    """Base class for model parameters."""
    
    def __init__(self, **opts):
        # Store state and model info
        self.state = opts.get('state')
        self.model_id = opts.get('model_id')
        self.can_export = opts.get('can_export', False)
        
        # Batch update support
        self._batch_mode = False
        self._pending_updates: Dict[str, Any] = {}
        
        # Get model type for type-safe updates
        model = self.state.get_model(self.model_id) if self.state and self.model_id else None
        if model:
            self.model_type = model.model_type
        else:
            self.model_type = None
        
        super().__init__(**opts)
    
    def setupParameters(self, model):
        """Set up child parameters based on model."""
        raise NotImplementedError("Subclass must implement setupParameters()")
    
    def begin_update(self):
        """Begin batch update mode."""
        self._batch_mode = True
        self._pending_updates.clear()
    
    def end_update(self):
        """End batch update mode and apply updates."""
        updates = self._pending_updates.copy()
        self._batch_mode = False
        self._pending_updates.clear()
        for name, value in updates.items():
            self.set_model_property(name, value)
    
    def set_model_property(self, name: str, value: Any):
        """Set a model property with batch support."""
        if self._batch_mode:
            self._pending_updates[name] = value
            return
        if self.state and self.model_id:
            model = self.state.get_model(self.model_id)
            if model:
                model.set_property(name, value)
    
    def get_model_property(self, name: str, default: Any = None) -> Any:
        """Get a model property."""
        if self.state and self.model_id:
            model = self.state.get_model(self.model_id)
            if model:
                return model.get_property(name, default)
        return default
    
    def remove_model(self):
        """Remove the model with cleanup."""
        if not hasattr(self, 'state') or not hasattr(self, 'model_id'):
            return
        try:
            model = self.state.get_model(self.model_id)
            if model:
                parent = self.state.get_parent(self.model_id)
                if parent:
                    self.state.unlink_models(parent.id, self.model_id)
                self.state.remove_model(self.model_id)
        except Exception as e:
            logger.error(f"Error removing model: {e}")




================================================================================
*** cursor_parameter.py ***
### src/pymetr/ui/parameters/cursor_parameter.py ###
================================================================================

from typing import Optional, Any
from PySide6.QtWidgets import QWidget, QHBoxLayout, QLabel, QMenu
from PySide6.QtCore import Qt
from PySide6.QtGui import QPainter, QColor, QPen
from pyqtgraph.parametertree import Parameter

from .base import ModelParameter, ModelParameterItem, ParameterWidget
from pymetr.core.logging import logger
from pymetr.models import Cursor

class CursorPreviewWidget(ParameterWidget):
    """
    Widget showing cursor position and line preview.
    """
    def __init__(self, param, parent=None):
        super().__init__(param, parent)
        self._setup_ui()
        
        # Cache current values
        self._current_position = 0.0
        self._current_axis = 'x'  # 'x' for vertical, 'y' for horizontal
        self._current_color = "#ffffff"
        self._current_style = "solid"
        self._current_width = 1
    
    def _setup_ui(self):
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(4)
        
        # Position display
        self.position_label = QLabel()
        self.position_label.setStyleSheet("""
            QLabel {
                color: #dddddd;
                padding: 2px 4px;
                min-width: 80px;
            }
        """)
        
        # Line preview
        self.line_preview = CursorLinePreview()
        
        layout.addWidget(self.position_label)
        layout.addWidget(self.line_preview)
        layout.addStretch()
    
    def _process_pending_update(self):
        """Process style and position updates."""
        updates = self._pending_updates
        self._pending_updates = {}
        
        try:
            # Update position display
            if 'position' in updates or 'axis' in updates:
                pos = updates.get('position', self._current_position)
                axis = updates.get('axis', self._current_axis)
                self._current_position = pos
                self._current_axis = axis
                # Format position display
                axis_label = 'X' if axis == 'x' else 'Y'
                self.position_label.setText(f"{axis_label} = {pos:.4g}")
            
            # Update line preview
            if any(key in updates for key in ['color', 'style', 'width', 'axis']):
                self.line_preview.update_style(
                    updates.get('axis', self._current_axis),
                    updates.get('color', self._current_color),
                    updates.get('style', self._current_style),
                    updates.get('width', self._current_width)
                )
                
        except Exception as e:
            logger.error(f"Error updating cursor preview: {e}")

class CursorLinePreview(QWidget):
    """Widget showing cursor line style preview."""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFixedSize(40, 20)
        
        self._axis = 'x'
        self._color = QColor("#ffffff")
        self._style = Qt.SolidLine
        self._width = 1
    
    def update_style(self, axis: str, color: str, style: str, width: int):
        """Update line style properties."""
        self._axis = axis
        self._color = QColor(color)
        self._style = self._get_qt_line_style(style)
        self._width = width
        self.update()
    
    @staticmethod
    def _get_qt_line_style(style_str: str) -> Qt.PenStyle:
        """Convert string style to Qt PenStyle."""
        styles = {
            'solid': Qt.SolidLine,
            'dash': Qt.DashLine,
            'dot': Qt.DotLine,
            'dashdot': Qt.DashDotLine
        }
        return styles.get(style_str.lower(), Qt.SolidLine)
    
    def paintEvent(self, event):
        try:
            painter = QPainter(self)
            painter.setRenderHint(QPainter.Antialiasing)
            
            # Set up pen
            pen = QPen(self._color)
            pen.setStyle(self._style)
            pen.setWidth(self._width)
            painter.setPen(pen)
            
            # Draw preview line
            if self._axis == 'x':  # Vertical line
                x = self.width() / 2
                painter.drawLine(x, 2, x, self.height() - 2)
            else:  # Horizontal line
                y = self.height() / 2
                painter.drawLine(2, y, self.width() - 2, y)
                
        except Exception as e:
            logger.error(f"Error drawing cursor preview: {e}")

class CursorParameterItem(ModelParameterItem):
    """Parameter item for cursors."""
    
    def makeWidget(self) -> Optional[QWidget]:
        """Create the cursor preview widget."""
        try:
            self.widget = CursorPreviewWidget(self.param)
            return self.widget
        except Exception as e:
            logger.error(f"Error creating cursor widget: {e}")
            return None
    
    def updateWidget(self, **kwargs):
        """Update the preview widget with new values."""
        if self.widget:
            self.widget.queue_update(**kwargs)
    
    def addCustomContextActions(self, menu: QMenu):
        """Add cursor-specific context actions."""
        # Toggle axis action
        model = self.param.state.get_model(self.param.model_id)
        if model:
            current_axis = model.get_property('axis', 'x')
            new_axis = 'y' if current_axis == 'x' else 'x'
            toggle_action = menu.addAction(f"Switch to {new_axis.upper()} axis")
            toggle_action.triggered.connect(
                lambda: self.param.set_model_property('axis', new_axis)
            )

class CursorParameter(ModelParameter):
    """
    Parameter for cursors with line style and position control.
    """
    
    itemClass = CursorParameterItem
    
    def __init__(self, **opts):
        opts['type'] = 'cursor'
        super().__init__(**opts)
        
        model = self.state.get_model(self.model_id) if self.state and self.model_id else None
        self.setupParameters(model)
    
    def setupParameters(self, model: Optional[Cursor]):
        """Set up cursor parameters with flat structure."""
        def get_prop(name, default):
            return model.get_property(name, default) if model else default
        
        # Create parameters
        params = [
            # Position and orientation
            dict(name='position', type='float',
                 value=get_prop('position', 0.0)),
            dict(name='axis', type='list',
                 value=get_prop('axis', 'x'),
                 limits=['x', 'y']),
            dict(name='visible', type='bool',
                 value=get_prop('visible', True)),
            dict(name='label', type='str',
                 value=get_prop('label', '')),
            
            # Line style
            dict(name='color', type='color',
                 value=get_prop('color', '#ffffff')),
            dict(name='style', type='list',
                 value=get_prop('style', 'solid'),
                 limits=['solid', 'dash', 'dot', 'dashdot']),
            dict(name='width', type='int',
                 value=get_prop('width', 1),
                 limits=(1, 5))
        ]
        
        # Add all parameters
        for param_opts in params:
            param = Parameter.create(**param_opts)
            self.addChild(param)
            param.sigValueChanged.connect(self._handle_parameter_change)
    
    def _handle_parameter_change(self, param, value):
        """Handle parameter changes."""
        self.set_model_property(param.name(), value)
    
    def handle_property_update(self, prop: str, value: Any):
        """Handle model property updates."""
        try:
            # Update matching parameter
            param = self.child(prop)
            if param:
                param.setValue(value)
            
            # Update preview widget
            if hasattr(self, 'widget'):
                self.widget.queue_update(**{prop: value})
                
        except Exception as e:
            logger.error(f"Error handling property update: {e}")




================================================================================
*** data_table_parameter.py ***
### src/pymetr/ui/parameters/data_table_parameter.py ###
================================================================================

from typing import Dict, Any, Optional, List
import pandas as pd
from PySide6.QtWidgets import QWidget, QHBoxLayout, QLabel, QMenu
from PySide6.QtCore import Qt
from pyqtgraph.parametertree import Parameter
from pymetr.core.logging import logger

from .base import ModelParameter, ModelParameterItem, ParameterWidget


class DataTableDisplayWidget(ParameterWidget):
    """
    Widget that displays the row and column counts in the format
    "[{row_count}:{column_count}]" in white text.
    """
    def __init__(self, param, parent=None):
        super().__init__(param, parent)
        self._current_counts = {'rows': None, 'cols': None}
        self._setup_ui()

    def _setup_ui(self):
        logger.debug("Setting up DataTableDisplayWidget UI")
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(4)
        
        self.size_label = QLabel()
        self.size_label.setStyleSheet("""
            QLabel {
                color: white;
                padding: 2px 4px;
                font-weight: bold;
            }
        """)
        layout.addWidget(self.size_label)
        layout.addStretch()
        self.setLayout(layout)

    def _process_pending_update(self):
        logger.debug("DataTableDisplayWidget processing pending update")
        self._pending_updates.clear()

        # Get the model from state
        model = (self.param.state.get_model(self.param.model_id)
                 if self.param.state and self.param.model_id else None)
        if model is None:
            logger.debug("DataTableDisplayWidget: No model found")
            return

        # Get the DataFrame
        df = model.get_property("data")
        if not isinstance(df, pd.DataFrame):
            logger.debug("DataTableDisplayWidget: Model data is not a DataFrame")
            return

        # Calculate row and column counts
        row_count = len(df)
        col_count = len(df.columns)
        logger.debug(f"DataTableDisplayWidget: Row count = {row_count}, Col count = {col_count}")

        # Only update the label if counts have changed
        if (row_count != self._current_counts['rows'] or 
            col_count != self._current_counts['cols']):
            self.size_label.setText(f"[{row_count}:{col_count}]")
            self._current_counts['rows'] = row_count
            self._current_counts['cols'] = col_count
            logger.debug("DataTableDisplayWidget label updated")
        else:
            logger.debug("DataTableDisplayWidget: No change in row/col counts")


class DataTableParameterItem(ModelParameterItem):
    """
    Parameter item for the DataTable parameter.
    Creates and attaches the DataTableDisplayWidget.
    """
    def makeWidget(self) -> Optional[QWidget]:
        logger.debug(f"Creating DataTable widget for parameter {self.param.title()}")
        try:
            self.widget = DataTableDisplayWidget(self.param)
            return self.widget
        except Exception as e:
            logger.error(f"Error creating DataTable widget for {self.param.title()}: {e}")
            return None

    def updateWidget(self, **kwargs):
        if self.widget:
            logger.debug(f"DataTableParameterItem updating widget with {kwargs}")
            self.widget.queue_update(**kwargs)

    def treeWidgetChanged(self) -> None:
        # Attach the widget when the item is added to the tree.
        super().treeWidgetChanged()
        if self.widget is None:
            logger.debug(f"DataTableParameterItem.treeWidgetChanged: Creating widget for parameter {self.param.title()}")
            self.widget = self.makeWidget()
            self.param.widget = self.widget
        tree = self.treeWidget()
        if tree is not None:
            logger.debug("DataTableParameterItem.treeWidgetChanged: Setting item widget in tree")
            tree.setItemWidget(self, 1, self.widget)

class DataTableParameter(ModelParameter):
    """
    Model parameter for data table display.
    This parameter both displays table metadata via a custom widget
    and holds sub-parameters for display and formatting options.
    """
    itemClass = DataTableParameterItem

    def __init__(self, **opts):
        opts['type'] = 'table'
        super().__init__(**opts)
        self.can_export = True
        # Retrieve the initial model if available
        model = self.state.get_model(self.model_id) if self.state and self.model_id else None
        self._setup_parameters(model)

    def _setup_parameters(self, model):
        logger.debug("Setting up DataTableParameter child parameters")
        # Define child parameters for table display options.
        children = [
            {
                'name': 'Display',
                'type': 'group',
                'expanded': False,
                'children': [
                    {
                        'name': 'show_index',
                        'type': 'bool',
                        'value': model.get_property('show_index', True) if model else True
                    },
                    {
                        'name': 'show_header',
                        'type': 'bool',
                        'value': model.get_property('show_header', True) if model else True
                    },
                    {
                        'name': 'alternate_rows',
                        'type': 'bool',
                        'value': model.get_property('alternate_rows', True) if model else True
                    }
                ]
            },
            {
                'name': 'Format',
                'type': 'group',
                'expanded': False,
                'children': [
                    {
                        'name': 'decimal_places',
                        'type': 'int',
                        'value': model.get_property('decimal_places', 2) if model else 2,
                        'limits': (0, 10)
                    },
                    {
                        'name': 'thousands_separator',
                        'type': 'bool',
                        'value': model.get_property('thousands_separator', True) if model else True
                    }
                ]
            }
        ]
        
        for child in children:
            param = Parameter.create(**child)
            self.addChild(param)
            if child['type'] == 'group':
                for subchild in param.children():
                    subchild.sigValueChanged.connect(self._handle_child_change)
        logger.debug("DataTableParameter child parameters set up")

    def _handle_child_change(self, param, value):
        logger.debug(f"DataTableParameter child parameter {param.name()} changed to {value}")
        if not self.state or not self.model_id:
            logger.debug("DataTableParameter: Missing state or model_id")
            return
        try:
            # Update the underlying model property when a child parameter changes
            self.set_model_property(param.name(), value)
            # Trigger an update to the widget
            if hasattr(self, 'widget') and self.widget:
                self.widget.queue_update()
        except Exception as e:
            logger.error(f"Error handling child parameter change for {param.name()}: {e}")

    def handle_property_update(self, name: str, value: Any):
        logger.debug(f"DataTableParameter handling property update: {name} = {value}")
        try:
            updated = False
            # Update matching child parameter values.
            for group in self.children():
                if group.type() == 'group':
                    for param in group.children():
                        if param.name() == name:
                            param.setValue(value)
                            updated = True
                            break
                    if updated:
                        break
            # For metadata updates (row and column counts), trigger the widget update.
            if name in ['row_count', 'col_count', 'data']:
                if hasattr(self, 'widget') and self.widget:
                    self.widget.queue_update(**{name: value})
        except Exception as e:
            logger.error(f"Error handling property update for {name}: {e}")



================================================================================
*** device_parameter.py ***
### src/pymetr/ui/parameters/device_parameter.py ###
================================================================================

# views/parameters/device_parameter.py
from typing import Optional, Any, Dict
from PySide6.QtWidgets import (
    QWidget, QHBoxLayout, QLabel, QComboBox, 
    QPushButton, QMenu
)
from PySide6.QtCore import Qt
from PySide6.QtGui import QPainter, QColor, QBrush, QPen

from pyqtgraph.parametertree import Parameter
from pymetr.models.device import Device, AcquisitionMode
from pymetr.core.logging import logger
from .base import ModelParameter, ModelParameterItem, ParameterWidget

class LEDIndicator(QLabel):
    """Simple LED status indicator."""
    def __init__(self, size=12, parent=None):
        super().__init__(parent)
        self.setFixedSize(size, size)
        self._color = QColor("#333333")  # Default off color
        
    def set_state(self, state: str):
        """Set LED color based on state."""
        colors = {
            'off': "#333333",
            'green': "#2ECC71",
            'blue': "#3498DB",
            'red': "#E74C3C"
        }
        self._color = QColor(colors.get(state, colors['off']))
        self.update()
        
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        
        # Draw LED circle
        painter.setBrush(QBrush(self._color))
        painter.setPen(QPen(Qt.black, 1))
        painter.drawEllipse(1, 1, self.width()-2, self.height()-2)

class DeviceInfoWidget(ParameterWidget):
    """Widget showing device status with LED indicators."""
    
    def __init__(self, param, parent=None):
        super().__init__(param, parent)
        self._setup_ui()
        self._connect_signals()
        
    def _connect_signals(self):
        """Connect to device signals."""
        device = self.param.state.get_model(self.param.model_id)
        if device:
            device.connection_changed.connect(
                lambda connected: self.queue_update(is_connected=connected)
            )
            device.error_occurred.connect(
                lambda error: self.queue_update(error_message=error)
            )

    def cleanup(self):
        """Clean up signal connections."""
        try:
            device = self.param.state.get_model(self.param.model_id)
            if device:
                device.connection_changed.disconnect()
                device.error_occurred.disconnect()
        except:
            pass
        super().cleanup()
        
    def _setup_ui(self):
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(8)
        
        # Connection LED
        self.conn_led = LEDIndicator()
        layout.addWidget(self.conn_led)
        
        # Status LED  
        self.status_led = LEDIndicator()
        layout.addWidget(self.status_led)
        
        # Connect/Disconnect button
        self.conn_button = QPushButton("Connect")
        self.conn_button.setCheckable(True)
        self.conn_button.clicked.connect(self._handle_connection)
        layout.addWidget(self.conn_button)
        
        layout.addStretch()
    
    def _handle_connection(self, checked):
        """Handle connect/disconnect button."""
        device = self.param.state.get_model(self.param.model_id)
        if device:
            if checked:
                device.connect()
                self.conn_button.setText("Disconnect")
            else:
                device.disconnect() 
                self.conn_button.setText("Connect")
    
    def _process_pending_update(self):
        updates = self._pending_updates.copy()
        self._pending_updates.clear()
        
        # Update connection status
        if 'is_connected' in updates:
            is_connected = updates['is_connected']
            self.conn_led.set_state('blue' if is_connected else 'off')
            self.conn_button.setChecked(is_connected)
            self.conn_button.setText("Disconnect" if is_connected else "Connect")
            
        # Update error status
        if 'error_message' in updates:
            error_msg = updates['error_message']
            self.status_led.set_state('red' if error_msg else 'green')
            if error_msg:
                self.setToolTip(error_msg)
            else:
                self.setToolTip("")

class DeviceParameter(ModelParameter):
    """Parameter for device control and monitoring."""
    
    itemClass = ModelParameterItem
    
    def __init__(self, **opts):
        opts['type'] = 'device'
        super().__init__(**opts)
        
        # Get model through state
        device = self.state.get_model(self.model_id) if self.state else None
        self.setupParameters(device)
    
    def setupParameters(self, device):
        """Set up device parameters."""
        def get_prop(name, default):
            return device.get_property(name, default) if device else default

        # Device Info group
        info_group = {
            'name': 'Device Info',
            'type': 'group',
            'children': [
                dict(name='model', type='str', 
                     value=get_prop('model', ''), readonly=True),
                dict(name='manufacturer', type='str', 
                     value=get_prop('manufacturer', ''), readonly=True),
                dict(name='serial', type='str', 
                     value=get_prop('serial', ''), readonly=True),
                dict(name='firmware', type='str', 
                     value=get_prop('firmware', ''), readonly=True),
                dict(name='resource', type='str', 
                     value=get_prop('resource', ''), readonly=True)
            ]
        }
        
        # Acquisition settings
        settings_group = {
            'name': 'Settings',
            'type': 'group',
            'children': [
                dict(name='acquisition_mode', type='list',
                     value=get_prop('acquisition_mode', AcquisitionMode.SINGLE.value),
                     limits=[mode.value for mode in AcquisitionMode]),
                dict(name='averaging_count', type='int',
                     value=get_prop('averaging_count', 10),
                     limits=(2, 1000))
            ]
        }
        
        # Add each parameter group
        for group_dict in [info_group, settings_group]:
            param = Parameter.create(**group_dict)
            self.addChild(param)
            
            # Only connect change handlers for settings
            if group_dict['name'] == 'Settings':
                for child in param.children():
                    child.sigValueChanged.connect(self._handle_parameter_change)

    def handle_property_update(self, prop: str, value: Any):
        """Handle model property updates."""
        try:
            # Update parameter values
            for group in self.children():
                for param in group.children():
                    if param.name() == prop:
                        param.setValue(value)
                        break
            
            # Update status widget
            if hasattr(self, 'widget'):
                self.widget.queue_update(**{prop: value})
                
        except Exception as e:
            logger.error(f"Error handling property update: {e}")

    def _handle_parameter_change(self, param, value):
        """Handle parameter changes by updating model through state."""
        device = self.state.get_model(self.model_id)
        if device:
            device.set_property(param.name(), value)


================================================================================
*** marker_parameter.py ***
### src/pymetr/ui/parameters/marker_parameter.py ###
================================================================================

from typing import Optional, Any, Tuple
from PySide6.QtWidgets import QWidget, QHBoxLayout, QLabel, QMenu
from PySide6.QtCore import Qt, QPointF
from PySide6.QtGui import QPainter, QColor, QPen
from pyqtgraph.parametertree import Parameter

from .base import ModelParameter, ModelParameterItem, ParameterWidget
from pymetr.core.logging import logger
from pymetr.models import Marker, Trace  # Add Trace import

class MarkerPreviewWidget(ParameterWidget):
    """
    Enhanced widget showing marker info with uncertainty and trace binding.
    """
    def __init__(self, param, parent=None):
        super().__init__(param, parent)
        self._setup_ui()
        
        # Cache for current values
        self._current_x = 0.0
        self._current_y = 0.0
        self._current_color = "#ffffff"
        self._current_symbol = "o"
        self._current_size = 8
        self._current_uncertainty = (None, None)
        self._current_bound = False
        self._current_mode = "linear"
    
    def _setup_ui(self):
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(4)
        
        # Position info - shows (x,y) and [computed] for trace binding
        self.position_label = QLabel()
        self.position_label.setStyleSheet("""
            QLabel {
                color: #dddddd;
                padding: 2px 4px;
                min-width: 120px;
            }
        """)
        
        # Symbol preview - shows marker with uncertainty bars
        self.symbol_preview = MarkerSymbolPreview()
        
        # Trace binding indicator
        self.binding_label = QLabel()
        self.binding_label.setStyleSheet("""
            QLabel {
                color: #666666;
                font-style: italic;
                padding: 2px 4px;
            }
        """)
        
        layout.addWidget(self.position_label)
        layout.addWidget(self.symbol_preview)
        layout.addWidget(self.binding_label)
        layout.addStretch()

    def _process_pending_update(self):
        """Process position and style updates."""
        updates = self._pending_updates
        self._pending_updates = {}
        
        try:
            # Update position display if x or y changed
            if 'x' in updates or 'y' in updates:
                x = updates.get('x', self._current_x)
                y = updates.get('y', self._current_y)
                self._current_x = x
                self._current_y = y
                self.position_label.setText(f"({x:.4g}, {y:.4g})")

            # Update marker style if style properties changed
            if any(key in updates for key in ['color', 'symbol', 'size']):
                color = updates.get('color', self._current_color)
                symbol = updates.get('symbol', self._current_symbol)
                size = updates.get('size', self._current_size)
                
                self._current_color = color
                self._current_symbol = symbol
                self._current_size = size

                # Get current uncertainty values
                if 'uncertainty_visible' in updates:
                    if updates['uncertainty_visible']:
                        upper = updates.get('uncertainty_upper', 0.0)
                        lower = updates.get('uncertainty_lower', 0.0)
                        self._current_uncertainty = (lower, upper)
                    else:
                        self._current_uncertainty = (None, None)
                
                self.symbol_preview.update_style(
                    color, 
                    symbol, 
                    size, 
                    self._current_uncertainty
                )

            # Update binding status if changed
            if 'bound_to_trace' in updates:
                self._current_bound = updates['bound_to_trace']
                self.binding_label.setText("[bound]" if self._current_bound else "")
                self.binding_label.setVisible(self._current_bound)

        except Exception as e:
            logger.error(f"Error updating marker preview: {e}")

class MarkerSymbolPreview(QWidget):
    """
    Custom widget showing marker symbol with uncertainty bars.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFixedSize(60, 20)
        
        self._color = QColor("#ffffff")
        self._symbol = "o"
        self._size = 8
        self._uncertainty = (None, None)
        
        # Symbol drawing functions
        self._symbol_funcs = {
            'o': self._draw_circle,
            's': self._draw_square,
            't': self._draw_triangle,
            'd': self._draw_diamond
        }
    
    def update_style(self, color: str, symbol: str, size: int, 
                    uncertainty: Tuple[Optional[float], Optional[float]]):
        try:
            self._color = QColor(color)
            self._symbol = symbol
            self._size = size
            self._uncertainty = uncertainty
            self.update()  # Force a repaint
            logger.debug(f"Updated marker style: color={color}, symbol={symbol}, size={size}")
        except Exception as e:
            logger.error(f"Error updating marker style: {e}")
    
    def paintEvent(self, event):
        try:
            painter = QPainter(self)
            painter.setRenderHint(QPainter.Antialiasing)
            
            # Center point for symbol
            center = QPointF(30, 10)
            
            # Draw uncertainty bars if enabled
            if self._uncertainty[0] is not None and self._uncertainty[1] is not None:
                painter.setPen(QPen(self._color, 1, Qt.DashLine))
                # Scale uncertainty to widget height
                lower_y = 15  # Bottom of widget
                upper_y = 5   # Top of widget
                painter.drawLine(QPointF(30, lower_y), QPointF(30, upper_y))
                # End caps
                painter.drawLine(QPointF(27, lower_y), QPointF(33, lower_y))
                painter.drawLine(QPointF(27, upper_y), QPointF(33, upper_y))
            
            # Draw symbol
            painter.setPen(QPen(self._color))
            painter.setBrush(self._color)
            
            draw_func = self._symbol_funcs.get(self._symbol, self._draw_circle)
            draw_func(painter, center, self._size)
            
        except Exception as e:
            logger.error(f"Error drawing marker preview: {e}")

    def _draw_circle(self, painter, center, size):
        """Draw circle symbol."""
        radius = size / 2
        painter.drawEllipse(center, radius, radius)

    def _draw_square(self, painter, center, size):
        """Draw square symbol."""
        half_size = size / 2
        painter.drawRect(center.x() - half_size, center.y() - half_size, 
                        size, size)

    def _draw_triangle(self, painter, center, size):
        """Draw triangle symbol."""
        half_size = size / 2
        points = [
            QPointF(center.x(), center.y() - half_size),  # Top
            QPointF(center.x() - half_size, center.y() + half_size),  # Bottom left
            QPointF(center.x() + half_size, center.y() + half_size)   # Bottom right
        ]
        painter.drawPolygon(points)

    def _draw_diamond(self, painter, center, size):
        """Draw diamond symbol."""
        half_size = size / 2
        points = [
            QPointF(center.x(), center.y() - half_size),  # Top
            QPointF(center.x() + half_size, center.y()),  # Right
            QPointF(center.x(), center.y() + half_size),  # Bottom
            QPointF(center.x() - half_size, center.y())   # Left
        ]
        painter.drawPolygon(points)

class MarkerInfoWidget(ParameterWidget):
    """Widget showing marker info and symbol preview."""
    
    def __init__(self, param, parent=None):
        super().__init__(param, parent)
        self._setup_ui()
    
    def _setup_ui(self):
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(4)
        
        self.symbol_preview = MarkerSymbolPreview()
        layout.addWidget(self.symbol_preview)
    
    def _process_pending_update(self):
        """Process position and style updates."""
        updates = self._pending_updates
        self._pending_updates = {}
        
        try:
            # Update marker style if any style properties changed
            if any(key in updates for key in ['color', 'symbol', 'size']):
                color = updates.get('color', self._current_color)
                symbol = updates.get('symbol', self._current_symbol)
                size = updates.get('size', self._current_size)
                
                self._current_color = color
                self._current_symbol = symbol
                self._current_size = size
                
                # Get current uncertainty values
                uncertainty = self._current_uncertainty
                if 'uncertainty_visible' in updates:
                    if updates['uncertainty_visible']:
                        upper = updates.get('uncertainty_upper', 0.0)
                        lower = updates.get('uncertainty_lower', 0.0)
                        uncertainty = (lower, upper)
                    else:
                        uncertainty = (None, None)
                
                self.symbol_preview.update_style(color, symbol, size, uncertainty)
            
            # Update position if x or y changed
            if 'x' in updates or 'y' in updates:
                x = updates.get('x', self._current_x)
                y = updates.get('y', self._current_y)
                self._current_x = x
                self._current_y = y
                self.position_label.setText(f"({x:.4g}, {y:.4g})")
                
            # Update binding status if changed
            if 'bound_to_trace' in updates:
                self._current_bound = updates['bound_to_trace']
                self.binding_label.setText("[bound]" if self._current_bound else "")
                self.binding_label.setVisible(self._current_bound)
                
        except Exception as e:
            logger.error(f"Error updating marker preview: {e}")

class MarkerParameterItem(ModelParameterItem):
    """Parameter item for markers with enhanced preview."""
    
    def makeWidget(self) -> Optional[QWidget]:
        """Create the marker preview widget."""
        try:
            self.widget = MarkerPreviewWidget(self.param)
            return self.widget
        except Exception as e:
            logger.error(f"Error creating marker widget: {e}")
            return None
    
    def updateWidget(self, **kwargs):
        """Update the preview widget with new values."""
        if self.widget:
            self.widget.queue_update(**kwargs)
    
    def addCustomContextActions(self, menu: QMenu):
        """Add marker-specific context actions."""
        # Add reset uncertainty action if enabled
        model = self.param.state.get_model(self.param.model_id)
        if model and model.get_property('uncertainty_visible', False):
            reset_action = menu.addAction("Reset Uncertainty")
            reset_action.triggered.connect(self._handle_reset_uncertainty)
    
    def _handle_reset_uncertainty(self):
        """Reset uncertainty bounds to zero."""
        try:
            self.param.begin_update()
            self.param.set_model_property('uncertainty_upper', 0.0)
            self.param.set_model_property('uncertainty_lower', 0.0)
            self.param.end_update()
        except Exception as e:
            logger.error(f"Error resetting uncertainty: {e}")

    
class MarkerParameter(ModelParameter):
    """
    Enhanced parameter for markers with trace binding and uncertainty support.
    Provides flat structure for common properties with minimal nesting.
    """
    
    itemClass = MarkerParameterItem
    
    def __init__(self, **opts):
        opts['type'] = 'marker'
        super().__init__(**opts)
        
        model = self.state.get_model(self.model_id) if self.state and self.model_id else None
        self.setupParameters(model)
    
    def setupParameters(self, model: Optional[Marker]):
        """Set up marker parameters with flattened structure."""
        def get_prop(name, default):
            return model.get_property(name, default) if model else default
        
        # Top-level parameters for quick access
        params = [
            # Position and identification
            dict(name='x', type='float',
                 value=get_prop('x', 0.0)),
            dict(name='y', type='float',
                 value=get_prop('y', 0.0),
                 enabled=not model.bound_to_trace if model else True),
            dict(name='label', type='str',
                 value=get_prop('label', '')),
            dict(name='visible', type='bool',
                 value=get_prop('visible', True)),
            
            # Visual style
            dict(name='color', type='color',
                 value=get_prop('color', '#ffffff')),
            dict(name='symbol', type='list',
                 value=get_prop('symbol', 'o'),
                 limits=['o', 's', 't', 'd']),
            dict(name='size', type='int',
                 value=get_prop('size', 8),
                 limits=(4, 20)),
                 
            # Interpolation (only shown when trace-bound)
            dict(name='interpolation_mode', type='list',
                 value=get_prop('interpolation_mode', 'linear'),
                 limits=['linear', 'nearest'],
                 visible=model.bound_to_trace if model else False),
            
            # Uncertainty as a subgroup
            {
                'name': 'Uncertainty',
                'type': 'group',
                'children': [
                    dict(name='uncertainty_visible', type='bool',
                         value=get_prop('uncertainty_visible', False)),
                    dict(name='uncertainty_upper', type='float',
                         value=get_prop('uncertainty_upper', 0.0)),
                    dict(name='uncertainty_lower', type='float',
                         value=get_prop('uncertainty_lower', 0.0))
                ]
            }
        ]
        
        # Add all parameters
        for param_opts in params:
            param = Parameter.create(**param_opts)
            self.addChild(param)
            
            # Connect change handlers
            if param.type() == 'group':
                for child in param.children():
                    child.sigValueChanged.connect(self._handle_parameter_change)
            else:
                param.sigValueChanged.connect(self._handle_parameter_change)
    
    def handle_property_update(self, prop: str, value: Any):
        """Handle model property updates with preview updates."""
        try:
            # For uncertainty properties, we need to handle them separately
            if prop.startswith('uncertainty_'):
                uncertainty_group = self.child('Uncertainty')
                if uncertainty_group and not uncertainty_group.isRemoved():
                    param = uncertainty_group.child(prop)
                    if param and not param.isRemoved():
                        param.setValue(value)
            else:
                # For all other properties, they're at the root level
                param = self.child(prop)
                if param and not param.isRemoved():
                    param.setValue(value)

            # Special handling for bound_to_trace
            if prop == 'bound_to_trace':
                y_param = self.child('y')
                if y_param and not y_param.isRemoved():
                    y_param.setOpts(enabled=not value)
                
                # Show/hide interpolation mode
                interp_param = self.child('interpolation_mode')
                if interp_param and not interp_param.isRemoved():
                    interp_param.setOpts(visible=value)

            # Update preview widget
            if hasattr(self, 'widget') and self.widget and not self.widget.isDeleted():
                self.widget.queue_update(**{prop: value})

        except Exception as e:
            logger.error(f"Error handling property update: {e}")

    def _handle_parameter_change(self, param, value):
        """Handle parameter changes with trace binding awareness."""
        try:
            # Get current model
            model = self.state.get_model(self.model_id)
            if not model:
                return
            
            # Make sure parameter still exists
            if param.isRemoved():
                return
            
            # Special handling for y-value when trace bound
            if param.name() == 'y' and model.bound_to_trace:
                return  # Ignore y changes when bound to trace
            
            # Handle uncertainty visibility changes
            if param.name() == 'uncertainty_visible':
                uncertainty_group = self.child('Uncertainty')
                if uncertainty_group and not uncertainty_group.isRemoved():
                    for child in uncertainty_group.children():
                        if child and not child.isRemoved() and child.name() != 'uncertainty_visible':
                            child.setOpts(visible=value)
            
            # Update the model
            self.set_model_property(param.name(), value)
            
        except Exception as e:
            logger.error(f"Error handling parameter change: {e}")



================================================================================
*** plot_parameter.py ***
### src/pymetr/ui/parameters/plot_parameter.py ###
================================================================================

from pathlib import Path
from typing import Optional, Any
from PySide6.QtWidgets import QWidget, QHBoxLayout, QMenu
from PySide6.QtCore import Qt
from PySide6.QtGui import QPainter, QColor, QIcon, QFont, QBrush, QPen

from pyqtgraph.parametertree import Parameter
from .base import ModelParameter, ModelParameterItem, ParameterWidget
from pymetr.core.logging import logger
from pymetr.models import Plot, Trace, Marker, Cursor

class ItemCountIcon(QWidget):
    """Custom widget showing an icon with a count badge in the top-right corner."""
    def __init__(self, icon_path: str, badge_color: str = "#FF8400", text_color: str = "#1e1e1e", parent=None):
        super().__init__(parent)
        self._icon = QIcon(icon_path)
        self._badge_color = QColor(badge_color)
        self._text_color = QColor(text_color)
        self._count = 0
        self.setFixedSize(22, 22)
        
    def setCount(self, count: int):
        self._count = count
        self.update()
        
    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        
        # Draw the icon to cover the entire widget area.
        self._icon.paint(painter, 0, 0, self.width(), self.height())
        
        if self._count > 0:
            # Define badge size.
            badge_radius = 8
            # Position badge at top-right.
            badge_x = self.width() - badge_radius * 2
            badge_y = 0
            # Draw a circle for the badge background.
            painter.setBrush(QBrush(self._badge_color))
            painter.setPen(Qt.NoPen)
            painter.drawEllipse(badge_x, badge_y, badge_radius * 2, badge_radius * 2)
            
            # Draw the count number over the badge.
            painter.setPen(QPen(self._text_color))
            painter.setFont(QFont("Arial", 8, QFont.Bold))
            painter.drawText(badge_x, badge_y, badge_radius * 2, badge_radius * 2, 
                             Qt.AlignCenter, str(self._count))

class PlotInfoWidget(ParameterWidget):
    """
    Enhanced widget showing counts of traces, markers, and cursors.
    Updates efficiently and tracks changes properly.
    """
    def __init__(self, param, parent=None):
        super().__init__(param, parent)
        self._setup_ui()
        self._current_counts = {'traces': 0, 'markers': 0, 'cursors': 0}
        
    def _setup_ui(self):
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(8)
        
        # Create icons with counts for each type
        icons_path = Path(__file__).parent.parent / 'icons'
        self.trace_icon = ItemCountIcon(str(icons_path / 'waves.png'))
        self.marker_icon = ItemCountIcon(str(icons_path / 'markers.png'))
        self.cursor_icon = ItemCountIcon(str(icons_path / 'cursor.png'))
        
        # Add to layout
        layout.addWidget(self.trace_icon)
        layout.addWidget(self.marker_icon)
        layout.addWidget(self.cursor_icon)
        
        # Add spacer
        layout.addStretch()
        
        # Connect to model signals
        if self.param.state:
            self.param.state.models_linked.connect(self._handle_model_linked)
            self.param.state.model_removed.connect(self._handle_model_removed)
    
    def _process_pending_update(self):
        """Update item counts."""
        try:
            if not self.param.state or not self.param.model_id:
                return
                
            model = self.param.state.get_model(self.param.model_id)
            if not model:
                return
                
            children = self.param.state.get_children(model.id)
            
            # Count each type
            new_counts = {
                'traces': sum(1 for c in children if isinstance(c, Trace)),
                'markers': sum(1 for c in children if isinstance(c, Marker)),
                'cursors': sum(1 for c in children if isinstance(c, Cursor))
            }
            
            # Only update icons if counts changed
            if new_counts['traces'] != self._current_counts['traces']:
                self.trace_icon.setCount(new_counts['traces'])
            if new_counts['markers'] != self._current_counts['markers']:
                self.marker_icon.setCount(new_counts['markers'])
            if new_counts['cursors'] != self._current_counts['cursors']:
                self.cursor_icon.setCount(new_counts['cursors'])
                
            self._current_counts = new_counts
            
        except Exception as e:
            logger.error(f"Error updating plot info: {e}")
    
    def _handle_model_linked(self, parent_id: str, child_id: str):
        """Update counts when new models are linked."""
        if not self.param.model_id or parent_id != self.param.model_id:
            return
        self.queue_update()
    
    def _handle_model_removed(self, model_id: str):
        """Update counts when models are removed."""
        if not self.param.model_id:
            return
            
        # Check if removed model was our child
        model = self.param.state.get_model(self.param.model_id)
        if model and model_id in [c.id for c in model.get_children()]:
            self.queue_update()
    
    def cleanup(self):
        """Clean up signal connections."""
        try:
            if self.param.state:
                self.param.state.models_linked.disconnect(self._handle_model_linked)
                self.param.state.model_removed.disconnect(self._handle_model_removed)
        except:
            pass
        super().cleanup()

class PlotParameterItem(ModelParameterItem):
    """Parameter item for plots."""
    
    def makeWidget(self) -> Optional[QWidget]:
        """Create the info widget."""
        try:
            self.widget = PlotInfoWidget(self.param)
            return self.widget
        except Exception as e:
            logger.error(f"Error creating plot widget: {e}")
            return None
    
    def updateWidget(self, **kwargs):
        """Update the widget with new values."""
        if self.widget:
            self.widget.queue_update(**kwargs)
    
    def addCustomContextActions(self, menu: QMenu):
        """Add plot-specific context actions."""
        # Add 'Auto Range' action if we have any traces
        if self.param.state:
            model = self.param.state.get_model(self.param.model_id)
            if model and any(isinstance(child, Trace) 
                           for child in self.param.state.get_children(model.id)):
                auto_range = menu.addAction("Auto Range")
                auto_range.triggered.connect(self._handle_auto_range)
    
    def _handle_auto_range(self):
        """Reset plot ranges based on trace data."""
        if self.param.state:
            model = self.param.state.get_model(self.param.model_id)
            if model:
                model.set_property('auto_range', True)

class PlotParameter(ModelParameter):
    """
    Restructured plot parameter with cleaner organization.
    """
    
    itemClass = PlotParameterItem
    
    def __init__(self, **opts):
        opts['type'] = 'plot'
        super().__init__(**opts)
        self.can_export = True
        
        model = self.state.get_model(self.model_id) if self.state and self.model_id else None
        self.setupParameters(model)
    
    def setupParameters(self, model: Optional[Plot]):
        """Set up plot configuration parameters with new structure."""
        def get_prop(name, default):
            return model.get_property(name, default) if model else default
        
        # Settings group (top level)
        settings_group = {
            'name': 'Settings',
            'type': 'group',
            'expanded': False,
            'children': [
                # Basic settings at this level
                dict(name='title', type='str', value=get_prop('title', '')),
                dict(name='x_label', type='str', value=get_prop('x_label', '')),
                dict(name='y_label', type='str', value=get_prop('y_label', '')),
                dict(name='x_unit', type='str', value=get_prop('x_unit', '')),
                dict(name='y_unit', type='str', value=get_prop('y_unit', '')),
                
                # Advanced settings groups
                {
                    'name': 'Display',
                    'type': 'group',
                    'expanded': False,
                    'children': [
                        dict(name='grid_enabled', type='bool', 
                             value=get_prop('grid_enabled', True)),
                        dict(name='legend_enabled', type='bool', 
                             value=get_prop('legend_enabled', True)),
                        dict(name='legend_position', type='list', 
                             value=get_prop('legend_position', 'right'),
                             limits=['right', 'top', 'bottom', 'left'])
                    ]
                },
                {
                    'name': 'Axis',
                    'type': 'group',
                    'expanded': False,
                    'children': [
                        dict(name='x_log', type='bool', 
                             value=get_prop('x_log', False)),
                        dict(name='y_log', type='bool', 
                             value=get_prop('y_log', False)),
                        dict(name='x_inverted', type='bool', 
                             value=get_prop('x_inverted', False)),
                        dict(name='y_inverted', type='bool', 
                             value=get_prop('y_inverted', False))
                    ]
                },
                {
                    'name': 'Range',
                    'type': 'group',
                    'expanded': False,
                    'children': [
                        dict(name='auto_range', type='bool', 
                             value=get_prop('auto_range', True)),
                        dict(name='x_min', type='float', 
                             value=get_prop('x_min', 0.0)),
                        dict(name='x_max', type='float', 
                             value=get_prop('x_max', 1.0)),
                        dict(name='y_min', type='float', 
                             value=get_prop('y_min', 0.0)),
                        dict(name='y_max', type='float', 
                             value=get_prop('y_max', 1.0))
                    ]
                }
            ]
        }
        
        # Add the settings group
        settings = Parameter.create(**settings_group)
        self.addChild(settings)
        
        # Connect change handlers (recursively for all children)
        def connect_param(param):
            if param.type() != 'group':
                param.sigValueChanged.connect(self._handle_parameter_change)
            for child in param.children():
                connect_param(child)
        
        connect_param(settings)
    
    def _handle_parameter_change(self, param, value):
        """Handle parameter changes."""
        try:
            # Special handling for auto_range
            if param.name() == 'auto_range' and value:
                self.begin_update()
                try:
                    for range_param in ['x_min', 'x_max', 'y_min', 'y_max']:
                        self.set_model_property(range_param, None)
                finally:
                    self.end_update()
            else:
                # Normal property update
                self.set_model_property(param.name(), value)
        except Exception as e:
            logger.error(f"Error handling parameter change: {e}")
    
    def handle_property_update(self, prop: str, value: Any):
        """Handle model property updates."""
        try:
            # Find and update matching parameter
            settings = self.child('Settings')
            if settings:
                def update_param(parent, name, val):
                    for child in parent.children():
                        if child.name() == name:
                            child.setValue(val)
                            return True
                        if child.type() == 'group':
                            if update_param(child, name, val):
                                return True
                    return False
                
                update_param(settings, prop, value)
            
            # Update widget for child count changes
            if hasattr(self, 'widget'):
                self.widget.queue_update()
                
        except Exception as e:
            logger.error(f"Error handling property update: {e}")


================================================================================
*** test_result_parameter.py ***
### src/pymetr/ui/parameters/test_result_parameter.py ###
================================================================================

from typing import Optional, Any
from PySide6.QtWidgets import QWidget, QHBoxLayout, QMenu, QProgressBar
from PySide6.QtCore import Qt, QTimer
from pymetr.core.logging import logger
from pymetr.models import TestResult, ResultStatus
from .base import ModelParameter, ModelParameterItem, ParameterWidget

class ResultStatusWidget(ParameterWidget):
    """
    A widget that displays the test result's status and progress in a single QProgressBar.
    Debug logging is added to trace the update chain, and for testing the QTimer, we force
    an immediate update call.
    """
    def __init__(self, param, parent=None):
        super().__init__(param, parent)
        self._setup_ui()
    
    def _setup_ui(self):
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        self.progress_bar = QProgressBar()
        self.progress_bar.setMaximumHeight(18)
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setTextVisible(True)
        layout.addWidget(self.progress_bar)
        
        # Define styles for statuses
        self.status_styles = {
            ResultStatus.PASS: {'border': '#2ECC71', 'chunk': '#2ECC71', 'background': '#1e1e1e'},
            ResultStatus.FAIL: {'border': '#E74C3C', 'chunk': '#E74C3C', 'background': '#1e1e1e'},
            ResultStatus.ERROR: {'border': '#F1C40F', 'chunk': '#F1C40F', 'background': '#1e1e1e'},
            None:             {'border': '#0000FF', 'chunk': '#0000FF', 'background': '#1e1e1e'}  # Blue for not reported
        }
        
        # Set initial style (none reported)
        self._apply_style(None, 0)
    
    def queue_update(self, **kwargs):
        # Add our debug log here
        # logger.debug(f"ResultStatusWidget.queue_update called with: {kwargs}")
        super().queue_update(**kwargs)
        # For debugging: force an immediate processing call.
        # Remove or comment this line once you confirm the update chain works.
        self._process_pending_update()
    
    def _process_pending_update(self):
        # logger.debug(f"ResultStatusWidget._process_pending_update: {self._pending_updates}")
        self._pending_updates.clear()
        
        # Read current values from the model
        status_val = self.param.get_model_property("status", None)
        progress_val = self.param.get_model_property("progress", 0)
        
        if status_val is None or str(status_val).strip() == "":
            status = None
        else:
            try:
                status = ResultStatus[status_val.upper()]
            except KeyError:
                logger.error(f"Invalid status from model: {status_val}")
                status = None

        try:
            progress = float(progress_val)
            progress = max(0, min(100, progress))
        except Exception as e:
            logger.error(f"Invalid progress value: {progress_val} - {e}")
            progress = 0
        
        # logger.debug(f"Updating widget: status={status if status else 'None'}, progress={progress}")
        self._apply_style(status, progress)
    
    def _apply_style(self, status: Optional[ResultStatus], progress: float):
        # If status is None, show "Not Reported" with blue style.
        if status is None:
            style = self.status_styles[None]
            text = "Not Reported"
        else:
            style = self.status_styles.get(status, self.status_styles[ResultStatus.ERROR])
            text = f"{status.name}" if progress == 0 else f"{status.name} ({progress:.1f}%)"
        
        self.progress_bar.setStyleSheet(f"""
            QProgressBar {{
                border: 1px solid {style['border']};
                border-radius: 2px;
                background: {style['background']};
                text-align: center;
                padding: 1px;
            }}
            QProgressBar::chunk {{
                background-color: {style['chunk']};
            }}
        """)
        self.progress_bar.setValue(int(progress))
        self.progress_bar.setFormat(text)
    
    def contextMenuEvent(self, event):
        try:
            menu = QMenu(self)
            try:
                current_status = ResultStatus[self.param.get_model_property("status", "PASS").upper()]
            except Exception:
                current_status = ResultStatus.PASS
            
            progress_menu = menu.addMenu("Set Progress")
            for value in [0, 25, 50, 75, 100]:
                action = progress_menu.addAction(f"{value}%")
                action.triggered.connect(lambda checked, v=value: self._handle_progress_change(v))
            
            menu.addSeparator()
            for status in ResultStatus:
                if status != current_status:
                    action = menu.addAction(f"Set {status.name}")
                    action.triggered.connect(lambda checked, s=status: self._handle_status_change(s))
            
            menu.exec_(event.globalPos())
        except Exception as e:
            logger.error(f"ResultStatusWidget: Error showing context menu: {e}")
    
    def _handle_status_change(self, status: ResultStatus):
        if hasattr(self.param, 'state') and hasattr(self.param, 'model_id'):
            model = self.param.state.get_model(self.param.model_id)
            if model:
                logger.debug(f"ResultStatusWidget: Changing status to {status.name}")
                model.set_property('status', status.name)
    
    def _handle_progress_change(self, value: float):
        if hasattr(self.param, 'state') and hasattr(self.param, 'model_id'):
            model = self.param.state.get_model(self.param.model_id)
            if model:
                logger.debug(f"ResultStatusWidget: Changing progress to {value}")
                model.set_property('progress', value)

class TestResultParameterItem(ModelParameterItem):
    def makeWidget(self) -> Optional[QWidget]:
        try:
            self.widget = ResultStatusWidget(self.param)
            return self.widget
        except Exception as e:
            logger.error(f"TestResultParameterItem: Error creating widget: {e}")
            return None
    
    def updateWidget(self, **kwargs):
        if self.widget:
            logger.debug(f"TestResultParameterItem.updateWidget called with: {kwargs}")
            self.widget.queue_update(**kwargs)
    
    def addCustomContextActions(self, menu: QMenu):
        pass  # Context menu is handled in the widget

class TestResultParameter(ModelParameter):
    itemClass = TestResultParameterItem
    
    def __init__(self, **opts):
        opts['type'] = 'testresult'
        super().__init__(**opts)
        self.can_export = True
        model = self.state.get_model(self.model_id) if self.state and self.model_id else None
        self.setupParameters(model)
    
    def setupParameters(self, model: Optional[TestResult]):
        # No child parameters needed.
        pass
    
    def handle_property_update(self, prop: str, value: Any):
        # logger.debug(f"TestResultParameter: handle_property_update prop: {prop}, value: {value}, widget: {getattr(self, 'widget', None)}")
        # If the widget isn't attached directly to self, try the one on self.param
        widget = getattr(self, 'widget', None) or getattr(self, 'widget', None)
        if widget is not None:
            widget.queue_update(**{prop: value})
        else:
            logger.warning("TestResultParameter: widget is not set for parameter " + self.title())



================================================================================
*** test_script_parameter.py ***
### src/pymetr/ui/parameters/test_script_parameter.py ###
================================================================================

from typing import Optional, Any
from PySide6.QtWidgets import QWidget, QProgressBar, QHBoxLayout, QMenu
from PySide6.QtCore import Qt
from PySide6.QtGui import QIcon
from pymetr.models import TestStatus, TestScript
from pymetr.core.logging import logger

from .base import ModelParameter, ModelParameterItem, ParameterWidget

class TestProgressWidget(ParameterWidget):
    """Widget showing test progress with status."""
    
    def __init__(self, param, parent=None):
        super().__init__(param, parent)
        self._setup_ui()
        
    def _setup_ui(self):
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(4)
        
        self.progress_bar = QProgressBar()
        self.progress_bar.setMaximumHeight(18)
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setTextVisible(True)
        layout.addWidget(self.progress_bar, 1)
        
        # Define styles for test statuses.
        self.status_styles = {
            TestStatus.READY: {'border': '#95A5A6', 'chunk': '#95A5A6', 'background': '#1e1e1e'},
            TestStatus.RUNNING: {'border': '#3498DB', 'chunk': '#3498DB', 'background': '#1e1e1e'},
            TestStatus.PASS: {'border': '#2ECC71', 'chunk': '#2ECC71', 'background': '#1e1e1e'},
            TestStatus.FAIL: {'border': '#E74C3C', 'chunk': '#E74C3C', 'background': '#1e1e1e'},
            TestStatus.ERROR: {'border': '#F1C40F', 'chunk': '#F1C40F', 'background': '#1e1e1e'},
            TestStatus.COMPLETE: {'border': '#2ECC71', 'chunk': '#2ECC71', 'background': '#1e1e1e'},
        }
        
        # Initially show "Not Reported" if no progress is set.
        self._apply_style(TestStatus.READY, 0)
    
    def _process_pending_update(self):
        # logger.debug(f"TestProgressWidget._process_pending_update: {self._pending_updates}")
        self._pending_updates.clear()
        
        status_val = self.param.get_model_property("status", "READY")
        progress_val = self.param.get_model_property("progress", 0)
        
        # Handle status value being either a TestStatus enum or a string.
        if isinstance(status_val, TestStatus):
            status = status_val
        elif isinstance(status_val, str):
            try:
                status = TestStatus[status_val.upper()]
            except KeyError:
                logger.error(f"TestProgressWidget: Invalid status string '{status_val}'. Defaulting to ERROR.")
                status = TestStatus.ERROR
        else:
            status = TestStatus.ERROR

        try:
            progress = float(progress_val)
            progress = max(0, min(100, progress))
        except Exception as e:
            logger.error(f"TestProgressWidget: Invalid progress value: {progress_val} - {e}")
            progress = 0
        
        # logger.debug(f"TestProgressWidget updating: status={status.name}, progress={progress}")
        self._apply_style(status, progress)
    
    def _apply_style(self, status: TestStatus, progress: float):
        style = self.status_styles.get(status, self.status_styles[TestStatus.ERROR])
        self.progress_bar.setStyleSheet(f"""
            QProgressBar {{
                border: 1px solid {style['border']};
                border-radius: 2px;
                background: {style['background']};
                text-align: center;
                padding: 1px;
            }}
            QProgressBar::chunk {{
                background-color: {style['chunk']};
            }}
        """)
        self.progress_bar.setValue(int(progress))
        self.progress_bar.setFormat(f"{status.name} ({progress:.1f}%)")
    
    def contextMenuEvent(self, event):
        """Handle context menu."""
        try:
            menu = QMenu(self)
            status = TestStatus[self.param.get_model_property('status', 'READY').upper()]
            
            if status == TestStatus.RUNNING:
                stop_action = menu.addAction("Stop Test")
                stop_action.triggered.connect(self._handle_stop)
            elif status in [TestStatus.PASS, TestStatus.FAIL, TestStatus.ERROR, TestStatus.COMPLETE]:
                run_action = menu.addAction("Run Test")
                run_action.triggered.connect(self._handle_run)
                menu.addSeparator()
                reset_action = menu.addAction("Reset Status")
                reset_action.triggered.connect(self._handle_reset)
            else:  # READY
                run_action = menu.addAction("Run Test")
                run_action.triggered.connect(self._handle_run)
                
            menu.exec_(event.globalPos())
        except Exception as e:
            logger.error(f"Error showing context menu: {e}")
    
    def _handle_run(self):
        """Handle run action."""
        if hasattr(self.param, 'state'):
            self.param.state.engine.run_test_script(self.param.model_id)
    
    def _handle_stop(self):
        """Handle stop action."""
        if hasattr(self.param, 'state'):
            self.param.state.engine.script_runner.stop()
    
    def _handle_reset(self):
        """Handle reset action."""
        if hasattr(self.param, 'state'):
            model = self.param.state.get_model(self.param.model_id)
            if model:
                model.set_property('status', TestStatus.READY)
                model.set_property('progress', 0)

class TestScriptParameterItem(ModelParameterItem):
    """Parameter item for test scripts."""
    
    def makeWidget(self) -> Optional[QWidget]:
        """Create the progress widget."""
        logger.debug(f"Creating widget for parameter {self.param.name()}")
        try:
            self.widget = TestProgressWidget(self.param)
            return self.widget
        except Exception as e:
            logger.error(f"Error creating test widget: {e}")
            return None
    
    def updateWidget(self, **kwargs):
        """Update the widget with new values."""
        if self.widget:
            self.widget.queue_update(**kwargs)
    
    def addCustomContextActions(self, menu: QMenu):
        """Add test-specific context menu actions."""
        if not self._context_icons:
            logger.debug("No context icons available")
            return
            
        # Add Run action
        run_action = menu.addAction(
            self._context_icons.get('run', QIcon()),
            "Run Test"
        )
        run_action.triggered.connect(self._handle_run)
        
        # Add Stop action (enabled only when running)
        stop_action = menu.addAction(
            self._context_icons.get('stop', QIcon()),
            "Stop Test"
        )
        stop_action.triggered.connect(self._handle_stop)
        
        # Add separator before standard actions
        menu.addSeparator()
        
        # Enable/disable based on current status
        model = self.param.state.get_model(self.param.model_id)
        if model:
            status = model.get_property('status', 'READY')
            stop_action.setEnabled(status == 'RUNNING')
            run_action.setEnabled(status != 'RUNNING')
    
    def _handle_run(self):
        """Handle Run Test action."""
        if hasattr(self.param, 'state'):
            self.param.state.engine.run_test_script(self.param.model_id)
    
    def _handle_stop(self):
        """Handle Stop Test action."""
        if hasattr(self.param, 'state'):
            self.param.state.engine.script_runner.stop()

class TestScriptParameter(ModelParameter):
    """Parameter for test scripts."""
    
    itemClass = TestScriptParameterItem
    
    def __init__(self, **opts):
        opts['type'] = 'testscript'
        super().__init__(**opts)
        self.can_export = True
    
    def setupParameters(self, model: Optional[TestScript]):
        """No child parameters needed - only shows model children."""
        pass
    
    def handle_property_update(self, prop: str, value: Any):
        """Handle model property updates."""
        if hasattr(self, 'widget'):
            self.widget.queue_update(**{prop: value})


================================================================================
*** test_suite_parameter.py ***
### src/pymetr/ui/parameters/test_suite_parameter.py ###
================================================================================

from typing import Optional, Any
from PySide6.QtWidgets import QWidget, QHBoxLayout, QLabel, QPushButton, QMenu
from PySide6.QtCore import Qt
from PySide6.QtGui import QIcon
from pyqtgraph.parametertree import Parameter

from .base import ModelParameter, ModelParameterItem, ParameterWidget
from pymetr.core.logging import logger
from pymetr.models.test import TestSuite, TestStatus

class TestSuiteStatusWidget(ParameterWidget):
    """Widget showing suite status and aggregated info."""
    def __init__(self, param, parent=None):
        super().__init__(param, parent)
        self._setup_ui()
    
    def _setup_ui(self):
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(4)
        
        # Status label
        self.status_label = QLabel()
        self.status_label.setStyleSheet("""
            QLabel {
                padding: 2px 8px;
                border-radius: 2px;
                font-weight: 500;
                min-width: 60px;
            }
        """)
        
        layout.addWidget(self.status_label)
        layout.addStretch()
        
        # Set initial state
        self._update_ui_state(TestStatus.READY)
    
    def _update_ui_state(self, status: TestStatus):
        """Update UI based on status."""
        styles = {
            TestStatus.READY: {"border": "#95A5A6", "bg": "#2A2A2A"},
            TestStatus.RUNNING: {"border": "#3498DB", "bg": "#2A2A2A"},
            TestStatus.PASS: {"border": "#2ECC71", "bg": "#2A2A2A"},
            TestStatus.FAIL: {"border": "#E74C3C", "bg": "#2A2A2A"},
            TestStatus.ERROR: {"border": "#F1C40F", "bg": "#2A2A2A"},
            TestStatus.COMPLETE: {"border": "#2ECC71", "bg": "#2A2A2A"}
        }
        
        style = styles.get(status, styles[TestStatus.READY])
        self.status_label.setStyleSheet(self.status_label.styleSheet() + f"""
            border: 1px solid {style['border']};
            background: {style['bg']};
        """)
        self.status_label.setText(status.name)
    
    def _process_pending_update(self):
        """Process status updates."""
        updates = self._pending_updates
        self._pending_updates = {}
        
        if 'status' in updates:
            status = updates['status']
            if isinstance(status, str):
                try:
                    status = TestStatus[status.upper()]
                except KeyError:
                    status = TestStatus.ERROR
            self._update_ui_state(status)

class TestSuiteParameterItem(ModelParameterItem):
    """Parameter item for test suites."""
    
    def makeWidget(self) -> Optional[QWidget]:
        """Create the status widget."""
        try:
            self.widget = TestSuiteStatusWidget(self.param)
            return self.widget
        except Exception as e:
            logger.error(f"Error creating suite widget: {e}")
            return None
    
    def updateWidget(self, **kwargs):
        """Update the widget with new values."""
        if self.widget:
            self.widget.queue_update(**kwargs)
    
    def addCustomContextActions(self, menu: QMenu):
        """Add suite-specific context actions."""
        # Add Run Suite action
        if self._context_icons:
            run_action = menu.addAction(
                self._context_icons.get('run', QIcon()),
                "Run Suite"
            )
            run_action.triggered.connect(self._handle_run_suite)
            
            # Add Stop Suite action (enabled only when running)
            stop_action = menu.addAction(
                self._context_icons.get('stop', QIcon()),
                "Stop Suite"
            )
            stop_action.triggered.connect(self._handle_stop_suite)
            
            # Enable/disable based on current status
            model = self.param.state.get_model(self.param.model_id)
            if model:
                status = model.get_property('status', 'READY')
                stop_action.setEnabled(status == 'RUNNING')
                run_action.setEnabled(status != 'RUNNING')
    
    def _handle_run_suite(self):
        """Handle Run Suite action."""
        if hasattr(self.param, 'state'):
            self.param.state.engine.run_suite(self.param.model_id)
    
    def _handle_stop_suite(self):
        """Handle Stop Suite action."""
        if hasattr(self.param, 'state'):
            self.param.state.engine.stop_suite()

class TestSuiteParameter(ModelParameter):
    """Parameter for test suites."""
    
    itemClass = TestSuiteParameterItem
    
    def __init__(self, **opts):
        opts['type'] = 'testsuite'
        super().__init__(**opts)
        self.can_export = True
        
        model = self.state.get_model(self.model_id) if self.state and self.model_id else None
        self.setupParameters(model)
    
    def setupParameters(self, model: Optional[TestSuite]):
        """Set up suite configuration parameters."""
        if not model:
            return
            
        # Add parameters for run configurations
        configs = [config.get_property('name') for config in model.get_run_configs()]
        if configs:
            config_param = Parameter.create(
                name='run_config',
                type='list',
                value=configs[0],
                limits=configs
            )
            self.addChild(config_param)
    
    def handle_property_update(self, prop: str, value: Any):
        """Handle model property updates."""
        if hasattr(self, 'widget'):
            self.widget.queue_update(**{prop: value})


================================================================================
*** trace_parameter.py ***
### src/pymetr/ui/parameters/trace_parameter.py ###
================================================================================

from typing import Optional, Any
import numpy as np
from PySide6.QtWidgets import QWidget, QHBoxLayout, QFileDialog, QMenu
from PySide6.QtCore import Qt
from PySide6.QtGui import QPainter, QColor, QPen
from pyqtgraph.parametertree import Parameter

from .base import ModelParameter, ModelParameterItem, ParameterWidget
from pymetr.core.logging import logger
from pymetr.models import Trace

class TraceStylePreview(QWidget):
    """
    Enhanced trace preview widget showing style and data length.
    Handles updates efficiently and maintains visual consistency.
    """
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFixedHeight(20)
        self.setMinimumWidth(100)
        
        # Cache current values to avoid unnecessary redraws
        self._current_style = {
            'color': QColor("#ffffff"),
            'style': Qt.SolidLine,
            'width': 1
        }
        self._current_length = 0
    
    def update_style(self, color: str, style: str, width: int):
        """Update line style properties efficiently."""
        try:
            new_color = QColor(color)
            new_style = self._get_qt_line_style(style)
            new_width = max(1, int(width))
            
            # Only update if something changed
            if (new_color != self._current_style['color'] or 
                new_style != self._current_style['style'] or
                new_width != self._current_style['width']):
                
                self._current_style.update({
                    'color': new_color,
                    'style': new_style,
                    'width': new_width
                })
                self.update()
                
        except Exception as e:
            logger.error(f"Error updating trace style: {e}")
    
    def set_length(self, length: int):
        """Update data length display efficiently."""
        if length != self._current_length:
            self._current_length = length
            self.update()
    
    @staticmethod
    def _get_qt_line_style(style_str: str) -> Qt.PenStyle:
        """Convert string style to Qt PenStyle with proper normalization."""
        normalized = style_str.lower().replace(" ", "").replace("-", "")
        styles = {
            "solid": Qt.SolidLine,
            "dash": Qt.DashLine,
            "dot": Qt.DotLine,
            "dashdot": Qt.DashDotLine
        }
        return styles.get(normalized, Qt.SolidLine)
    
    def paintEvent(self, event):
        try:
            painter = QPainter(self)
            painter.setRenderHint(QPainter.Antialiasing)
            
            # Draw length indicator efficiently
            painter.setPen(QPen(Qt.white))
            length_text = f"[{self._current_length:,}]"
            painter.drawText(2, 0, 50, 20, Qt.AlignVCenter, length_text)
            
            # Draw style preview with cached values
            pen = QPen(self._current_style['color'])
            pen.setStyle(self._current_style['style'])
            pen.setWidth(self._current_style['width'])
            painter.setPen(pen)
            
            # Draw line sample after the length text
            line_start = 60
            painter.drawLine(line_start, 10, self.width() - 5, 10)
            
        except Exception as e:
            logger.error(f"Error painting trace preview: {e}")

class TraceInfoWidget(ParameterWidget):
    """Widget showing trace info and style preview with proper update handling."""
    
    def __init__(self, param, parent=None):
        super().__init__(param, parent)
        self._setup_ui()
        
        # Cache current values
        self._current_color = "#ffffff"
        self._current_style = "solid"
        self._current_width = 1
    
    def _setup_ui(self):
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(4)
        
        self.style_preview = TraceStylePreview()
        layout.addWidget(self.style_preview)
    
    def _process_pending_update(self):
        """Process style and data updates efficiently."""
        updates = self._pending_updates
        self._pending_updates = {}
        
        try:
            # Update line style if any style properties changed
            if any(key in updates for key in ['color', 'style', 'width']):
                color = updates.get('color', self._current_color)
                style = updates.get('style', self._current_style)
                width = updates.get('width', self._current_width)
                
                self._current_color = color
                self._current_style = style
                self._current_width = width
                
                self.style_preview.update_style(color, style, width)
            
            # Update length if data changed
            if 'x_data' in updates:
                if isinstance(updates['x_data'], (list, tuple, np.ndarray)):
                    self.style_preview.set_length(len(updates['x_data']))
            
            # Also check model for initial data
            elif not hasattr(self, '_initialized'):
                model = self.param.state.get_model(self.param.model_id)
                if model and hasattr(model, 'x_data'):
                    self.style_preview.set_length(len(model.x_data))
                self._initialized = True
            
        except Exception as e:
            logger.error(f"Error updating trace info: {e}")
    
    def cleanup(self):
        """Clean up resources."""
        try:
            super().cleanup()
            if hasattr(self, 'style_preview'):
                self.style_preview.deleteLater()
        except Exception as e:
            logger.error(f"Error cleaning up trace info widget: {e}")

class TraceParameterItem(ModelParameterItem):
    """Parameter item for traces with line style preview."""
    
    def makeWidget(self) -> Optional[QWidget]:
        """Create the trace preview widget."""
        try:
            self.widget = TraceInfoWidget(self.param)
            return self.widget
        except Exception as e:
            logger.error(f"Error creating trace widget: {e}")
            return None
    
    def updateWidget(self, **kwargs):
        """Update the widget with new values."""
        if self.widget:
            self.widget.queue_update(**kwargs)
    
    def addCustomContextActions(self, menu: QMenu):
        """Add trace-specific context actions."""
        try:
            model = self.param.state.get_model(self.param.model_id)
            if not model:
                return
                
            # Add "Show Only This" action
            isolate_action = menu.addAction("Show Only This")
            isolate_action.triggered.connect(self._handle_isolate)
            
            # Add "Show All" action
            show_all_action = menu.addAction("Show All")
            show_all_action.triggered.connect(self._handle_show_all)
            
            # Add separator before data actions
            menu.addSeparator()
            
            # Add data information/actions
            x_data = model.get_property('x_data', [])
            y_data = model.get_property('y_data', [])
            if len(x_data) > 0 and len(y_data) > 0:
                # Show data range info
                x_range = f"X Range: [{min(x_data):.4g}, {max(x_data):.4g}]"
                y_range = f"Y Range: [{min(y_data):.4g}, {max(y_data):.4g}]"
                range_action = menu.addAction(f"{x_range}, {y_range}")
                range_action.setEnabled(False)  # Just for display
                
                # Add "Export Data" action
                export_action = menu.addAction("Export Data...")
                export_action.triggered.connect(self._handle_export)
                
        except Exception as e:
            logger.error(f"Error adding context actions: {e}")
    
    def _handle_isolate(self):
        """Handle 'Show Only This' action."""
        try:
            plot_model = None
            model = self.param.state.get_model(self.param.model_id)
            if model:
                # Find parent plot
                plot_model = self.param.state.get_parent(model.id)
            
            if plot_model:
                # Hide all traces except this one
                for trace in self.param.state.get_children(plot_model.id):
                    if isinstance(trace, Trace):
                        trace.set_property('visible', trace.id == model.id)
                        
        except Exception as e:
            logger.error(f"Error handling isolate action: {e}")
    
    def _handle_show_all(self):
        """Handle 'Show All' action."""
        try:
            plot_model = None
            model = self.param.state.get_model(self.param.model_id)
            if model:
                # Find parent plot
                plot_model = self.param.state.get_parent(model.id)
            
            if plot_model:
                # Show all traces
                for trace in self.param.state.get_children(plot_model.id):
                    if isinstance(trace, Trace):
                        trace.set_property('visible', True)
                        
        except Exception as e:
            logger.error(f"Error handling show all action: {e}")
    
    def _handle_export(self):
        """Handle 'Export Data' action."""
        try:
            model = self.param.state.get_model(self.param.model_id)
            if not model:
                return
                
            # Get file path from user
            path, _ = QFileDialog.getSaveFileName(
                None,
                "Export Trace Data",
                "",
                "CSV Files (*.csv);;All Files (*.*)"
            )
            
            if path:
                x_data = model.get_property('x_data', [])
                y_data = model.get_property('y_data', [])
                
                # Create DataFrame and save
                import pandas as pd
                df = pd.DataFrame({
                    'x': x_data,
                    'y': y_data
                })
                df.to_csv(path, index=False)
                
        except Exception as e:
            logger.error(f"Error exporting trace data: {e}")
            
class TraceParameter(ModelParameter):
    """
    Parameter for traces with pen styling and data handling.
    """
    
    itemClass = TraceParameterItem
    
    def __init__(self, **opts):
        opts['type'] = 'trace'
        super().__init__(**opts)
        
        model = self.state.get_model(self.model_id) if self.state and self.model_id else None
        self.setupParameters(model)
    
    def setupParameters(self, model: Optional[Trace]):
        def get_prop(name, default):
            return model.get_property(name, default) if model else default

        # Create the pen dictionary
        pen_dict = {
            'color': get_prop('color', '#ffffff'),
            'width': get_prop('width', 1),
            'style': get_prop('style', 'solid')
        }

        # Convert it to a QPen instance
        qpen = QPen()
        qpen.setColor(QColor(pen_dict['color']))
        qpen.setWidth(pen_dict['width'])
        # Use your _get_qt_line_style function to convert the style string
        qpen.setStyle(self._get_qt_line_style(pen_dict['style']))

        params = [
            dict(name='visible', type='bool', value=get_prop('visible', True)),
            dict(name='mode', type='list',
                value=get_prop('mode', 'Group'),
                limits=['Group', 'Isolate']),
            {
                'name': 'pen',
                'type': 'pen',
                'expanded':False,
                'value': qpen
            }
        ]

        # Add each parameter as a child with signal connections
        for param_opts in params:
            param = Parameter.create(**param_opts)
            if param.type() == 'pen':
                param.sigValueChanged.connect(self._handle_pen_change)
            else:
                param.sigValueChanged.connect(self._handle_parameter_change)
            self.addChild(param)
    
    def _handle_pen_change(self, param, value):
        """Handle pen parameter changes."""
        try:
            # Update individual style properties
            self.begin_update()
            try:
                self.set_model_property('color', value.color().name())
                self.set_model_property('width', value.width())
                self.set_model_property('style', self._get_style_string(value.style()))
            finally:
                self.end_update()
        except Exception as e:
            logger.error(f"Error handling pen change: {e}")
    
    def _handle_parameter_change(self, param, value):
        """Handle non-pen parameter changes."""
        self.set_model_property(param.name(), value)
    
    @staticmethod
    def _get_style_string(qt_style: Qt.PenStyle) -> str:
        """Convert Qt PenStyle to string."""
        style_map = {
            Qt.SolidLine: 'solid',
            Qt.DashLine: 'dash',
            Qt.DotLine: 'dot',
            Qt.DashDotLine: 'dashdot'
        }
        return style_map.get(qt_style, 'solid')
    
    def handle_property_update(self, prop: str, value: Any):
        """Handle model property updates."""
        try:
            # Update matching parameter
            if prop in ['visible', 'mode']:
                param = self.child(prop)
                if param:
                    param.setValue(value)
            
            # Update pen parameter if style property changed
            elif prop in ['color', 'width', 'style']:
                pen_param = self.child('pen')
                if pen_param:
                    pen = pen_param.value()
                    if prop == 'color':
                        pen.setColor(QColor(value))
                    elif prop == 'width':
                        pen.setWidth(value)
                    elif prop == 'style':
                        pen.setStyle(self._get_qt_line_style(value))
                    pen_param.setValue(pen)
            
            # Update widget
            if hasattr(self, 'widget'):
                self.widget.queue_update(**{prop: value})
                
        except Exception as e:
            logger.error(f"Error handling property update: {e}")
    
    @staticmethod
    def _get_qt_line_style(style_str: str) -> Qt.PenStyle:
        """Convert string style to Qt PenStyle."""
        styles = {
            'solid': Qt.SolidLine,
            'dash': Qt.DashLine,
            'dot': Qt.DotLine,
            'dashdot': Qt.DashDotLine
        }
        return styles.get(style_str.lower(), Qt.SolidLine)


================================================================================
*** base.py ***
### src/pymetr/ui/tabs/base.py ###
================================================================================

# views/tabs/base.py
from typing import Optional
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QToolBar, QSizePolicy
)
from PySide6.QtCore import Qt
from pymetr.ui.views.base import BaseWidget
from pymetr.ui.components.toolbar import TabToolbar
from pymetr.core.logging import logger

class BaseTab(BaseWidget):
    """Base class for all dockable content views."""
    
    def __init__(self, state, model_id: str, parent=None):
        super().__init__(state, parent)
        self._model_id = model_id
        self.toolbar: Optional[TabToolbar] = None
        self.content_widget: Optional[QWidget] = None
        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)        
        self._setup_container()
        self._setup_ui()  # Setup UI first
        self.set_model(model_id)  # Then set model

    def _setup_container(self):
        """Set up main container and layout."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Create toolbar
        self.toolbar = TabToolbar()
        layout.addWidget(self.toolbar)
        
        # Create content widget container
        self.content_widget = QWidget()
        self.content_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        layout.addWidget(self.content_widget)

    def _setup_ui(self):
        """
        Initialize UI components.
        Must be overridden by derived classes.
        """
        raise NotImplementedError("Derived classes must implement _setup_ui")

    def add_toolbar_separator(self):
        """Add separator to toolbar."""
        self.toolbar.addSeparator()
        
    def add_toolbar_stretch(self):
        """Add stretch to toolbar."""
        self.toolbar.addStretch()
        
    def add_toolbar_widget(self, widget: QWidget):
        """Add widget to toolbar."""
        return self.toolbar.addWidget(widget)

    def get_title(self) -> str:
        """Get the title for this content."""
        if self.model:
            return self.model.get_property('name', str(self._model_id))
        return str(self._model_id)


================================================================================
*** device_tab.py ***
### src/pymetr/ui/tabs/device_tab.py ###
================================================================================

# views/tabs/device_tab.py
from pathlib import Path
from PySide6.QtWidgets import (
    QVBoxLayout, QHBoxLayout, QPlainTextEdit, 
    QLineEdit, QPushButton
)
from PySide6.QtGui import QIcon

from pymetr.models.device import AcquisitionMode, Device
from pymetr.models.trace import Trace  # For type checking
from .base import BaseTab
from ..widgets.group_view import GroupView
from ..widgets.toolbar import TabToolbar
from ..widgets.scpi_console import SCPIConsole
from pymetr.core.logging import logger

class DeviceTab(BaseTab):
    """
    Device tab with toolbar controls and SCPI console.
    """

    # Icon mapping for toolbar
    TOOLBAR_ICONS = {
        'connect': 'connect.png',
        'disconnect': 'disconnect.png',
        'acquire': 'acquire.png',
        'stop': 'stop.png',
        'reset': 'reset.png',
        'clear': 'clear.png',
        'save': 'save.png',
        'preset': 'preset.png'
    }

    def __init__(self, state, model_id: str, parent=None):
        super().__init__(state, model_id, parent)
        # Connect to device signals
        model = self.state.get_model(model_id)
        if isinstance(model, Device):
            model.connection_changed.connect(self._handle_connection_changed)
            model.error_occurred.connect(self._handle_error)

    def _handle_connection_changed(self, connected: bool):
        """Handle device connection state changes."""
        self._update_control_states(connected)

    def _handle_error(self, error: str):
        """Handle device errors."""
        self.state.set_error(error)

    def _get_icon(self, name: str) -> QIcon:
        """Get icon from resources."""
        icon_file = self.TOOLBAR_ICONS.get(name)
        if icon_file:
            icon_path = str(Path(__file__).parent.parent / 'icons' / icon_file)
            return QIcon(icon_path)
        return QIcon()
    
    def _setup_ui(self):
        layout = QVBoxLayout(self.content_widget)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # Setup enhanced toolbar
        self._setup_toolbar()
        
        # Main content uses group view
        self.content_view = GroupView(self.state, self.model_id, self)
        layout.addWidget(self.content_view)

        # Add SCPI console at bottom
        self.console = SCPIConsole(self.state, self.model_id, self)
        layout.addWidget(self.console)

    def _setup_toolbar(self):
        """Setup device-specific toolbar controls."""
        # Add connection controls
        self.toolbar.addButton("Connect", self._get_icon('connect'), 
                             self._handle_connect)
        self.toolbar.addButton("Disconnect", self._get_icon('disconnect'), 
                             self._handle_disconnect)
        self.toolbar.addSeparator()

        # Add acquisition controls
        self.mode_combo = self.toolbar.addComboBox(
            "Mode", 
            [mode.value for mode in AcquisitionMode],
            self._handle_mode_change
        )
        self.toolbar.addButton("Acquire", self._get_icon('acquire'), 
                             self._handle_acquire)
        self.toolbar.addButton("Stop", self._get_icon('stop'), 
                             self._handle_stop)
        self.toolbar.addSeparator()

        # Add IEEE 488.2 controls
        self.toolbar.addButton("Reset (*RST)", self._get_icon('reset'),
                             self._handle_reset)
        self.toolbar.addButton("Clear (*CLS)", self._get_icon('clear'),
                             self._handle_clear)
        self.toolbar.addButton("Save", self._get_icon('save'),
                             self._handle_save)
        self.toolbar.addButton("Preset", self._get_icon('preset'),
                             self._handle_preset)
        
    def _handle_connect(self):
        """Handle connect button."""
        try:
            model = self.state.get_model(self.model_id)
            if model:
                model.connect()
                self.toolbar.get_button("Connect").setEnabled(False)
                self.toolbar.get_button("Disconnect").setEnabled(True)
                # Enable other controls
                self._update_control_states(True)
        except Exception as e:
            self.state.set_error(str(e))

    def _handle_disconnect(self):
        """Handle disconnect button."""
        try:
            model = self.state.get_model(self.model_id)
            if model:
                model.disconnect()
                self.toolbar.get_button("Connect").setEnabled(True)
                self.toolbar.get_button("Disconnect").setEnabled(False)
                # Disable other controls
                self._update_control_states(False)
        except Exception as e:
            self.state.set_error(str(e))

    def _handle_mode_change(self, mode: str):
        """Handle acquisition mode change."""
        try:
            model = self.state.get_model(self.model_id)
            if model:
                model.set_property('acquisition_mode', mode)
                # Update button states based on mode
                is_continuous = mode in ['CONTINUOUS', 'AVERAGE']
                self.toolbar.get_button("Stop").setEnabled(is_continuous)
        except Exception as e:
            self.state.set_error(str(e))

    def _handle_acquire(self):
        """Handle acquire button."""
        try:
            model = self.state.get_model(self.model_id)
            if model:
                model.start_acquisition()
                # Update button states
                self.toolbar.get_button("Acquire").setEnabled(False)
                self.toolbar.get_button("Stop").setEnabled(True)
                self.mode_combo.setEnabled(False)
        except Exception as e:
            self.state.set_error(str(e))

    def _handle_stop(self):
        """Handle stop button."""
        try:
            model = self.state.get_model(self.model_id)
            if model:
                model.stop_acquisition()
                # Reset button states
                self.toolbar.get_button("Acquire").setEnabled(True)
                self.toolbar.get_button("Stop").setEnabled(False)
                self.mode_combo.setEnabled(True)
        except Exception as e:
            self.state.set_error(str(e))

    def _handle_reset(self):
        """Handle *RST command."""
        try:
            model = self.state.get_model(self.model_id)
            if model and model.instrument:
                model.instrument.reset()
                self.state.set_info("Instrument reset complete")
        except Exception as e:
            self.state.set_error(str(e))

    def _handle_clear(self):
        """Handle *CLS command."""
        try:
            model = self.state.get_model(self.model_id)
            if model and model.instrument:
                model.instrument.clear_status_registers()
                self.state.set_info("Status registers cleared")
        except Exception as e:
            self.state.set_error(str(e))

    def _handle_save(self):
        """Handle *SAV command."""
        try:
            model = self.state.get_model(self.model_id)
            if model and model.instrument:
                # Could add dialog for save location
                model.instrument.write("*SAV 1")
                self.state.set_info("Instrument state saved")
        except Exception as e:
            self.state.set_error(str(e))

    def _handle_preset(self):
        """Handle preset command."""
        try:
            model = self.state.get_model(self.model_id)
            if model and model.instrument:
                model.instrument.write("*RST;*CLS")
                self.state.set_info("Instrument preset complete")
        except Exception as e:
            self.state.set_error(str(e))

    def _update_control_states(self, enabled: bool):
        """Update enabled state of controls."""
        self.mode_combo.setEnabled(enabled)
        self.toolbar.get_button("Acquire").setEnabled(enabled)
        self.toolbar.get_button("Stop").setEnabled(False)  # Always start disabled
        self.toolbar.get_button("Reset").setEnabled(enabled)
        self.toolbar.get_button("Clear").setEnabled(enabled)
        self.toolbar.get_button("Save").setEnabled(enabled)
        self.toolbar.get_button("Preset").setEnabled(enabled)
        self.console.setEnabled(enabled)

    def cleanup(self):
        """Clean up resources."""
        try:
            model = self.state.get_model(self.model_id)
            if isinstance(model, Device):
                model.connection_changed.disconnect(self._handle_connection_changed)
                model.error_occurred.disconnect(self._handle_error)
        except:
            pass
        super().cleanup()


================================================================================
*** plot_tab.py ***
### src/pymetr/ui/tabs/plot_tab.py ###
================================================================================

# pymetr/views/tabs/plot_tab.py
from pathlib import Path
from typing import Optional, Any, Dict
from PySide6.QtWidgets import (
    QVBoxLayout, QWidget, QLabel, QSizePolicy, QDialog, 
    QFormLayout, QComboBox, QDoubleSpinBox, QPushButton, 
    QHBoxLayout, QLineEdit
)
from PySide6.QtCore import Qt, Slot
from PySide6.QtGui import QAction, QIcon
import pyqtgraph as pg
import numpy as np

from pymetr.ui.tabs.base import BaseTab
from pymetr.ui.views.plot.plot_view import PlotView
from pymetr.core.logging import logger

class PlotTab(BaseTab):
    """
    Enhanced plot tab with ROI synchronization and efficient toolbar actions.
    """
    
    # Updated icon mapping for toolbar
    TOOLBAR_ICONS = {
        'autoscale': 'autoscale.png',
        'isolate': 'isolate.png',
        'group': 'group.png',
        'marker': 'markers.png',
        'cursor': 'cursor.png',
        'camera': 'camera.png',
        'save': 'save.png',
        'visibility': 'visibility_on.png',
        'traces': 'traces.png',
        'grid': 'grid.png',
        'roi': 'roi.png'
    }

    def __init__(self, state, model_id: str, parent=None):
        logger.debug(f"Initializing PlotTab for model_id: {model_id}")
        self.plot_view: Optional[PlotView] = None
        # Cache for toolbar actions
        self._toolbar_actions: Dict[str, QAction] = {}

        super().__init__(state, model_id, parent)
        
        # Connect to state signals for ROI sync if needed
        self.state.model_changed.connect(self._handle_model_changed)
        logger.debug("PlotTab initialized and connected to state")

    def _setup_ui(self):
        """Initialize the tab UI with enhanced toolbar."""
        layout = QVBoxLayout(self.content_widget)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # Create main plot view (now includes ROI plot)
        self.plot_view = PlotView(self.state, self._model_id, self)
        layout.addWidget(self.plot_view)

        # Setup enhanced toolbar
        self._setup_enhanced_toolbar()

    def _setup_enhanced_toolbar(self):
        """Setup enhanced toolbar with toggles and new actions."""
        self.toolbar.addButton("Auto Scale", self._get_icon('autoscale'), self._handle_auto_range)
        self.toolbar.addSeparator()
        
        grid_action = self.toolbar.addToggleButton("Toggle Grid", self._get_icon('grid'),
                                                    checked=True, callback=self._handle_grid_visibility)
        grid_action.setChecked(True)
        self._toolbar_actions['grid'] = grid_action
        
        roi_action = self.toolbar.addToggleButton("Toggle ROI", self._get_icon('roi'),
                                                checked=False, callback=self._handle_roi_visibility)
        roi_action.setChecked(False)
        self._toolbar_actions['roi'] = roi_action
        
        self.toolbar.addSeparator()
        
        self.toolbar.addButton("Group All Traces", self._get_icon('group'), self._handle_group_all_traces)
        self.toolbar.addButton("Isolate All Traces", self._get_icon('isolate'), self._handle_isolate_all_traces)
        
        self.toolbar.addSeparator()
        
        self.toolbar.addButton("Add Marker", self._get_icon('marker'), self._on_add_marker_clicked)
        self.toolbar.addButton("Add X Cursor", self._get_icon('cursor'), self._on_add_x_cursor_clicked)
        self.toolbar.addButton("Add Y Cursor", self._get_icon('cursor'), self._on_add_y_cursor_clicked)
        
        self.toolbar.addStretch()

    def _handle_grid_visibility(self, visible: bool):
        """Handle grid visibility toggle."""
        try:
            if self.model:
                self.model.set_property('grid_enabled', visible)
            if self.plot_view:
                self.plot_view.main_plot_item.showGrid(x=visible, y=visible, alpha=0.3)
                
        except Exception as e:
            logger.error(f"Error handling grid visibility: {e}")

    def _handle_group_all_traces(self):
        """Set all traces to group mode."""
        try:
            if not self.model:
                return
            self.model.begin_update()
            for trace in self.model.get_children():
                if hasattr(trace, 'model_type') and trace.model_type == 'Trace':
                    trace.set_property('mode', 'Group')
            self.model.end_update()
            
        except Exception as e:
            logger.error(f"Error grouping all traces: {e}")

    def _handle_isolate_all_traces(self):
        """Set all traces to isolate mode."""
        try:
            if not self.model:
                return
            self.model.begin_update()
            for trace in self.model.get_children():
                if hasattr(trace, 'model_type') and trace.model_type == 'Trace':
                    trace.set_property('mode', 'Isolate')
            self.model.end_update()
            
        except Exception as e:
            logger.error(f"Error isolating all traces: {e}")

    @Slot(str, str, str, object)
    def _handle_model_changed(self, model_id: str, model_type: str, prop: str, value: Any):
        """Handle model changes affecting ROI and grid toggle from the tab perspective."""
        try:
            if not self.model or model_id != self.model.id:
                return
            if prop == 'roi' and self.plot_view:
                self.plot_view.roi.setRegion(value)
            elif prop == 'roi_visible' and self.plot_view:
                self.plot_view.roi_plot_area.setVisible(value)
                if 'roi' in self._toolbar_actions:
                    self._toolbar_actions['roi'].setChecked(value)
            elif prop == 'grid_enabled' and 'grid' in self._toolbar_actions:
                self._toolbar_actions['grid'].setChecked(value)
                
        except Exception as e:
            logger.error(f"Error handling model change: {e}")

    def _handle_roi_visibility(self, visible: bool):
        """Handle ROI visibility toggle."""
        logger.debug(f"ROI visibility toggle triggered: {visible}")
        try:
            if self.plot_view:
                self.plot_view.roi_plot_area.setVisible(visible)
                self.plot_view._apply_roi_update() # Add RS
            if self.model:
                self.model.set_property('roi_visible', visible)
                logger.debug(f"Model property 'roi_visible' set to {visible}")
        except Exception as e:
            logger.error(f"Error in _handle_roi_visibility: {e}")

    def _handle_auto_range(self):
        """Handle auto range action efficiently."""
        try:
            if self.plot_view:
                self.plot_view._suppress_roi_updates = True
                self.plot_view.main_plot_item.autoRange()
                if self.plot_view.roi:
                    x_range = self.plot_view.main_plot_item.getViewBox().viewRange()[0]
                    self.plot_view.roi.setRegion(x_range)
                self.plot_view._suppress_roi_updates = False
                self.plot_view._apply_roi_update()
                
        except Exception as e:
            logger.error(f"Error in _handle_auto_range: {e}")

    def _on_add_marker_clicked(self):
        """Handle Add Marker button click with efficient trace lookup."""
        try:
            if not self.plot_view or not self.model:
                return

            visible_traces = [
                (curve.opts.get('name', 'Unnamed'), curve)
                for curve in self.plot_view.trace_handler.traces.items()
                if curve.isVisible()
            ]

            if not visible_traces:
                logger.warning("No visible traces available for marker placement")
                return

            dialog = MarkerDialog(visible_traces, self)
            if dialog.exec():
                trace, x_pos, label = dialog.get_values()
                data = trace.getData()
                if data[0].size > 0:
                    idx = np.searchsorted(data[0], x_pos)
                    if idx >= data[0].size:
                        idx = data[0].size - 1
                    y_val = data[1][idx]
                    
                    self.model.create_marker(
                        x=x_pos,
                        y=y_val,
                        label=label,
                        color="#FFFF00",
                        size=8,
                        symbol="o"
                    )
                
        except Exception as e:
            logger.error(f"Error in _on_add_marker_clicked: {e}")

    def _on_add_x_cursor_clicked(self):
        """Add X cursor at current view center."""
        try:
            if not self.plot_view or not self.model:
                return
                
            viewbox = self.plot_view.main_plot_item.getViewBox()
            x_range = viewbox.viewRange()[0]
            pos = (x_range[0] + x_range[1]) / 2.0
            
            self.model.create_cursor(
                axis="x",
                position=pos,
                color="#FFFF00",
                style="dash",
                width=1,
                visible=True
            )
            
        except Exception as e:
            logger.error(f"Error in _on_add_x_cursor_clicked: {e}")

    def _on_add_y_cursor_clicked(self):
        """Add Y cursor at current view center."""
        try:
            if not self.plot_view or not self.model:
                return
                
            viewbox = self.plot_view.main_plot_item.getViewBox()
            y_range = viewbox.viewRange()[1]
            pos = (y_range[0] + y_range[1]) / 2.0
            
            self.model.create_cursor(
                axis="y",
                position=pos,
                color="#FF00FF",
                style="dot",
                width=1,
                visible=True
            )
            
        except Exception as e:
            logger.error(f"Error in _on_add_y_cursor_clicked: {e}")

    def _get_icon(self, name: str) -> QIcon:
        """Get cached icon from the icons directory."""
        icon_file = self.TOOLBAR_ICONS.get(name)
        if icon_file:
            icon_path = str(Path(__file__).parent.parent / 'icons' / icon_file)
            return QIcon(icon_path)
        return QIcon()


class MarkerDialog(QDialog):
    """
    Enhanced dialog for marker creation with improved trace selection.
    """
    def __init__(self, traces, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Add Marker")
        self.setModal(True)

        layout = QFormLayout(self)
        layout.setSpacing(10)

        self.trace_combo = QComboBox()
        for name, trace in traces:
            self.trace_combo.addItem(name, trace)
        layout.addRow("Trace:", self.trace_combo)

        self.x_pos = QDoubleSpinBox()
        self.x_pos.setRange(-1e9, 1e9)
        self.x_pos.setDecimals(6)
        self.x_pos.setStepType(QDoubleSpinBox.AdaptiveDecimalStepType)
        self.x_pos.setButtonSymbols(QDoubleSpinBox.NoButtons)
        layout.addRow("X Position:", self.x_pos)

        self.label_input = QLineEdit()
        self.label_input.setPlaceholderText("Enter marker label...")
        layout.addRow("Label:", self.label_input)

        btn_box = QWidget()
        btn_layout = QHBoxLayout(btn_box)
        btn_layout.setContentsMargins(0, 10, 0, 0)
        
        ok_btn = QPushButton("OK")
        ok_btn.setDefault(True)
        ok_btn.clicked.connect(self.accept)
        
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        
        btn_layout.addWidget(ok_btn)
        btn_layout.addWidget(cancel_btn)
        
        layout.addRow(btn_box)

        self.x_pos.setFocus()

    def get_values(self):
        """Get dialog values with proper defaults."""
        trace = self.trace_combo.currentData()
        x_pos = self.x_pos.value()
        label = self.label_input.text() or f"Marker ({x_pos:.2f})"
        return trace, x_pos, label



================================================================================
*** result_tab.py ***
### src/pymetr/ui/tabs/result_tab.py ###
================================================================================

# views/tabs/result_tab.py
from PySide6.QtWidgets import QVBoxLayout, QToolBar, QComboBox, QLabel, QSizePolicy
from PySide6.QtGui import QAction
from PySide6.QtCore import Qt, Slot

from pymetr.ui.tabs.base import BaseTab
from pymetr.ui.views.result_view import ResultView, LayoutMode
from pymetr.core.logging import logger

class ResultTab(BaseTab):
    """Full-featured result tab with layout controls."""
    
    def __init__(self, state, model_id: str, parent=None):
        super().__init__(state, model_id, parent)
        
    def _setup_ui(self):
        """Initialize the tab UI components."""
        # Add layout controls to the toolbar
        self.toolbar.addWidget(QLabel("Layout:"))
        self.layout_combo = QComboBox()
        self.layout_combo.addItems([
            "Vertical Stack",
            "2 Columns",
            "3 Columns",
            "Auto Grid"
        ])
        # Set the default to Auto Grid (index 3) to match ResultView's default
        self.layout_combo.setCurrentIndex(3)
        self.layout_combo.currentIndexChanged.connect(self._handle_layout_changed)
        self.toolbar.addWidget(self.layout_combo)
        
        self.toolbar.addSeparator()
        
        # Export action
        self.export_action = QAction("Export Results...", self)
        self.export_action.triggered.connect(self._handle_export)
        self.toolbar.addAction(self.export_action)

        # Set up content area with ResultView
        content_layout = QVBoxLayout(self.content_widget)
        content_layout.setContentsMargins(0, 0, 0, 0)
        content_layout.setSpacing(0)
        
        # Result view
        self.result_view = ResultView(self.state, self.model_id, self)
        self.result_view.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        content_layout.addWidget(self.result_view)

    def _handle_layout_changed(self, index: int):
        """Change result layout mode."""
        mode = [
            LayoutMode.Vertical,
            LayoutMode.Grid2,
            LayoutMode.Grid3,
            LayoutMode.GridAuto
        ][index]
        self.result_view.set_layout_mode(mode)

    def _handle_export(self):
        """Handle export action."""
        # TODO: Implement result export
        pass

    def set_model(self, model_id: str):
        """Override to ensure ResultView gets model updates."""
        super().set_model(model_id)
        if hasattr(self, 'result_view'):
            self.result_view.set_model(model_id)


================================================================================
*** script_tab.py ***
### src/pymetr/ui/tabs/script_tab.py ###
================================================================================

# views/tabs/script_tab.py
from pathlib import Path
from typing import Optional, Any
from PySide6.QtWidgets import (
    QVBoxLayout, QHBoxLayout, QWidget,
    QFontComboBox, QComboBox, QLabel,
    QMessageBox
)
from PySide6.QtGui import QFont, QAction
from PySide6.QtCore import Qt, Slot

from pymetr.ui.tabs.base import BaseTab
from pymetr.ui.views.script_view import ScriptView
from pymetr.core.logging import logger

class ScriptTab(BaseTab):
    """Script editor with toolbar controls."""
    
    def __init__(self, state, model_id: str, parent=None):
        self.script_view: Optional[ScriptView] = None
        self.font_combo: Optional[QFontComboBox] = None
        self.size_combo: Optional[QComboBox] = None
        super().__init__(state, model_id, parent)

    def _setup_ui(self):
        """Initialize UI components."""
        # Set up content layout
        layout = QVBoxLayout(self.content_widget)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Create script view
        self.script_view = ScriptView(self.state, self._model_id, self)
        layout.addWidget(self.script_view)
        
        # Set up toolbar items
        self._setup_file_actions()
        self._setup_run_controls()
        self._setup_font_controls()
        
        # Connect script view signals
        self.script_view.content_changed.connect(self._update_status)

    def _setup_file_actions(self):
        """Set up file-related actions."""
        file_menu = self.toolbar.addDropdown("File")
        
        save_action = QAction("Save", file_menu)
        save_action.setShortcut("Ctrl+S")
        save_action.triggered.connect(self._handle_save)
        file_menu.addAction(save_action)
        
        self.add_toolbar_separator()

    def _setup_run_controls(self):
        """Set up run controls."""
        self.run_action = self.toolbar.addButton(
            "Run",
            callback=self._handle_run
        )
        self.run_action.setShortcut("F5")
        
        self.add_toolbar_separator()

    def _setup_font_controls(self):
        """Set up font controls."""
        # Add font controls to toolbar
        font_label = QLabel("Font:")
        # font_label.setStyleSheet("color: #D4D4D4;")
        self.add_toolbar_widget(font_label)
        
        self.font_combo = QFontComboBox()
        self.font_combo.setCurrentFont(QFont("Consolas"))
        self.font_combo.currentFontChanged.connect(self._change_font)
        self.add_toolbar_widget(self.font_combo)
        
        self.size_combo = QComboBox()
        self.size_combo.addItems([str(s) for s in [8,9,10,11,12,14,16,18,20]])
        self.size_combo.setCurrentText("11")
        self.size_combo.currentTextChanged.connect(self._change_font_size)
        self.add_toolbar_widget(self.size_combo)
        
        self.add_toolbar_stretch()

    def _change_font(self, font: QFont):
        """Update editor font family."""
        if self.script_view:
            current_font = self.script_view.editor.font()
            current_font.setFamily(font.family())
            self.script_view.set_font(current_font)

    def _change_font_size(self, size_str: str):
        """Update editor font size."""
        if not self.script_view:
            return
        try:
            size = int(size_str)
            current_font = self.script_view.editor.font()
            current_font.setPointSize(size)
            self.script_view.set_font(current_font)
        except ValueError:
            pass

    def _handle_save(self):
        """Handle save action."""
        if not self.script_view or not self.model:
            return
            
        try:
            path = self.model.get_property('script_path')
            if not path:
                self.state.set_error("No script path specified")
                return False
                
            content = self.script_view.get_content()
            Path(path).write_text(content, encoding='utf-8')
            self.script_view.set_original_content(content)
            self.state.set_info("Script saved successfully")
            return True
        except Exception as e:
            error_msg = f"Error saving script: {str(e)}"
            logger.error(error_msg)
            self.state.set_error(error_msg)
            return False

    def _handle_run(self):
        """Handle run action."""
        if not self.script_view:
            return
            
        if self.script_view.has_unsaved_changes():
            response = QMessageBox.question(
                self,
                "Unsaved Changes",
                "Save changes before running?",
                QMessageBox.Save | QMessageBox.Discard | QMessageBox.Cancel
            )
            
            if response == QMessageBox.Save:
                if not self._handle_save():
                    return
            elif response == QMessageBox.Cancel:
                return
        
        if self.model:
            self.state.set_info("Starting script execution...")
            self.state.engine.run_test_script(self.model.id)

    def _update_status(self):
        """Update status based on editor state."""
        if not self.script_view:
            return
            
        if self.script_view.has_unsaved_changes():
            self.state.set_status("Modified")
        else:
            self.state.set_status("Ready")

    def _handle_property_update(self, prop: str, value: Any):
        """Handle model property updates."""
        if not self.script_view:
            return
            
        if prop == 'status':
            status_msg = f"Status: {value}"
            
            # Different status types get different treatment
            if value == "Running":
                self.state.set_status(status_msg)
                self.script_view.set_read_only(True)
                self.run_action.setEnabled(False)
            elif value == "Failed":
                self.state.set_error(status_msg)
                self.script_view.set_read_only(False)
                self.run_action.setEnabled(True)
            elif value == "Completed":
                self.state.set_info(status_msg)
                self.script_view.set_read_only(False)
                self.run_action.setEnabled(True)
            else:
                self.state.set_status(status_msg)
                self.script_view.set_read_only(False)
                self.run_action.setEnabled(True)
                
        elif prop == 'progress':
            if value is not None:
                self.state.set_progress(value, "Script execution")

    def set_model(self, model_id: str):
        """Set up model and load content."""
        super().set_model(model_id)
        if self.model and self.script_view:
            try:
                path = self.model.get_property('script_path')
                if path and Path(path).exists():
                    content = Path(path).read_text(encoding='utf-8')
                    self.script_view.set_content(content)
                    self.script_view.set_original_content(content)
                    self.state.set_info("Script loaded successfully")
                else:
                    self.state.set_warning("Script file not found")
            except Exception as e:
                error_msg = f"Error loading script: {str(e)}"
                logger.error(error_msg)
                self.state.set_error(error_msg)


================================================================================
*** tab_manager.py ***
### src/pymetr/ui/tabs/tab_manager.py ###
================================================================================

from typing import Dict, Optional, Type
from PySide6.QtWidgets import QTabWidget, QWidget, QLabel, QVBoxLayout
from PySide6.QtCore import Slot

from pymetr.ui.views.base import BaseWidget
from pymetr.models.test import TestScript, TestResult
from pymetr.core.logging import logger

class WelcomeTab(BaseWidget):
    """Welcome tab showing initial application state."""
    
    def __init__(self, state, parent=None):
        super().__init__(state, parent)
        self._setup_ui()
        
    def _setup_ui(self):
        layout = QVBoxLayout(self)
        layout.addWidget(QLabel(
            "<h1>Welcome to PyMetr</h1>"
            "<p>Start by opening a script or connecting an instrument.</p>"
            "<p>Use the ribbon actions above to get started.</p>"
        ))

class TabManager(QTabWidget):
    """
    Manages content tabs and their relationship to models.
    Handles view creation and tab lifecycle.
    """
    
    def __init__(self, state, parent=None):
        super().__init__(parent)
        self.state = state
        self.setTabsClosable(True)
        
        # Track open tabs
        self._tabs: Dict[str, BaseWidget] = {}
        
        # Connect signals
        self.tabCloseRequested.connect(self._handle_tab_close)
        self.currentChanged.connect(self._handle_current_changed)
        
        # Connect to state
        self.state.model_registered.connect(self._handle_model_registered)
        self.state.active_model_changed.connect(self._handle_active_model)
        self.state.model_changed.connect(self._handle_model_changed)
        
        # Open welcome tab
        self.show_welcome()
        
    def show_welcome(self):
        """Show the welcome tab."""
        if 'welcome' not in self._tabs:
            welcome = WelcomeTab(self.state, self)
            self._tabs['welcome'] = welcome
            self.addTab(welcome, ' Welcome')
        self.setCurrentWidget(self._tabs['welcome'])
        
    def _get_view_class(self, model) -> Optional[Type[BaseWidget]]:
        """Get appropriate view class for model type."""
        from pymetr.ui.tabs.script_tab import ScriptTab
        from pymetr.ui.tabs.plot_tab import PlotTab
        from pymetr.ui.tabs.result_tab import ResultTab
        from pymetr.ui.tabs.table_tab import TableTab
        
        model_type = type(model).__name__
        view_map = {
            'TestScript': ScriptTab,
            'TestResult': ResultTab,
            'Plot': PlotTab,
            'DataTable': TableTab 
        }
        return view_map.get(model_type)
        
    def _create_view(self, model_id: str) -> Optional[BaseWidget]:
        """Create appropriate view for model."""
        model = self.state.get_model(model_id)
        if not model:
            return None
            
        view_class = self._get_view_class(model)
        if not view_class:
            logger.warning(f"No view class for model type: {type(model).__name__}")
            return None
            
        try:
            return view_class(self.state, model_id, self)
        except Exception as e:
            logger.error(f"Error creating view for {model_id}: {e}")
            return None

    def _get_tab_title(self, model_id: str) -> str:
        """Get display title for tab."""
        model = self.state.get_model(model_id)
        if model:
            # Try to get name from model
            name = model.get_property('name')
            if name:
                return name
                
            # If no name, try to get from parent (for plots in results)
            parent = self.state.get_parent(model_id)
            if parent:
                parent_name = parent.get_property('name')
                if parent_name:
                    return f"{parent_name} - {type(model).__name__}"
                    
        return str(model_id)
                
    def open_tab(self, model_id: str) -> None:
        """Open or switch to tab for model."""
        # Check if already open
        if model_id in self._tabs:
            self.setCurrentWidget(self._tabs[model_id])
            return True
            
        # Create new view
        view = self._create_view(model_id)
        if not view:
            return False
            
        # Add new tab with proper title
        self._tabs[model_id] = view
        title = self._get_tab_title(model_id)
        self.addTab(view, title)
        self.setCurrentWidget(view)
        logger.debug(f"TabManager: Opened new tab for {model_id} with title {title}")
        return True
        
    @Slot(str)
    def _handle_model_registered(self, model_id: str):
        """Handle new model registration."""
        model = self.state.get_model(model_id)
        if isinstance(model, TestScript):
            # Auto-open scripts
            self.open_tab(model_id)
            
    @Slot(str)
    def _handle_active_model(self, model_id: str):
        """Handle active model changes."""
        if model_id:
            self.open_tab(model_id)
        else:
            self.show_welcome()

    @Slot(str, str, object)
    def _handle_model_changed(self, model_id: str, prop: str, value: object):
        """Handle model property changes."""
        if prop == 'name' and model_id in self._tabs:
            # Update tab title
            tab_idx = self.indexOf(self._tabs[model_id])
            if tab_idx >= 0:
                self.setTabText(tab_idx, value)
                logger.debug(f"TabManager: Updated tab title for {model_id} to {value}")

    @Slot(int)
    def _handle_tab_close(self, index: int):
        """Handle tab close button clicks."""
        widget = self.widget(index)
        model_id = None
        
        # Find model_id for widget
        for mid, tab in self._tabs.items():
            if tab == widget:
                model_id = mid
                break
                
        if model_id:
            # Remove tab
            self.removeTab(index)
            del self._tabs[model_id]
            
            # If last tab, show welcome
            if not self._tabs:
                self.show_welcome()
                
    @Slot(int)
    def _handle_current_changed(self, index: int):
        """Handle tab selection changes."""
        widget = self.widget(index)
        
        # Find model_id for widget
        model_id = None
        for mid, tab in self._tabs.items():
            if tab == widget:
                model_id = mid
                break
                
        # Update active model
        if model_id and model_id != 'welcome':
            self.state.set_active_model(model_id)
            
    def open_discovery(self):
        """Open the instrument discovery tab."""
        if 'discovery' in self._tabs:
            self.setCurrentWidget(self._tabs['discovery'])
            return
            
        from pymetr.ui.views.discovery_view import DiscoveryView
        view = DiscoveryView(self.state, self)
        self._tabs['discovery'] = view
        self.addTab(view, ' Discovery')
        self.setCurrentWidget(view)
        
    def get_current_view(self) -> Optional[BaseWidget]:
        """Get the currently active view."""
        widget = self.currentWidget()
        return widget if isinstance(widget, BaseWidget) else None


================================================================================
*** table_tab.py ***
### src/pymetr/ui/tabs/table_tab.py ###
================================================================================

from PySide6.QtWidgets import (
    QVBoxLayout, QWidget, QMessageBox, QInputDialog,
    QDialog, QLabel, QLineEdit, QDialogButtonBox, QFormLayout,
    QFileDialog
)
from PySide6.QtGui import QAction, QKeySequence
from PySide6.QtCore import Qt, Slot, Signal
import pandas as pd
import numpy as np
from typing import Any

from pymetr.ui.tabs.base import BaseTab
from pymetr.ui.views.table_view import TableView
from pymetr.core.logging import logger
from pymetr.ui.components.toolbar import TabToolbar

class FilterDialog(QDialog):
    """Dialog for creating column filters."""
    def __init__(self, columns, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Filter Data")
        self.columns = columns
        self._setup_ui()
        
    def _setup_ui(self):
        layout = QFormLayout(self)
        
        # Column selection
        self.column_edit = QLineEdit()
        self.column_edit.setPlaceholderText("Column name")
        layout.addRow("Column:", self.column_edit)
        
        # Condition input
        self.condition_edit = QLineEdit()
        self.condition_edit.setPlaceholderText("e.g. > 0, == 'value', etc.")
        layout.addRow("Condition:", self.condition_edit)
        
        # Buttons
        buttons = QDialogButtonBox(
            QDialogButtonBox.Ok | QDialogButtonBox.Cancel
        )
        buttons.accepted.connect(self.accept)
        buttons.rejected.connect(self.reject)
        layout.addRow(buttons)

    def get_filter(self):
        return (self.column_edit.text(), self.condition_edit.text())

class TableTab(BaseTab):
    """Enhanced table tab with advanced features."""
    
    data_changed = Signal(pd.DataFrame)  # Emitted when data changes
    
    def __init__(self, state, model_id: str, parent=None):
        super().__init__(state, model_id, parent)
        self._filters = []  # Store active filters
        
    def _setup_ui(self):
        """Initialize the tab UI components."""
        layout = QVBoxLayout(self.content_widget)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # Table view
        self.table_view = TableView(self.state, self.model_id, self)
        
        # Set up toolbar actions
        self._setup_toolbar_actions()
        
        # Add widgets to layout
        layout.addWidget(self.table_view)
        
        # Connect signals
        self.table_view.selection_changed.connect(self._handle_selection_changed)
        
    def _setup_toolbar_actions(self):
        """Set up toolbar actions and menus."""
        # Export menu
        export_menu = self.toolbar.addDropdown("Export")
        
        # Export actions
        export_menu.addAction("CSV...").triggered.connect(
            lambda: self._handle_export('csv')
        )
        export_menu.addAction("Excel...").triggered.connect(
            lambda: self._handle_export('excel')
        )
        export_menu.addAction("JSON...").triggered.connect(
            lambda: self._handle_export('json')
        )
        
        self.toolbar.addSeparator()
        
        # Filter menu
        filter_menu = self.toolbar.addDropdown("Filter")
        filter_menu.addAction("Add Filter...").triggered.connect(self._add_filter)
        filter_menu.addAction("Clear Filters").triggered.connect(self._clear_filters)
        
        # Statistics menu
        stats_menu = self.toolbar.addDropdown("Statistics")
        stats_menu.addAction("Summary Statistics").triggered.connect(
            self._show_summary_stats
        )
        stats_menu.addAction("Correlation Matrix").triggered.connect(
            self._show_correlation_matrix
        )
        
        # Add stretcher at the end
        self.toolbar.addStretch()
        
    def set_model(self, model_id: str):
        """Override to ensure TableView gets model updates."""
        logger.debug(f"TableTab.set_model called with {model_id}")
        super().set_model(model_id)
        if hasattr(self, 'table_view'):
            logger.debug("Setting model on table_view")
            self.table_view.set_model(model_id)
            if self.model:
                data = self.model.get_property('data')
                if isinstance(data, pd.DataFrame):
                    logger.debug(f"Initial data update: {len(data)} rows")
                    self.table_view._update_table(data)
                    self._update_status(data)

    def handle_property_update(self, prop: str, value: Any):
        """Handle property updates from the model."""
        logger.debug(f"TableTab.handle_property_update: {prop}")
        if prop == 'data' and hasattr(self, 'table_view'):
            logger.debug(f"Updating table with {len(value)} rows")
            self.table_view._update_table(value)
            self._update_status(value)
                    
    def _update_status(self, data: pd.DataFrame):
        """Update status bar with current data info."""
        if isinstance(data, pd.DataFrame):
            total = len(data)
            selected = len(self.table_view.get_selected_data())
            memory = data.memory_usage(deep=True).sum()
            memory_str = self._format_memory(memory)
            
            msg = f"Total rows: {total:,}  |  Selected: {selected:,}  |  Memory usage: {memory_str}"
            self.state.set_status(msg)
            
    def _format_memory(self, bytes: int) -> str:
        """Format memory size in human-readable format."""
        for unit in ['B', 'KB', 'MB', 'GB']:
            if bytes < 1024:
                return f"{bytes:.1f} {unit}"
            bytes /= 1024
        return f"{bytes:.1f} TB"
    
    def _handle_selection_changed(self, selected_data: pd.DataFrame):
        """Update status when selection changes."""
        if self.model:
            data = self.model.get_property('data')
            self._update_status(data)
            
    def _handle_export(self, format: str):
        """Handle data export to various formats."""
        if not self.model:
            return
            
        data = self.model.get_property('data')
        if not isinstance(data, pd.DataFrame) or data.empty:
            self.state.set_warning("No data to export")
            return
            
        # Get file name
        file_filters = {
            'csv': "CSV Files (*.csv)",
            'excel': "Excel Files (*.xlsx)",
            'json': "JSON Files (*.json)"
        }
        
        file_name, _ = QFileDialog.getSaveFileName(
            self, "Export Data", "", file_filters[format]
        )
        
        if not file_name:
            return
            
        try:
            if format == 'csv':
                data.to_csv(file_name, index=False)
            elif format == 'excel':
                data.to_excel(file_name, index=False)
            elif format == 'json':
                data.to_json(file_name, orient='records')
                
            self.state.set_info(f"Data exported to {file_name}")
            
        except Exception as e:
            logger.error(f"Error exporting data: {e}")
            self.state.set_error(f"Error exporting data: {str(e)}")
            
    def _add_filter(self):
        """Add a new filter to the data."""
        if not self.model:
            return
            
        data = self.model.get_property('data')
        if not isinstance(data, pd.DataFrame) or data.empty:
            return
            
        dialog = FilterDialog(data.columns, self)
        if dialog.exec_():
            column, condition = dialog.get_filter()
            if column in data.columns:
                try:
                    # Create filter string
                    filter_str = f"data['{column}'] {condition}"
                    # Test filter
                    filtered = data[eval(filter_str)]
                    # If successful, add to filters
                    self._filters.append((column, condition))
                    # Apply all filters
                    self._apply_filters()
                    self.state.set_info(f"Filter added: {column} {condition}")
                except Exception as e:
                    self.state.set_error(f"Filter error: {str(e)}")
            else:
                self.state.set_warning(f"Column '{column}' not found")
                
    def _clear_filters(self):
        """Remove all filters and restore original data."""
        if self._filters:
            self._filters.clear()
            if self.model:
                data = self.model.get_property('data')
                if isinstance(data, pd.DataFrame):
                    self.table_view._update_table(data)
                    self._update_status(data)
                    self.state.set_info("All filters cleared")
                    
    def _apply_filters(self):
        """Apply all active filters to the data."""
        if not self.model or not self._filters:
            return
            
        data = self.model.get_property('data')
        if not isinstance(data, pd.DataFrame) or data.empty:
            return
            
        try:
            filtered_data = data.copy()
            for column, condition in self._filters:
                filter_str = f"filtered_data['{column}'] {condition}"
                filtered_data = filtered_data[eval(filter_str)]
                
            self.table_view._update_table(filtered_data)
            self._update_status(filtered_data)
            self.state.set_info(f"Applied {len(self._filters)} filter(s)")
            
        except Exception as e:
            logger.error(f"Error applying filters: {e}")
            self.state.set_error(f"Error applying filters: {str(e)}")
            
    def _show_summary_stats(self):
        """Show summary statistics for numeric columns."""
        if not self.model:
            return
            
        data = self.model.get_property('data')
        if not isinstance(data, pd.DataFrame) or data.empty:
            return
            
        # Create summary table
        numeric_data = data.select_dtypes(include=[np.number])
        if not numeric_data.empty:
            summary = numeric_data.describe()
            
            # Create new table model
            summary_table = self.state.create_model(
                type(self.model),
                title="Summary Statistics"
            )
            summary_table.set_property('data', summary)
            
            # Show in new tab
            self.state.register_model(summary_table)
            self.state.set_active_model(summary_table.id)
            self.state.set_info("Created summary statistics table")
        else:
            self.state.set_warning("No numeric columns found for statistics")
            
    def _show_correlation_matrix(self):
        """Show correlation matrix for numeric columns."""
        if not self.model:
            return
            
        data = self.model.get_property('data')
        if not isinstance(data, pd.DataFrame) or data.empty:
            return
            
        # Create correlation matrix
        numeric_data = data.select_dtypes(include=[np.number])
        if not numeric_data.empty:
            corr = numeric_data.corr()
            
            # Create new table model
            corr_table = self.state.create_model(
                type(self.model),
                title="Correlation Matrix"
            )
            corr_table.set_property('data', corr)
            
            # Show in new tab
            self.state.register_model(corr_table)
            self.state.set_active_model(corr_table.id)
            self.state.set_info("Created correlation matrix")
        else:
            self.state.set_warning("No numeric columns found for correlation")


================================================================================
*** toolbar.py ***
### src/pymetr/ui/tabs/toolbar.py ###
================================================================================

# views/widgets/toolbar.py
from typing import Optional, Callable, Any
from PySide6.QtWidgets import (
    QToolBar, QWidget, QToolButton, 
    QMenu, QWidgetAction, QFrame,
    QHBoxLayout, QLabel, QSizePolicy, 
)
from PySide6.QtGui import QIcon, QAction
from PySide6.QtCore import Qt, Signal


class ToolBarButton(QToolButton):
    """Enhanced toolbar button with better styling."""
    def __init__(self, icon=None, text="", parent=None):
        super().__init__(parent)
        self.setToolButtonStyle(Qt.ToolButtonTextBesideIcon)
        if icon:
            self.setIcon(icon)
        self.setText(text)

class ToolBarSeparator(QFrame):
    """Vertical separator for toolbar."""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFrameStyle(QFrame.VLine)

class TabToolbar(QToolBar):
    """Enhanced toolbar with modern styling and better widget handling."""
    
    def __init__(self, parent=None):
        super().__init__(parent)

        self.setFloatable(False)
        self.setMovable(False)

    def addButton(self, text, icon=None, callback=None):
        """Add a button with optional icon and callback."""
        button = ToolBarButton(icon, text, self)
        if callback:
            button.clicked.connect(callback)
        self.addWidget(button)
        return button

    def addToggleButton(self, text, icon=None, checked=False, callback=None):
        """
        Add a toggle button with optional icon, initial state, and callback.
        
        Args:
            text (str): Text to display on the button
            icon (QIcon, optional): Icon for the button
            checked (bool, optional): Initial checked state of the button
            callback (Callable, optional): Function to call when button state changes
        
        Returns:
            QToolButton: The created toggle button
        """
        button = ToolBarButton(icon, text, self)
        button.setCheckable(True)
        button.setChecked(checked)
        
        if callback:
            button.toggled.connect(callback)
        
        self.addWidget(button)
        return button

    def addDropdown(self, text, icon=None):
        """Add a dropdown button."""
        button = ToolBarButton(icon, text, self)
        button.setPopupMode(QToolButton.InstantPopup)
        menu = QMenu(button)

        button.setMenu(menu)
        self.addWidget(button)
        return menu

    def addWidget(self, widget):
        """Add a widget with proper styling."""
        action = QWidgetAction(self)
        container = QWidget()
        layout = QHBoxLayout(container)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        layout.addWidget(widget)
        action.setDefaultWidget(container)
        super().addAction(action)
        return action

    def addSeparator(self):
        """Add a vertical separator."""
        sep = ToolBarSeparator(self)
        self.addWidget(sep)
        return sep

    def addStretch(self):
        """Add a stretch to push items to the right."""
        spacer = QWidget()
        spacer.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Preferred)
        self.addWidget(spacer)
        return spacer




================================================================================
*** __init__.py ***
### src/pymetr/ui/views/__init__.py ###
================================================================================




================================================================================
*** base.py ***
### src/pymetr/ui/views/base.py ###
================================================================================

from PySide6.QtWidgets import QWidget
from PySide6.QtCore import Signal, Slot

from pymetr.models.base import BaseModel
from pymetr.core.logging import logger

class BaseWidget(QWidget):
    """
    Base class for all widgets that display model data.
    Handles model synchronization and updates.
    """
    
    # Signals
    model_changed = Signal(object)  # model
    
    def __init__(self, state, parent=None):
        super().__init__(parent)
        self.state = state
        self._model_id = None
        self._updating = False  # Prevent update loops
        
    @property
    def model_id(self):
        return self._model_id
        
    @property
    def model(self) -> BaseModel:
        """Get current model instance."""
        if self._model_id:
            return self.state.get_model(self._model_id)
        return None
        
    def set_model(self, model_id: str):
        """Set the model for this widget."""
        if model_id != self._model_id:
            # # Disconnect from old model if exists
            # if self._model_id:
            #     old_model = self.state.get_model(self._model_id)
            #     if old_model:
            #         old_model.property_changed.disconnect(self._handle_property_change)
            
            # Connect to new model
            self._model_id = model_id
            model = self.state.get_model(model_id)
            if model:
                model.property_changed.connect(self._handle_property_change)
                self.update_from_model(model)
                self.model_changed.emit(model)
                
    def update_from_model(self, model: BaseModel):
        """
        Update widget from model data.
        Override in subclasses.
        """
        pass
        
    def update_model(self, **properties):
        """
        Update model properties from widget.
        
        Args:
            **properties: Property name/value pairs to update
        """
        if not self._model_id or self._updating:
            return
            
        model = self.state.get_model(self._model_id)
        if model:
            for name, value in properties.items():
                model.set_property(name, value)
                
    @Slot(str, str, str, object)  # NEW signature: model_id, model_type, prop, value
    def _handle_property_change(self, model_id: str, model_type: str, prop: str, value: object):
        """Handle model property changes."""
        if model_id != self._model_id or self._updating:
            return
            
        try:
            self._updating = True
            self.handle_property_update(prop, value)
        finally:
            self._updating = False
            
    def handle_property_update(self, prop: str, value: object):
        """
        Handle specific property updates.
        Override in subclasses.
        """
        pass
        
    def closeEvent(self, event):
        """Clean up model connections on close."""
        if self._model_id:
            model = self.state.get_model(self._model_id)
            if model:
                model.property_changed.disconnect(self._handle_property_change)
        super().closeEvent(event)


================================================================================
*** discovery_view.py ***
### src/pymetr/ui/views/discovery_view.py ###
================================================================================

from typing import Dict, Optional, List, Any
from PySide6.QtWidgets import (
    QVBoxLayout, QHBoxLayout, QPushButton, QTableWidget,
    QTableWidgetItem, QHeaderView, QDialog, QLabel,
    QProgressBar, QFrame
)
from PySide6.QtCore import Qt, Signal, Slot

from pymetr.ui.views.base import BaseWidget
from pymetr.core.logging import logger

class InstrumentTable(QTableWidget):
    """Table for displaying discovered instruments."""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self._setup_ui()
        self._instrument_data: List[Dict] = []
        
    def _setup_ui(self):
        """Configure table UI."""
        # Setup columns
        self.setColumnCount(5)
        self.setHorizontalHeaderLabels([
            "Manufacturer",
            "Model",
            "Serial",
            "Firmware",
            "Resource"
        ])
        
        # Configure header
        header = self.horizontalHeader()
        header.setSectionResizeMode(QHeaderView.Interactive)
        header.setStretchLastSection(True)
        
        # Configure selection
        self.setSelectionBehavior(QTableWidget.SelectRows)
        self.setSelectionMode(QTableWidget.SingleSelection)
        
        # Style
        self.setStyleSheet("""
            QTableWidget {
                background-color: #1E1E1E;
                alternate-background-color: #252525;
                color: #D4D4D4;
                gridline-color: #2D2D2D;
                selection-background-color: #264F78;
                selection-color: #FFFFFF;
            }
            QHeaderView::section {
                background-color: #2D2D2D;
                color: #FFFFFF;
                padding: 4px;
                border: none;
                border-right: 1px solid #3D3D3D;
            }
        """)
        
    def update_instruments(self, instruments: Dict[str, Dict]):
        """Update table with discovered instruments."""
        self.setRowCount(0)
        self._instrument_data.clear()
        
        for info in instruments.values():
            row = self.rowCount()
            self.insertRow(row)
            
            # Add instrument data
            self.setItem(row, 0, QTableWidgetItem(info.get('manufacturer', '')))
            self.setItem(row, 1, QTableWidgetItem(info.get('model', '')))
            self.setItem(row, 2, QTableWidgetItem(info.get('serial', '')))
            self.setItem(row, 3, QTableWidgetItem(info.get('firmware', '')))
            self.setItem(row, 4, QTableWidgetItem(info.get('resource', '')))
            
            # Store full info
            self._instrument_data.append(info)
            
    def get_selected_instrument(self) -> Optional[Dict]:
        """Get the currently selected instrument info."""
        row = self.currentRow()
        if row >= 0 and row < len(self._instrument_data):
            return self._instrument_data[row]
        return None

class DiscoveryDialog(QDialog):
    """Dialog for instrument discovery and connection."""
    
    def __init__(self, state, parent=None):
        super().__init__(parent)
        self.state = state
        self.result_info = None
        
        self._setup_ui()
        self._connect_signals()
        
        # Start discovery
        self.state.discover_instruments()
        
    def _setup_ui(self):
        """Initialize dialog UI."""
        self.setWindowTitle("Discover Instruments")
        self.setMinimumSize(800, 400)
        
        layout = QVBoxLayout(self)
        
        # Status section
        status_frame = QFrame()
        status_frame.setStyleSheet("""
            QFrame {
                background-color: #2D2D2D;
                border-bottom: 1px solid #3D3D3D;
            }
            QLabel {
                color: #FFFFFF;
            }
        """)
        status_layout = QHBoxLayout(status_frame)
        
        self.status_label = QLabel("Discovering instruments...")
        self.progress_bar = QProgressBar()
        self.progress_bar.setTextVisible(False)
        self.progress_bar.setMinimum(0)
        self.progress_bar.setMaximum(0)  # Indeterminate
        
        status_layout.addWidget(self.status_label)
        status_layout.addWidget(self.progress_bar)
        layout.addWidget(status_frame)
        
        # Instrument table
        self.table = InstrumentTable()
        layout.addWidget(self.table)
        
        # Buttons
        button_layout = QHBoxLayout()
        
        self.refresh_button = QPushButton("Refresh")
        self.refresh_button.clicked.connect(self._handle_refresh)
        button_layout.addWidget(self.refresh_button)
        
        button_layout.addStretch()
        
        self.connect_button = QPushButton("Connect")
        self.connect_button.clicked.connect(self._handle_connect)
        button_layout.addWidget(self.connect_button)
        
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.clicked.connect(self.reject)
        button_layout.addWidget(self.cancel_button)
        
        layout.addLayout(button_layout)
        
    def _connect_signals(self):
        """Connect to state signals."""
        self.state.discovery_started.connect(self._handle_discovery_started)
        self.state.discovery_complete.connect(self._handle_discovery_complete)
        self.state.instrument_found.connect(self._handle_instrument_found)
        
    @Slot()
    def _handle_discovery_started(self):
        """Handle start of discovery."""
        self.status_label.setText("Discovering instruments...")
        self.progress_bar.setMaximum(0)
        self.refresh_button.setEnabled(False)
        self.connect_button.setEnabled(False)
        
    @Slot(dict)
    def _handle_discovery_complete(self, instruments: Dict):
        """Handle discovery completion."""
        self.status_label.setText(f"Found {len(instruments)} instruments")
        self.progress_bar.setMaximum(100)
        self.progress_bar.setValue(100)
        self.refresh_button.setEnabled(True)
        self.connect_button.setEnabled(True)
        self.table.update_instruments(instruments)
        
    @Slot(dict)
    def _handle_instrument_found(self, info: Dict):
        """Handle individual instrument discovery."""
        self.status_label.setText(f"Found {info.get('model', 'Unknown')}")
        
    def _handle_refresh(self):
        """Handle refresh button."""
        self.state.discover_instruments()
        
    def _handle_connect(self):
        """Handle connect button."""
        if info := self.table.get_selected_instrument():
            self.result_info = info
            self.accept()

class DiscoveryView(BaseWidget):
    """View for instrument discovery and management."""
    
    def __init__(self, state, parent=None):
        super().__init__(state, parent)
        self._setup_ui()
        
        # Start discovery
        self.state.discover_instruments()
        
    def _setup_ui(self):
        """Initialize view UI."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        
        # Control section
        control_frame = QFrame()
        control_frame.setStyleSheet("""
            QFrame {
                background-color: #2D2D2D;
                border-bottom: 1px solid #3D3D3D;
            }
            QLabel {
                color: #FFFFFF;
            }
        """)
        control_layout = QHBoxLayout(control_frame)
        
        self.refresh_button = QPushButton("Refresh")
        self.refresh_button.clicked.connect(self._handle_refresh)
        control_layout.addWidget(self.refresh_button)
        
        self.status_label = QLabel()
        control_layout.addWidget(self.status_label)
        
        control_layout.addStretch()
        
        self.connect_button = QPushButton("Connect")
        self.connect_button.clicked.connect(self._handle_connect)
        control_layout.addWidget(self.connect_button)
        
        layout.addWidget(control_frame)
        
        # Instrument table
        self.table = InstrumentTable()
        layout.addWidget(self.table)
        
    def _handle_property_update(self, prop: str, value: Any):
        """Handle model property updates."""
        if prop == 'instruments':
            self.table.update_instruments(value)
            self.status_label.setText(f"Found {len(value)} instruments")
            
    @Slot()
    def _handle_refresh(self):
        """Handle refresh button."""
        self.state.discover_instruments()
        
    @Slot()
    def _handle_connect(self):
        """Handle connect button."""
        if info := self.table.get_selected_instrument():
            self.state.connect_instrument(info)


================================================================================
*** group_view.py ***
### src/pymetr/ui/views/group_view.py ###
================================================================================

# views/widgets/result_view.py
from enum import Enum, auto
from typing import Any
from PySide6.QtWidgets import (
    QVBoxLayout, QHBoxLayout, QWidget, QFrame,
    QLabel, QScrollArea, QGridLayout, QSizePolicy
)
from PySide6.QtCore import Qt
from pymetr.ui.views.base import BaseWidget
from pymetr.ui.views.plot.plot_view import PlotView
from pymetr.ui.views.table_view import TableView
from pymetr.models.plot import Plot
from pymetr.models.table import DataTable
from pymetr.models.measurement import Measurement
from pymetr.core.logging import logger

class MeasurementWidget(QFrame):
    """Widget for displaying a single measurement."""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFrameStyle(QFrame.StyledPanel)
        self.setStyleSheet("""
            QFrame {
                background: #252525;
                border: 1px solid #3D3D3D;
                border-radius: 4px;
            }
            QLabel {
                color: #FFFFFF;
            }
        """)
        self._setup_ui()
        
    def _setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(8, 8, 8, 8)
        
        self.name_label = QLabel()
        self.name_label.setStyleSheet("font-weight: bold;")
        layout.addWidget(self.name_label)
        
        self.value_label = QLabel()
        self.value_label.setStyleSheet("font-size: 16px;")
        layout.addWidget(self.value_label)
        
    def update_measurement(self, measurement: Measurement):
        self.name_label.setText(measurement.name)
        self.value_label.setText(f"{measurement.value} {measurement.units}")
        
        # Update color based on limits if set
        if hasattr(measurement, 'min_val') and hasattr(measurement, 'max_val'):
            if measurement.value < measurement.min_val or measurement.value > measurement.max_val:
                self.value_label.setStyleSheet("font-size: 16px; color: #F14C4C;")
            else:
                self.value_label.setStyleSheet("font-size: 16px; color: #4EC9B0;")


class LayoutMode(Enum):
    """Available layout modes for result content."""
    Vertical = auto()      # Stack everything vertically
    Grid2 = auto()         # 2 columns
    Grid3 = auto()         # 3 columns
    GridAuto = auto()      # Auto-adjust columns based on window width


class GroupView(BaseWidget):
    def __init__(self, state, model_id: str, parent=None):
        logger.debug(f"Initializing ResultView for model_id: {model_id}")
        super().__init__(state, parent)
        self._signals_connected = False
        
        self.child_views = {}
        self.layout_mode = LayoutMode.GridAuto
        
        # Ensure the main widget expands in both directions
        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.setMinimumSize(400, 300)
        
        self._init_ui()
        self.set_model(model_id)
        
    def _init_ui(self):
        """Initialize the UI components with improved layout behavior."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        
        # Scroll area with improved size policy
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.scroll_area.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.scroll_area.setStyleSheet("""
            QScrollArea {
                background: #1E1E1E;
                border: none;
            }
        """)
        layout.addWidget(self.scroll_area)
        
        # Content widget with improved layout handling
        self.content_widget = QWidget()
        self.content_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.scroll_area.setWidget(self.content_widget)
        
        self.content_layout = QGridLayout(self.content_widget)
        self.content_layout.setContentsMargins(4, 0, 4, 4)
        self.content_layout.setSpacing(4)
        
        # Critical: Set the content layout to expand properly
        self.content_layout.setColumnStretch(0, 1)
        self.content_layout.setRowStretch(0, 1)
    
    def set_model(self, model_id: str):
        """Set up model and establish connections."""
        super().set_model(model_id)
        if not self.model:
            return
            
        # Update header
        name = self.model.get_property('name', 'Untitled Result')
        status = self.model.get_property('status', None)
        self.header.update_name(name)
        self.header.update_status(status)
        
        # Connect signals only once
        if not self._signals_connected:
            self.state.model_changed.connect(self._handle_model_changed)
            self.state.models_linked.connect(self._handle_models_linked)
            self._signals_connected = True
        
        # Add existing children
        for child in self.model.get_children():
            self._add_child_view(child, force_layout=False)
        
        # Update layout once after all children are added
        self._update_layout()
    
    def _add_child_view(self, model, force_layout=True):
        """Add child view with improved size handling."""
        if model.id in self.child_views:
            return
            
        view = None
        try:
            if isinstance(model, Plot):
                view = PlotView(self.state, model.id, self)
                view.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
                view.setMinimumSize(300, 250)
            elif isinstance(model, DataTable):
                view = TableView(self.state, model.id, self)
                view.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
                view.setMinimumHeight(200)
            elif isinstance(model, Measurement):
                view = MeasurementWidget(self)
                view.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Fixed)
                view.setMinimumHeight(80)
                view.update_measurement(model)
                
            if view:
                self.child_views[model.id] = view
                if force_layout:
                    self._update_layout()
                    
        except Exception as e:
            logger.error(f"Error creating view for {model.id}: {e}")
    
    def _update_layout(self):
        """Enhanced layout management for better space utilization."""
        # Clear existing layout and reset stretch factors
        for i in range(self.content_layout.rowCount()):
            self.content_layout.setRowStretch(i, 0)
        for i in range(self.content_layout.columnCount()):
            self.content_layout.setColumnStretch(i, 0)
            
        while self.content_layout.count():
            item = self.content_layout.takeAt(0)
            if item.widget():
                item.widget().setParent(None)
        
        views = list(self.child_views.values())
        if not views:
            # Even with no views, ensure the layout stretches
            self.content_layout.setRowStretch(0, 1)
            self.content_layout.setColumnStretch(0, 1)
            return
            
        # Calculate grid dimensions
        viewport_width = self.scroll_area.viewport().width()
        viewport_height = self.scroll_area.viewport().height()
        width = self.width()
        
        # Determine columns based on layout mode
        if self.layout_mode == LayoutMode.GridAuto:
            cols = 1 if width < 800 else (2 if width < 1200 else 3)
        elif self.layout_mode == LayoutMode.Grid2:
            cols = 2
        elif self.layout_mode == LayoutMode.Grid3:
            cols = 3
        else:  # LayoutMode.Vertical
            cols = 1
            
        rows = (len(views) + cols - 1) // cols
        
        # Ensure at least one row and column
        rows = max(1, rows)
        cols = max(1, cols)
        
        # Set up grid stretching
        available_height = viewport_height - (rows - 1) * self.content_layout.spacing()
        row_height = available_height // rows if rows > 0 else available_height
        
        # Special handling for single items
        if len(views) == 1:
            view = views[0]
            if isinstance(view, (PlotView, TableView)):
                view.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
                if isinstance(view, PlotView):
                    view.setMinimumHeight(max(250, viewport_height - 40))
            self.content_layout.addWidget(view, 0, 0, 1, cols)
            self.content_layout.setRowStretch(0, 1)
            for col in range(cols):
                self.content_layout.setColumnStretch(col, 1)
            return
            
        # For multiple items, set equal stretching
        for row in range(rows):
            self.content_layout.setRowStretch(row, 1)
        for col in range(cols):
            self.content_layout.setColumnStretch(col, 1)
        
        # Handle multiple items
        for idx, view in enumerate(views):
            row = idx // cols
            col = idx % cols
            
            # Ensure proper size policies
            if isinstance(view, (PlotView, TableView)):
                view.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
                if isinstance(view, PlotView):
                    view.setMinimumHeight(max(200, row_height))
                
            # Add widget to grid with proper span
            if idx == len(views) - 1 and len(views) % cols != 0:
                # Last item spans remaining columns if needed
                remaining_cols = cols - (len(views) % cols) + 1
                self.content_layout.addWidget(view, row, col, 1, remaining_cols)
            else:
                self.content_layout.addWidget(view, row, col)
        
        # Update content widget constraints
        self.content_widget.setMinimumWidth(viewport_width)
        self.content_widget.setMinimumHeight(viewport_height)
        
    def resizeEvent(self, event):
        """Enhanced resize handling."""
        super().resizeEvent(event)
        viewport = self.scroll_area.viewport()
        
        # Update content widget constraints
        self.content_widget.setMinimumWidth(viewport.width())
        
        # Trigger layout update if in auto mode
        if self.layout_mode == LayoutMode.GridAuto:
            self._update_layout()
    
    def set_layout_mode(self, mode: LayoutMode):
        """Change how content is arranged."""
        logger.debug(f"Setting layout mode to: {mode}")
        if mode != self.layout_mode:
            self.layout_mode = mode
            self._update_layout()
    
    def _handle_models_linked(self, parent_id: str, child_id: str):
        """Handle new model relationships."""
        if not self.model or parent_id != self.model.id:
            return
            
        # Only add view if we don't already have it
        if child_id not in self.child_views:
            child = self.state.get_model(child_id)
            if child:
                self._add_child_view(child)
    
    def _handle_model_changed(self, model_id: str, prop: str, value: Any):
        """Handle model property changes."""
        if not self.model:
            return
            
        # Handle parent model changes
        if model_id == self.model.id:
            if prop == 'name':
                self.header.update_name(value)
            elif prop == 'status':
                self.header.update_status(value)
            return
            
        # Handle child model changes
        view = self.child_views.get(model_id)
        if not view:
            return
            
        if hasattr(view, 'handle_property_update'):
            view.handle_property_update(prop, value)
        elif isinstance(view, MeasurementWidget):
            child_model = self.state.get_model(model_id)
            if child_model:
                view.update_measurement(child_model)
    
    def cleanup(self):
        """Clean up signal connections and resources."""
        if self._signals_connected and self.state:
            try:
                self.state.model_changed.disconnect(self._handle_model_changed)
                self.state.models_linked.disconnect(self._handle_models_linked)
            except:
                pass  # Ignore if already disconnected
            self._signals_connected = False
        
        # Clean up child views
        for view in self.child_views.values():
            if hasattr(view, 'cleanup'):
                view.cleanup()
        self.child_views.clear()
        
        super().cleanup()



================================================================================
*** result_view.py ***
### src/pymetr/ui/views/result_view.py ###
================================================================================

# views/widgets/result_view.py
from enum import Enum, auto
from typing import Any
from PySide6.QtWidgets import (
    QVBoxLayout, QHBoxLayout, QWidget, QFrame,
    QLabel, QScrollArea, QGridLayout, QSizePolicy
)
from PySide6.QtCore import Qt
from pymetr.ui.views.base import BaseWidget
from pymetr.ui.views.plot.plot_view import PlotView
from pymetr.ui.views.table_view import TableView
from pymetr.models.plot import Plot
from pymetr.models.table import DataTable
from pymetr.models.measurement import Measurement
from pymetr.core.logging import logger


class ResultHeader(QFrame):
    """Header showing result name and status."""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFrameStyle(QFrame.StyledPanel | QFrame.Raised)
        self._setup_ui()
        
    def _setup_ui(self):
        layout = QHBoxLayout(self)
        layout.setContentsMargins(10, 5, 10, 5)
        
        # Name label (left-aligned, bold)
        self.name_label = QLabel()
        layout.addWidget(self.name_label)
        
        layout.addStretch()
        
        # Status label (right-aligned)
        self.status_label = QLabel()
        layout.addWidget(self.status_label)
        
    def update_name(self, name: str):
        self.name_label.setText(name)
        
    def update_status(self, status: str):
        """Update status with appropriate color."""
        color = {
            'Passed': '#4EC9B0',  # Green
            'Failed': '#F14C4C',  # Red
            'Running': '#CCCCCC', # Light gray
            'Pending': '#CCCCCC'  # Light gray
        }.get(status, '#CCCCCC')
        
        self.status_label.setStyleSheet(f"""
            font-size: 12px;
            color: {color};
            font-weight: bold;
        """)
        self.status_label.setText(status)


class MeasurementWidget(QFrame):
    """Widget for displaying a single measurement."""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFrameStyle(QFrame.StyledPanel)
        self.setStyleSheet("""
            QFrame {
                background: #252525;
                border: 1px solid #3D3D3D;
                border-radius: 4px;
            }
            QLabel {
                color: #FFFFFF;
            }
        """)
        self._setup_ui()
        
    def _setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(8, 8, 8, 8)
        
        self.name_label = QLabel()
        self.name_label.setStyleSheet("font-weight: bold;")
        layout.addWidget(self.name_label)
        
        self.value_label = QLabel()
        self.value_label.setStyleSheet("font-size: 16px;")
        layout.addWidget(self.value_label)
        
    def update_measurement(self, measurement: Measurement):
        self.name_label.setText(measurement.name)
        self.value_label.setText(f"{measurement.value} {measurement.units}")
        
        # Update color based on limits if set
        if hasattr(measurement, 'min_val') and hasattr(measurement, 'max_val'):
            if measurement.value < measurement.min_val or measurement.value > measurement.max_val:
                self.value_label.setStyleSheet("font-size: 16px; color: #F14C4C;")
            else:
                self.value_label.setStyleSheet("font-size: 16px; color: #4EC9B0;")


class LayoutMode(Enum):
    """Available layout modes for result content."""
    Vertical = auto()      # Stack everything vertically
    Grid2 = auto()         # 2 columns
    Grid3 = auto()         # 3 columns
    GridAuto = auto()      # Auto-adjust columns based on window width


class ResultView(BaseWidget):
    def __init__(self, state, model_id: str, parent=None):
        logger.debug(f"Initializing ResultView for model_id: {model_id}")
        super().__init__(state, parent)
        self._signals_connected = False
        
        self.child_views = {}
        self.layout_mode = LayoutMode.GridAuto
        
        # Ensure the main widget expands in both directions
        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.setMinimumSize(400, 300)
        
        self._init_ui()
        self.set_model(model_id)
        
    def _init_ui(self):
        """Initialize the UI components with improved layout behavior."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Header setup remains the same
        self.header = ResultHeader()
        self.header.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        self.header.setMinimumHeight(20)
        layout.addWidget(self.header)
        
        # Scroll area with improved size policy
        self.scroll_area = QScrollArea()
        self.scroll_area.setWidgetResizable(True)
        self.scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.scroll_area.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.scroll_area.setStyleSheet("""
            QScrollArea {
                background: #1E1E1E;
                border: none;
            }
        """)
        layout.addWidget(self.scroll_area)
        
        # Content widget with improved layout handling
        self.content_widget = QWidget()
        self.content_widget.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        self.scroll_area.setWidget(self.content_widget)
        
        self.content_layout = QGridLayout(self.content_widget)
        self.content_layout.setContentsMargins(4, 0, 4, 4)
        self.content_layout.setSpacing(4)
        
        # Critical: Set the content layout to expand properly
        self.content_layout.setColumnStretch(0, 1)
        self.content_layout.setRowStretch(0, 1)
    
    def set_model(self, model_id: str):
        """Set up model and establish connections."""
        super().set_model(model_id)
        if not self.model:
            return
            
        # Update header
        name = self.model.get_property('name', 'Untitled Result')
        status = self.model.get_property('status', None)
        self.header.update_name(name)
        self.header.update_status(status)
        
        # Connect signals only once
        if not self._signals_connected:
            self.state.model_changed.connect(self._handle_model_changed)
            self.state.models_linked.connect(self._handle_models_linked)
            self._signals_connected = True
        
        # Add existing children
        for child in self.model.get_children():
            self._add_child_view(child, force_layout=False)
        
        # Update layout once after all children are added
        self._update_layout()
    
    def _add_child_view(self, model, force_layout=True):
        """Add child view with improved size handling."""
        if model.id in self.child_views:
            return
            
        view = None
        try:
            if isinstance(model, Plot):
                view = PlotView(self.state, model.id, self)
                view.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
                view.setMinimumSize(300, 250)
            elif isinstance(model, DataTable):
                view = TableView(self.state, model.id, self)
                view.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
                view.setMinimumHeight(200)
            elif isinstance(model, Measurement):
                view = MeasurementWidget(self)
                view.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Fixed)
                view.setMinimumHeight(80)
                view.update_measurement(model)
                
            if view:
                self.child_views[model.id] = view
                if force_layout:
                    self._update_layout()
                    
        except Exception as e:
            logger.error(f"Error creating view for {model.id}: {e}")
    
    def _update_layout(self):
        """Enhanced layout management for better space utilization."""
        # Clear existing layout and reset stretch factors
        for i in range(self.content_layout.rowCount()):
            self.content_layout.setRowStretch(i, 0)
        for i in range(self.content_layout.columnCount()):
            self.content_layout.setColumnStretch(i, 0)
            
        while self.content_layout.count():
            item = self.content_layout.takeAt(0)
            if item.widget():
                item.widget().setParent(None)
        
        views = list(self.child_views.values())
        if not views:
            # Even with no views, ensure the layout stretches
            self.content_layout.setRowStretch(0, 1)
            self.content_layout.setColumnStretch(0, 1)
            return
            
        # Calculate grid dimensions
        viewport_width = self.scroll_area.viewport().width()
        viewport_height = self.scroll_area.viewport().height()
        width = self.width()
        
        # Determine columns based on layout mode
        if self.layout_mode == LayoutMode.GridAuto:
            cols = 1 if width < 800 else (2 if width < 1200 else 3)
        elif self.layout_mode == LayoutMode.Grid2:
            cols = 2
        elif self.layout_mode == LayoutMode.Grid3:
            cols = 3
        else:  # LayoutMode.Vertical
            cols = 1
            
        rows = (len(views) + cols - 1) // cols
        
        # Ensure at least one row and column
        rows = max(1, rows)
        cols = max(1, cols)
        
        # Set up grid stretching
        available_height = viewport_height - (rows - 1) * self.content_layout.spacing()
        row_height = available_height // rows if rows > 0 else available_height
        
        # Special handling for single items
        if len(views) == 1:
            view = views[0]
            if isinstance(view, (PlotView, TableView)):
                view.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
                if isinstance(view, PlotView):
                    view.setMinimumHeight(max(250, viewport_height - 40))
            self.content_layout.addWidget(view, 0, 0, 1, cols)
            self.content_layout.setRowStretch(0, 1)
            for col in range(cols):
                self.content_layout.setColumnStretch(col, 1)
            return
            
        # For multiple items, set equal stretching
        for row in range(rows):
            self.content_layout.setRowStretch(row, 1)
        for col in range(cols):
            self.content_layout.setColumnStretch(col, 1)
        
        # Handle multiple items
        for idx, view in enumerate(views):
            row = idx // cols
            col = idx % cols
            
            # Ensure proper size policies
            if isinstance(view, (PlotView, TableView)):
                view.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
                if isinstance(view, PlotView):
                    view.setMinimumHeight(max(200, row_height))
                
            # Add widget to grid with proper span
            if idx == len(views) - 1 and len(views) % cols != 0:
                # Last item spans remaining columns if needed
                remaining_cols = cols - (len(views) % cols) + 1
                self.content_layout.addWidget(view, row, col, 1, remaining_cols)
            else:
                self.content_layout.addWidget(view, row, col)
        
        # Update content widget constraints
        self.content_widget.setMinimumWidth(viewport_width)
        self.content_widget.setMinimumHeight(viewport_height)
        
    def resizeEvent(self, event):
        """Enhanced resize handling."""
        super().resizeEvent(event)
        viewport = self.scroll_area.viewport()
        
        # Update content widget constraints
        self.content_widget.setMinimumWidth(viewport.width())
        
        # Trigger layout update if in auto mode
        if self.layout_mode == LayoutMode.GridAuto:
            self._update_layout()
    
    def set_layout_mode(self, mode: LayoutMode):
        """Change how content is arranged."""
        logger.debug(f"Setting layout mode to: {mode}")
        if mode != self.layout_mode:
            self.layout_mode = mode
            self._update_layout()
    
    def _handle_models_linked(self, parent_id: str, child_id: str):
        """Handle new model relationships."""
        if not self.model or parent_id != self.model.id:
            return
            
        # Only add view if we don't already have it
        if child_id not in self.child_views:
            child = self.state.get_model(child_id)
            if child:
                self._add_child_view(child)
    
    def _handle_model_changed(self, model_id: str, prop: str, value: Any):
        """Handle model property changes."""
        if not self.model:
            return
            
        # Handle parent model changes
        if model_id == self.model.id:
            if prop == 'name':
                self.header.update_name(value)
            elif prop == 'status':
                self.header.update_status(value)
            return
            
        # Handle child model changes
        view = self.child_views.get(model_id)
        if not view:
            return
            
        if hasattr(view, 'handle_property_update'):
            view.handle_property_update(prop, value)
        elif isinstance(view, MeasurementWidget):
            child_model = self.state.get_model(model_id)
            if child_model:
                view.update_measurement(child_model)
    
    def cleanup(self):
        """Clean up signal connections and resources."""
        if self._signals_connected and self.state:
            try:
                self.state.model_changed.disconnect(self._handle_model_changed)
                self.state.models_linked.disconnect(self._handle_models_linked)
            except:
                pass  # Ignore if already disconnected
            self._signals_connected = False
        
        # Clean up child views
        for view in self.child_views.values():
            if hasattr(view, 'cleanup'):
                view.cleanup()
        self.child_views.clear()
        
        super().cleanup()



================================================================================
*** scpi_console.py ***
### src/pymetr/ui/views/scpi_console.py ###
================================================================================

# views/widgets/scpi_console.py
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLineEdit,
    QPushButton, QPlainTextEdit
)
from PySide6.QtCore import Qt, QEvent
from pymetr.ui.views.base import BaseWidget
from pymetr.core.logging import logger

class SCPIConsole(QWidget):
    """
    Interactive SCPI console showing instrument communication with command history.
    Provides real-time display of commands, responses, and errors.
    """
    def __init__(self, state, model_id, parent=None):
        super().__init__(parent)
        self.state = state
        self.model_id = model_id
        self.command_history = []
        self.history_index = 0
        self._setup_ui()
        self._connect_signals()

    def _setup_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(4, 4, 4, 4)
        layout.setSpacing(4)

        # Command input area
        input_layout = QHBoxLayout()
        self.command_input = QLineEdit()
        self.command_input.setPlaceholderText("Enter SCPI command...")
        self.command_input.returnPressed.connect(self._send_command)
        input_layout.addWidget(self.command_input)

        self.send_button = QPushButton("Send")
        self.send_button.clicked.connect(self._send_command)
        input_layout.addWidget(self.send_button)
        layout.addLayout(input_layout)

        # Console output
        self.console = QPlainTextEdit()
        self.console.setReadOnly(True)
        self.console.setMaximumBlockCount(1000)  # Limit scrollback
        self.console.setStyleSheet("""
            QPlainTextEdit {
                background-color: #1E1E1E;
                color: #D4D4D4;
                font-family: "Consolas", monospace;
            }
        """)
        layout.addWidget(self.console)

    def _connect_signals(self):
        """Connect to instrument communication signals."""
        model = self.state.get_model(self.model_id)
        if model and model.instrument:
            model.instrument.commandSent.connect(self._handle_command)
            model.instrument.responseReceived.connect(self._handle_response)
            model.instrument.exceptionOccured.connect(self._handle_error)

    def _handle_command(self, command: str):
        """Log sent command."""
        self.console.appendHtml(
            f'<span style="color: #569CD6">&gt; {command}</span>'
        )

    def _handle_response(self, command: str, response: str):
        """Log command response."""
        self.console.appendHtml(
            f'<span style="color: #608B4E">&lt; {response}</span>'
        )

    def _handle_error(self, error: str):
        """Log communication error."""
        self.console.appendHtml(
            f'<span style="color: #F14C4C">! {error}</span>'
        )

    def eventFilter(self, obj, event):
        """Handle command history navigation."""
        if obj == self.command_input and event.type() == QEvent.KeyPress:
            if event.key() == Qt.Key_Up:
                self._history_previous()
                return True
            elif event.key() == Qt.Key_Down:
                self._history_next()
                return True
        return super().eventFilter(obj, event)

    def _history_previous(self):
        """Navigate command history backwards."""
        if not self.command_history:
            return
        if self.history_index > 0:
            self.history_index -= 1
            self.command_input.setText(self.command_history[self.history_index])

    def _history_next(self):
        """Navigate command history forwards."""
        if not self.command_history:
            return
        if self.history_index < len(self.command_history) - 1:
            self.history_index += 1
            self.command_input.setText(self.command_history[self.history_index])
        else:
            self.history_index = len(self.command_history)
            self.command_input.clear()

    def _send_command(self):
        command = self.command_input.text().strip()
        if not command:
            return

        try:
            # Add to history if unique
            if not self.command_history or command != self.command_history[-1]:
                self.command_history.append(command)
                if len(self.command_history) > 50:  # Limit history size
                    self.command_history.pop(0)
            self.history_index = len(self.command_history)

            model = self.state.get_model(self.model_id)
            if model and model.instrument:
                if command.endswith('?'):
                    response = model.instrument.query(command)
                else:
                    model.instrument.write(command)
            self.command_input.clear()

        except Exception as e:
            self._handle_error(str(e))


================================================================================
*** script_view.py ***
### src/pymetr/ui/views/script_view.py ###
================================================================================

from typing import Optional
from PySide6.QtWidgets import (
    QVBoxLayout, QPlainTextEdit, QWidget, QTextEdit
)
from PySide6.QtGui import (
    QSyntaxHighlighter, QTextCharFormat, QColor, 
    QFont, QTextCursor, QPainter, QTextFormat
)
from PySide6.QtCore import Qt, Signal, QRect, QSize, QRegularExpression

from pymetr.ui.views.base import BaseWidget
from pymetr.core.logging import logger

class LineNumberArea(QWidget):
    """Widget for displaying line numbers."""
    
    def __init__(self, editor):
        super().__init__(editor)
        self.editor = editor

    def sizeHint(self):
        return QSize(self.editor.line_number_area_width(), 0)

    def paintEvent(self, event):
        self.editor.line_number_area_paint_event(event)

class PythonHighlighter(QSyntaxHighlighter):
    """
    Syntax highlighter for Python code with a bright, neon-inspired palette.
    Adjust as you see fit!
    """
    
    def __init__(self, document):
        super().__init__(document)
        self._rules = []
        self._setup_formats()
        self._initialize_rules()

    def _setup_formats(self):
        """Initialize text formats for different syntax elements."""
        # A bright/neon palette example:
        self.formats = {
            # Purple neon for keywords
            'keyword':   self._create_format("#9D00FF", bold=True),  
            # Electric cyan for builtins
            'builtin':   self._create_format("#5E57FF", bold=True),
            # Bright orange for functions
            'function':  self._create_format("#FF9535", bold=False),
            # Slightly subdued green for comments (italic)
            'comment':   self._create_format("#4BAA36", italic=True),
            # Neon yellow for strings
            'string':    self._create_format("#4BEE36", bold=False),
            # Gold for numbers
            'number':    self._create_format("#5E57FF", bold=False),
            # Neon pink for decorators
            'decorator': self._create_format("#F23CA6", bold=False),
        }

    def _create_format(self, color: str, bold: bool=False, italic: bool=False) -> QTextCharFormat:
        fmt = QTextCharFormat()
        fmt.setForeground(QColor(color))
        if bold:
            fmt.setFontWeight(QFont.Bold)
        if italic:
            fmt.setFontItalic(True)
        return fmt

    def _initialize_rules(self):
        """Setup syntax highlighting rules using regular expressions."""
        keywords = [
            'and', 'as', 'assert', 'break', 'class', 'continue', 'def',
            'del', 'elif', 'else', 'except', 'False', 'finally', 'for',
            'from', 'global', 'if', 'import', 'in', 'is', 'lambda',
            'None', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return',
            'True', 'try', 'while', 'with', 'yield'
        ]

        # Mark keywords
        for word in keywords:
            pattern = QRegularExpression(r'\b' + word + r'\b')
            self._rules.append((pattern, self.formats['keyword']))

        # Additional patterns
        self._rules.extend([
            # Functions (sequence of word chars followed by parentheses)
            (QRegularExpression(r'\b[A-Za-z0-9_]+(?=\s*\()'), self.formats['function']),
            # Strings (double or single quoted)
            (QRegularExpression(r'"[^"\\]*(\\.[^"\\]*)*"'), self.formats['string']),
            (QRegularExpression(r'\'[^\'\\]*(\\.[^\'\\]*)*\''), self.formats['string']),
            # Comments (#...)
            (QRegularExpression(r'#[^\n]*'), self.formats['comment']),
            # Numbers (simple integer pattern)
            (QRegularExpression(r'\b\d+\b'), self.formats['number']),
            # Decorators (@something)
            (QRegularExpression(r'@\w+'), self.formats['decorator']),
        ])

    def highlightBlock(self, text: str):
        """Apply highlighting to a block of text."""
        for pattern, fmt in self._rules:
            matches = pattern.globalMatch(text)
            while matches.hasNext():
                match = matches.next()
                self.setFormat(match.capturedStart(), match.capturedLength(), fmt)

class ScriptEditor(QPlainTextEdit):
    """Enhanced text editor for Python scripts."""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        
        # Line number area
        self.line_number_area = LineNumberArea(self)
        
        # Setup editor appearance
        self._setup_editor()
        
        # Connect signals
        self.blockCountChanged.connect(self.update_line_number_area_width)
        self.updateRequest.connect(self.update_line_number_area)
        self.cursorPositionChanged.connect(self.highlight_current_line)
        
        # Initial setup
        self.update_line_number_area_width(0)
        self.highlight_current_line()

    def _setup_editor(self):
        """Configure editor appearance and behavior."""
        # Set default font
        font = QFont("Consolas", 11)
        self.setFont(font)
        
        # Configure tab stops and wrapping
        self.setTabStopDistance(self.fontMetrics().horizontalAdvance(' ') * 4)
        self.setLineWrapMode(QPlainTextEdit.NoWrap)

    def line_number_area_width(self) -> int:
        digits = len(str(max(1, self.blockCount())))
        space = 3 + self.fontMetrics().horizontalAdvance('9') * digits
        return space

    def update_line_number_area_width(self, _):
        self.setViewportMargins(self.line_number_area_width(), 0, 0, 0)

    def update_line_number_area(self, rect, dy):
        if dy:
            self.line_number_area.scroll(0, dy)
        else:
            self.line_number_area.update(0, rect.y(), 
                self.line_number_area.width(), rect.height())

    def resizeEvent(self, event):
        super().resizeEvent(event)
        cr = self.contentsRect()
        self.line_number_area.setGeometry(QRect(cr.left(), cr.top(),
            self.line_number_area_width(), cr.height()))

    def line_number_area_paint_event(self, event):
        painter = QPainter(self.line_number_area)
        painter.fillRect(event.rect(), QColor("#1E1E1E"))

        block = self.firstVisibleBlock()
        block_number = block.blockNumber()
        offset = self.contentOffset()
        top = self.blockBoundingGeometry(block).translated(offset).top()
        bottom = top + self.blockBoundingRect(block).height()

        while block.isValid() and top <= event.rect().bottom():
            if block.isVisible() and bottom >= event.rect().top():
                number = str(block_number + 1)
                painter.setPen(QColor("#858585"))
                painter.drawText(
                    0, int(top),
                    self.line_number_area.width(),
                    self.fontMetrics().height(),
                    Qt.AlignRight, number
                )

            block = block.next()
            top = bottom
            bottom = top + self.blockBoundingRect(block).height()
            block_number += 1

    def highlight_current_line(self):
        extra_selections = []

        if not self.isReadOnly():
            selection = QTextEdit.ExtraSelection()
            # A slightly lighter background to show the active line
            selection.format.setBackground(QColor("#282828"))
            selection.format.setProperty(QTextFormat.FullWidthSelection, True)
            selection.cursor = self.textCursor()
            selection.cursor.clearSelection()
            extra_selections.append(selection)

        self.setExtraSelections(extra_selections)

class ScriptView(BaseWidget):
    """Core widget for editing Python scripts."""
    
    content_changed = Signal()  # Emitted when text content changes
    
    def __init__(self, state, model_id: str, parent=None):
        super().__init__(state, parent)
        self._original_content = ""  # Store original content for modification checking
        self._setup_ui()
        self.set_model(model_id)

    def _setup_ui(self):
        """Initialize the core editor UI."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # Core editor
        self.editor = ScriptEditor()
        self.highlighter = PythonHighlighter(self.editor.document())
        layout.addWidget(self.editor)
        
        # Connect editor signals
        self.editor.textChanged.connect(self.content_changed)

    def set_font(self, font: QFont):
        """Update editor font."""
        self.editor.setFont(font)

    def get_content(self) -> str:
        """Get current editor content."""
        return self.editor.toPlainText()

    def set_content(self, content: str):
        """Set editor content."""
        self.editor.setPlainText(content)

    def set_original_content(self, content: str):
        """Set the baseline content for modification checking."""
        self._original_content = content

    def has_unsaved_changes(self) -> bool:
        """Check if current content differs from original."""
        return self.get_content() != self._original_content

    def set_read_only(self, read_only: bool):
        """Set editor read-only state."""
        self.editor.setReadOnly(read_only)



================================================================================
*** table_view.py ***
### src/pymetr/ui/views/table_view.py ###
================================================================================

# views/widgets/table_view.py
from typing import Optional, Any
from PySide6.QtWidgets import (
    QVBoxLayout, QTableWidget, QTableWidgetItem, 
    QHeaderView
)
from PySide6.QtCore import Qt, Signal
import pandas as pd

from pymetr.ui.views.base import BaseWidget
from pymetr.core.logging import logger

class TableView(BaseWidget):
    """Core widget for displaying data tables with sorting."""
    
    # Signal: emits a DataFrame containing the data from the selected rows.
    selection_changed = Signal(pd.DataFrame)
    
    def __init__(self, state, model_id: str, parent=None):
        super().__init__(state, parent)
        self._setup_ui()
        self.set_model(model_id)
        
    def _setup_ui(self):
        """Initialize the UI components."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)
        
        # Create the QTableWidget.
        self.table = QTableWidget()
        self.table.setAlternatingRowColors(True)
        self.table.setSortingEnabled(True)
        
        # Configure header
        header = self.table.horizontalHeader()
        header.setDefaultSectionSize(100)
        header.setMinimumSectionSize(50)
        header.setSectionResizeMode(QHeaderView.Stretch) 
        
        # Set selection behavior
        self.table.setSelectionBehavior(QTableWidget.SelectRows)
        self.table.setSelectionMode(QTableWidget.ExtendedSelection)
        
        # Apply a custom stylesheet
        self.table.setStyleSheet("""
            QTableWidget {
                background-color: #1E1E1E;
                alternate-background-color: #252525;
                color: #D4D4D4;
                gridline-color: #2D2D2D;
                selection-background-color: #264F78;
                selection-color: #FFFFFF;
            }
            QHeaderView::section {
                background-color: #2D2D2D;
                color: #FFFFFF;
                padding: 4px;
                border: none;
                border-right: 1px solid #3D3D3D;
            }
        """)
        
        layout.addWidget(self.table)
        
        # Connect the selection change signal
        self.table.itemSelectionChanged.connect(self._handle_selection_changed)
            
    def handle_property_update(self, prop: str, value: Any):
        """Handle model property changes. (Overriding BaseWidget's method)"""
        if prop == 'data':
            self._update_table(value)
            
    def _update_table(self, data: pd.DataFrame):
        """Update the QTableWidget with new data."""
        if not isinstance(data, pd.DataFrame):
            logger.error(f"Expected DataFrame, got {type(data)}")
            return
            
        try:
            # Clear the current table contents.
            self.table.setRowCount(0)
            self.table.setColumnCount(0)
            
            # Set dimensions based on the DataFrame.
            self.table.setRowCount(len(data))
            self.table.setColumnCount(len(data.columns))
            
            # Set the header labels.
            self.table.setHorizontalHeaderLabels(data.columns.tolist())
            
            # Populate the table with data.
            for row_idx, (_, row) in enumerate(data.iterrows()):
                for col_idx, cell_value in enumerate(row):
                    item = self._create_item(cell_value)
                    self.table.setItem(row_idx, col_idx, item)
                    
        except Exception as e:
            logger.error(f"Error updating table: {e}")
            
    def _create_item(self, value: Any) -> QTableWidgetItem:
        """Create a properly formatted QTableWidgetItem for a given value."""
        item = QTableWidgetItem()
        
        if pd.isna(value):
            item.setText("")
            item.setData(Qt.DisplayRole, None)
        elif isinstance(value, (int, float)):
            text = f"{value:.6g}" if isinstance(value, float) else str(value)
            item.setText(text)
            item.setData(Qt.DisplayRole, value)
            item.setTextAlignment(Qt.AlignRight | Qt.AlignVCenter)
        elif isinstance(value, bool):
            item.setText(str(value))
            item.setData(Qt.DisplayRole, int(value))
            item.setTextAlignment(Qt.AlignCenter | Qt.AlignVCenter)
        else:
            item.setText(str(value))
            item.setData(Qt.DisplayRole, str(value))
            item.setTextAlignment(Qt.AlignLeft | Qt.AlignVCenter)
            
        item.setFlags(item.flags() & ~Qt.ItemIsEditable)  # Make the cell read-only.
        return item
        
    def _handle_selection_changed(self):
        """Emit the data from selected rows as a DataFrame."""
        if self.model:
            data = self.get_selected_data()
            self.selection_changed.emit(data)
        
    def get_selected_data(self) -> pd.DataFrame:
        """Retrieve data from the currently selected rows."""
        if not self.model:
            return pd.DataFrame()
            
        data = self.model.get_property('data')
        if not isinstance(data, pd.DataFrame):
            return pd.DataFrame()
            
        selected_rows = sorted(set(item.row() for item in self.table.selectedItems()))
        return data.iloc[selected_rows].copy()



================================================================================
*** cursor_handler.py ***
### src/pymetr/ui/views/plot/cursor_handler.py ###
================================================================================

from PySide6.QtCore import QObject, Qt
import pyqtgraph as pg
from pymetr.core.logging import logger
from typing import Dict, Any

class CursorHandler(QObject):
    """
    CursorHandler for managing cursors on a plot.
    """
    # Add a style mapping dictionary
    _style_map = {
        'solid': Qt.SolidLine,
        'dash': Qt.DashLine,
        'dot': Qt.DotLine,
        'dashdot': Qt.DashDotLine
    }

    def __init__(self, plot_item: pg.PlotItem, state):
        """
        Initialize the CursorHandler.

        Args:
            plot_item: Main plot for cursor overlays.
            state: The ApplicationState instance.
        """
        super().__init__()
        self.plot_item = plot_item
        self.state = state  # Save state for lookups
        self.cursors: Dict[str, pg.InfiniteLine] = {}

        logger.debug("CursorHandler initialized")

        # Connect to plot item signals as needed.
        # For example, if you have a mechanism to detect cursor movement,
        # you might connect a lambda to call _handle_cursor_moved.

    @staticmethod
    def _get_qt_line_style(style_str: str) -> Qt.PenStyle:
        """Convert string style to Qt PenStyle."""
        styles = {
            'solid': Qt.SolidLine,
            'dash': Qt.DashLine,
            'dot': Qt.DotLine,
            'dashdot': Qt.DashDotLine
        }
        return styles.get(style_str.lower(), Qt.SolidLine)
    
    def handle_property_change(self, model_id: str, model_type: str, prop: str, value: Any) -> None:
        """Handle cursor property changes."""
        if model_id not in self.cursors:
            logger.debug(f"[CursorHandler] Cursor {model_id} not found.")
            return

        logger.debug(f"[CursorHandler] Updating cursor {model_id}: prop={prop}, value={value}")
        try:
            cursor_line = self.cursors[model_id]
            
            # Check if cursor still exists
            if not cursor_line.scene():
                logger.debug(f"[CursorHandler] Cursor {model_id} already deleted")
                return
            
            if prop == "position":
                cursor_line.setValue(value)
            elif prop == "axis":
                try:
                    # Handle axis change - recreate cursor with new angle
                    angle = 90 if value == "x" else 0
                    pos = cursor_line.value()
                    current_pen = cursor_line.pen
                    is_visible = cursor_line.isVisible()
                    is_movable = cursor_line.movable
                    
                    # Remove old cursor
                    if cursor_line.scene():
                        self.plot_item.removeItem(cursor_line)
                    
                    # Create new cursor with updated angle
                    new_cursor = pg.InfiniteLine(
                        pos=pos, 
                        angle=angle,
                        pen=current_pen,
                        movable=is_movable
                    )
                    # Set visibility after creation
                    new_cursor.setVisible(is_visible)
                    
                    self.plot_item.addItem(new_cursor)
                    self.cursors[model_id] = new_cursor
                except Exception as e:
                    logger.error(f"Error recreating cursor: {e}")
                    
            elif prop == "color":
                try:
                    current_pen = cursor_line.pen
                    pen = pg.mkPen(
                        color=value,
                        width=current_pen.width(),
                        style=current_pen.style()
                    )
                    cursor_line.setPen(pen)
                except Exception as e:
                    logger.error(f"Error updating cursor color: {e}")
                    
            elif prop == "style":
                try:
                    style_map = {
                        'solid': Qt.SolidLine,
                        'dash': Qt.DashLine,
                        'dot': Qt.DotLine,
                        'dashdot': Qt.DashDotLine
                    }
                    current_pen = cursor_line.pen
                    qt_style = style_map.get(value, Qt.SolidLine)
                    pen = pg.mkPen(
                        color=current_pen.color(),
                        width=current_pen.width(),
                        style=qt_style
                    )
                    cursor_line.setPen(pen)
                except Exception as e:
                    logger.error(f"Error updating cursor style: {e}")
                    
            elif prop == "width":
                try:
                    current_pen = cursor_line.pen
                    pen = pg.mkPen(
                        color=current_pen.color(),
                        width=int(value),
                        style=current_pen.style()
                    )
                    cursor_line.setPen(pen)
                except Exception as e:
                    logger.error(f"Error updating cursor width: {e}")
                    
            elif prop == "visible":
                if cursor_line.scene():  # Only set if cursor still exists
                    cursor_line.setVisible(bool(value))
            else:
                logger.warning(f"Unhandled cursor property: {prop}")
                
        except Exception as e:
            logger.error(f"Error updating cursor {model_id}.{prop}: {e}")

    def add_cursor(self, cursor_model) -> None:
        """Add a new cursor from a model."""
        cursor_id = cursor_model.id
        if cursor_id in self.cursors:
            return
        try:
            position = cursor_model.get_property('position', 0.0)
            axis = cursor_model.get_property('axis', 'x')
            color = cursor_model.get_property('color', '#FFFF00')
            style = cursor_model.get_property('style', 'solid')
            width = cursor_model.get_property('width', 1)
            visible = cursor_model.get_property('visible', True)

            # Create pen with proper style
            pen = pg.mkPen(
                color=color,
                width=width,
                style=self._get_qt_line_style(style)
            )

            # Create cursor with proper angle based on axis
            angle = 90 if axis == "x" else 0
            cursor_line = pg.InfiniteLine(
                pos=position,
                angle=angle,
                pen=pen,
                movable=True
            )
            
            cursor_line.setVisible(visible)
            self.plot_item.addItem(cursor_line)
            self.cursors[cursor_id] = cursor_line

            logger.debug(f"Added cursor {cursor_id} at position {position}")
        except Exception as e:
            logger.error(f"Error adding cursor {cursor_id}: {e}")

    def remove_cursor(self, cursor_id: str) -> None:
        """Remove a cursor."""
        if cursor_id not in self.cursors:
            return
        try:
            cursor_line = self.cursors[cursor_id]
            if cursor_line.scene():  # Check if cursor still exists
                self.plot_item.removeItem(cursor_line)
            del self.cursors[cursor_id]
            logger.debug(f"Removed cursor {cursor_id}")
        except Exception as e:
            logger.error(f"Error removing cursor {cursor_id}: {e}")

    def clear_all(self) -> None:
        """Remove all cursors."""
        for cursor_id in list(self.cursors.keys()):
            self.remove_cursor(cursor_id)

    def _handle_cursor_moved(self, cursor_id: str) -> None:
        """
        Called when a cursor is moved interactively.
        Use the stored state to look up the cursor model.
        """
        try:
            cursor_model = self.state.get_model(cursor_id)
            if cursor_model is None:
                return
            # Here you can update the model based on the new cursor position.
            # For example, if the cursor is movable:
            new_pos = self.cursors[cursor_id].value()
            cursor_model.set_property('position', new_pos)
        except Exception as e:
            logger.error(f"Error handling cursor move for {cursor_id}: {e}")



================================================================================
*** marker_handler.py ***
### src/pymetr/ui/views/plot/marker_handler.py ###
================================================================================

from PySide6.QtCore import QObject
import pyqtgraph as pg
import numpy as np
from typing import Dict, Any, Optional
from pymetr.core.logging import logger

class MarkerHandler(QObject):
    """
    Enhanced marker management with optimized scatter plot handling and
    efficient label updates. Uses a single ScatterPlotItem for better performance.
    """

    def __init__(self, plot_item: pg.PlotItem, state):
        """
        Initialize the MarkerHandler.

        Args:
            plot_item: Main plot for marker overlays.
            state: The ApplicationState instance for model lookups.
        """
        super().__init__()
        self.plot_item = plot_item
        self.state = state  # Save the state for all lookups
        # Main storage
        self.markers: Dict[str, Dict] = {}  # {marker_id: {point: dict, label: pg.TextItem}}
        self.marker_labels: Dict[str, pg.TextItem] = {}
        
        # Batch update support
        self.batch_mode = False
        self.pending_updates: Dict[str, Dict[str, Any]] = {}
        
        # Use a single ScatterPlotItem for all markers
        self.scatter_plot = pg.ScatterPlotItem()
        self.plot_item.addItem(self.scatter_plot)
        
        logger.debug("MarkerHandler initialized")

    def begin_update(self) -> None:
        """Enable batch update mode."""
        self.batch_mode = True
        self.pending_updates.clear()

    def end_update(self) -> None:
        """Apply pending updates and exit batch mode."""
        self.batch_mode = False
        self._apply_pending_updates()

    def add_marker(self, marker_model) -> None:
        """
        Add a new marker from a model.

        Args:
            marker_model: Marker model containing position and style properties.
        """
        marker_id = marker_model.id
        if marker_id in self.markers:
            logger.warning(f"Marker {marker_id} already exists")
            return

        try:
            # Extract main properties
            x = marker_model.get_property('x', 0.0)
            y = marker_model.get_property('y', 0.0)
            color = marker_model.get_property('color', '#FFFF00')
            size = marker_model.get_property('size', 8)
            symbol = marker_model.get_property('symbol', 'o')
            visible = marker_model.get_property('visible', True)
            label_text = marker_model.get_property('label', '')
            
            # Get uncertainty properties
            uncertainty_visible = marker_model.get_property('uncertainty_visible', False)
            uncertainty_upper = marker_model.get_property('uncertainty_upper', 0.0)
            uncertainty_lower = marker_model.get_property('uncertainty_lower', 0.0)

            # Create point data for scatter plot
            point = {
                'pos': (x, y),
                'brush': pg.mkBrush(color),
                'size': size,
                'symbol': symbol,
                'pen': pg.mkPen('w', width=0.5),
                'data': marker_id,  # Store ID for click handling
                'visible': visible,
                'uncertainty': {
                    'visible': uncertainty_visible,
                    'upper': uncertainty_upper,
                    'lower': uncertainty_lower
                }
            }

            # Create and style label
            label = pg.TextItem(
                text=label_text,
                color=color,
                anchor=(0.5, 1.0),
                fill=pg.mkBrush('#2A2A2A')
            )
            label.setVisible(visible and bool(label_text))
            label.setPos(x, y)

            # Store marker components
            self.markers[marker_id] = {'point': point, 'label': label}
            self.marker_labels[marker_id] = label
            
            # Add label to plot
            self.plot_item.addItem(label)
            
            # Update scatter plot
            self._update_scatter()
            
            logger.debug(f"Added marker {marker_id} at ({x}, {y})")

        except Exception as e:
            logger.error(f"Error adding marker {marker_id}: {e}")
            self.remove_marker(marker_id)

    def _apply_marker_update(self, marker_id: str, prop: str, value: Any) -> None:
        """Apply a single property update to a marker."""
        try:
            marker = self.markers[marker_id]
            point = marker['point']
            label = marker['label']

            update_scatter = False
            
            # Handle top-level properties
            if prop in ('x', 'y'):
                # Update position
                x, y = point['pos']
                new_pos = (value, y) if prop == 'x' else (x, value)
                point['pos'] = new_pos
                label.setPos(*new_pos)
                update_scatter = True
                
            elif prop == "color":
                # Update colors
                point['brush'] = pg.mkBrush(value)
                label.setColor(value)
                update_scatter = True
                
            elif prop == "size":
                point['size'] = value
                update_scatter = True
                
            elif prop == "symbol":
                point['symbol'] = value
                update_scatter = True
                
            elif prop == "label":
                label.setText(value)
                label.setVisible(bool(value) and point['visible'])
                
            elif prop == "visible":
                point['visible'] = bool(value)
                label.setVisible(bool(value) and bool(label.text()))
                update_scatter = True

            elif prop == "interpolation_mode":
                # Store interpolation mode if needed
                point['interpolation_mode'] = value
                
            # Handle uncertainty properties
            elif prop == "uncertainty_visible":
                point['uncertainty']['visible'] = bool(value)
                update_scatter = True
                
            elif prop == "uncertainty_upper":
                point['uncertainty']['upper'] = value
                update_scatter = True
                
            elif prop == "uncertainty_lower":
                point['uncertainty']['lower'] = value
                update_scatter = True
                
            else:
                logger.warning(f"Unhandled marker property: {prop}")
                return

            if update_scatter:
                self._update_scatter()

        except Exception as e:
            logger.error(f"Error updating marker {marker_id}.{prop}: {e}")

    def _handle_parameter_change(self, param, value):
        """Handle parameter changes with trace binding awareness."""
        try:
            # Get current model
            model = self.state.get_model(self.model_id)
            if not model:
                return
            
            # Special handling for y-value when trace bound
            if param.name() == 'y' and model.bound_to_trace:
                return  # Ignore y changes when bound to trace
            
            # Handle uncertainty visibility changes
            if param.name() == 'uncertainty_visible':
                uncertainty_group = self.child('Uncertainty')
                if uncertainty_group:
                    for child in uncertainty_group.children():
                        if child.name() != 'uncertainty_visible':
                            child.setOpts(visible=value)
            
            # Get the full property name for parameter
            prop_name = param.name()
            
            # Update the model
            self.set_model_property(prop_name, value)
            
        except Exception as e:
            logger.error(f"Error handling parameter change: {e}")

    def update_marker(self, marker_id: str, prop: str, value: Any) -> None:
        """
        Update a marker property with batch support.

        Args:
            marker_id: ID of the marker.
            prop: Property name.
            value: New value.
        """
        if marker_id not in self.markers:
            logger.error(f"Marker {marker_id} not found")
            return

        if self.batch_mode:
            if marker_id not in self.pending_updates:
                self.pending_updates[marker_id] = {}
            self.pending_updates[marker_id][prop] = value
        else:
            self._apply_marker_update(marker_id, prop, value)

    def remove_marker(self, marker_id: str) -> None:
        """
        Remove a marker and clean up its resources.

        Args:
            marker_id: ID of the marker to remove.
        """
        if marker_id in self.markers:
            # Remove label
            if marker_id in self.marker_labels:
                self.plot_item.removeItem(self.marker_labels[marker_id])
                del self.marker_labels[marker_id]

            # Remove marker data
            del self.markers[marker_id]
            
            # Update scatter plot
            self._update_scatter()
            
            logger.debug(f"Removed marker {marker_id}")

    def clear_all(self) -> None:
        """Remove all markers and clean up."""
        # Remove all labels
        for marker_id in list(self.marker_labels.keys()):
            self.plot_item.removeItem(self.marker_labels[marker_id])
        
        # Clear storage
        self.markers.clear()
        self.marker_labels.clear()
        
        # Clear scatter plot
        self.scatter_plot.clear()
        
        logger.debug("All markers cleared")

    def _apply_pending_updates(self) -> None:
        """Apply all pending marker updates."""
        for marker_id, updates in self.pending_updates.items():
            for prop, value in updates.items():
                self._apply_marker_update(marker_id, prop, value)
        self.pending_updates.clear()

    def _apply_marker_update(self, marker_id: str, prop: str, value: Any) -> None:
        """Apply a single property update to a marker."""
        try:
            marker = self.markers[marker_id]
            point = marker['point']
            label = marker['label']

            update_scatter = False
            
            if prop in ('x', 'y'):
                # Update position
                x, y = point['pos']
                new_pos = (value, y) if prop == 'x' else (x, value)
                point['pos'] = new_pos
                label.setPos(*new_pos)
                update_scatter = True
                
            elif prop == "color":
                # Update colors
                point['brush'] = pg.mkBrush(value)
                label.setColor(value)  # Update text color
                update_scatter = True
                
            elif prop == "size":
                point['size'] = value
                update_scatter = True
                
            elif prop == "symbol":
                point['symbol'] = value
                update_scatter = True
                
            elif prop == "label":
                label.setText(value)
                label.setVisible(bool(value) and point.get('visible', True))
                
            elif prop == "visible":
                is_visible = bool(value)
                old_color = point['brush'].color()
                old_color.setAlpha(255 if is_visible else 0)
                point['brush'] = pg.mkBrush(old_color)
                label.setVisible(is_visible and bool(label.text()))
                update_scatter = True
                
            else:
                logger.warning(f"Unhandled marker property: {prop}")
                return

            if update_scatter:
                self._update_scatter()

        except Exception as e:
            logger.error(f"Error updating marker {marker_id}.{prop}: {e}")


    def _update_scatter(self) -> None:
        """Update the ScatterPlotItem with current markers."""
        try:
            points = []
            for marker in self.markers.values():
                point = marker['point']
                if point.get('visible', True):  # Only include visible points
                    # Create a clean point dict without extra properties
                    scatter_point = {
                        'pos': point['pos'],
                        'brush': point['brush'],
                        'size': point['size'],
                        'symbol': point['symbol'],
                        'pen': point['pen'],
                        'data': point['data']
                    }
                    points.append(scatter_point)
                    
            self.scatter_plot.setData(points)
        except Exception as e:
            logger.error(f"Error updating scatter plot: {e}")

    def update_label_positions(self) -> None:
        """Update all label positions (e.g., after plot range changes)."""
        try:
            for marker_id, marker in self.markers.items():
                if marker_id in self.marker_labels:
                    pos = marker['point']['pos']
                    self.marker_labels[marker_id].setPos(*pos)
        except Exception as e:
            logger.error(f"Error updating label positions: {e}")

    def get_marker_at_pos(self, pos) -> Optional[str]:
        """
        Get marker ID at the given position.
        """
        try:
            points = self.scatter_plot.pointsAt(pos)
            if points:
                return points[0].data()
            return None
        except Exception as e:
            logger.error(f"Error getting marker at position: {e}")
            return None
        
    def handle_property_change(self, model_id: str, model_type: str, prop: str, value: Any) -> None:
        """
        Handle marker property changes from the parameter tree.
        Handles both top-level and uncertainty group properties.
        """
        if model_id not in self.markers:
            logger.debug(f"[MarkerHandler] Marker {model_id} not found.")
            return

        logger.debug(f"[MarkerHandler] Updating marker {model_id}: prop={prop}, value={value}")
        try:
            # Check if property is in uncertainty group
            if prop.startswith('uncertainty_'):
                self._apply_marker_update(model_id, prop, value)
            else:
                # Handle top-level property
                self._apply_marker_update(model_id, prop, value)
        except Exception as e:
            logger.error(f"Error updating marker {model_id}.{prop}: {e}")



================================================================================
*** plot_view.py ***
### src/pymetr/ui/views/plot/plot_view.py ###
================================================================================

from typing import Dict, Any
from PySide6.QtWidgets import QVBoxLayout, QSplitter, QSizePolicy
from PySide6.QtCore import Qt, Slot, QTimer, QEvent
from PySide6.QtGui import QTransform
import pyqtgraph as pg
import numpy as np

from pymetr.ui.views.base import BaseWidget
from pymetr.core.logging import logger
from .trace_handler import TraceHandler
from .cursor_handler import CursorHandler
from .marker_handler import MarkerHandler

class PlotView(BaseWidget):
    """
    Enhanced PlotView that efficiently routes model updates to specialized handlers.
    Coordinates real-time updates between traces, cursors, and markers.
    """

    def __init__(self, state, model_id: str, parent=None):
        logger.debug(f"Initializing PlotView with model_id: {model_id}")
        super().__init__(state, parent)
        self._suppress_roi_updates = False  # For ROI update loops

        # Mapping of trace id to ROI plot curve items for efficient updates.
        self.roi_curves: Dict[str, pg.PlotDataItem] = {}

        # Initialize UI and handlers
        self._setup_ui()

        # Connect state signals with proper routing
        self.state.model_registered.connect(self._handle_model_registered)
        self.state.model_changed.connect(self._handle_model_changed)
        self.state.model_removed.connect(self._handle_model_removed)

        # Geometry update handling with debouncing (for ~60fps updates)
        self._geometry_update_timer = QTimer(self)
        self._geometry_update_timer.setSingleShot(True)
        self._geometry_update_timer.timeout.connect(self._update_geometries)
        self._geometry_update_needed = False

        # ROI update handling with debouncing (for ~20fps updates)
        self._roi_update_timer = QTimer(self)
        self._roi_update_timer.setSingleShot(True)
        self._roi_update_timer.timeout.connect(self._apply_roi_update)
        self._roi_connected = False  # Track ROI signal connection state

        # Set model to initialize handlers
        self.set_model(model_id)
        logger.debug("PlotView initialized")

    def _setup_ui(self) -> None:
        """Initialize the plot UI, main plot, ROI plot, and handlers."""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)

        # Use a vertical splitter to hold the main plot and the ROI plot area
        self.plot_container = QSplitter(Qt.Vertical)
        layout.addWidget(self.plot_container)

        # --- Main Plot Setup ---
        self.plot_layout = pg.GraphicsLayoutWidget()
        self.plot_layout.setBackground('#1E1E1E')
        self.plot_container.addWidget(self.plot_layout)

        # Create main plot (renamed to main_plot_item for clarity)
        self.main_plot_item = self.plot_layout.addPlot(row=0, col=0)
        self.main_plot_item.setTitle("", size="20pt", color='w')
        try:
            self.legend = self.main_plot_item.addLegend(offset=(70, 70))
            logger.debug("Legend created")
        except Exception as e:
            logger.error(f"Legend creation failed: {e}")
            self.legend = None

        # Connect main plot range change to update ROI
        self.main_plot_item.scene().sigMouseClicked.connect(self.handle_mouse_clicked)
        self.main_plot_item.sigRangeChanged.connect(self._handle_main_plot_range_changed)

        # --- ROI Plot Setup ---
        self.roi_plot_area = pg.PlotWidget()
        self.roi_plot_area.setMinimumHeight(60)
        self.roi_plot_area.setMaximumHeight(60)
        self.roi_plot_area.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Fixed)
        self.roi_plot_area.setBackground('#2A2A2A')
        self.roi_plot_item = self.roi_plot_area.getPlotItem()
        self.roi_plot_item.showGrid(x=True, y=False)
        self.roi_plot_item.getAxis('left').hide()
        self.roi_plot_item.setMouseEnabled(x=False, y=False)
        bottom_axis = self.roi_plot_item.getAxis('bottom')
        bottom_axis.setPen(pg.mkPen('w'))
        bottom_axis.setTextPen(pg.mkPen('w'))

        # Add ROI selector with styling
        self.roi = pg.LinearRegionItem(
            brush=pg.mkBrush(color=(100, 100, 255, 50)),
            hoverBrush=pg.mkBrush(color=(100, 100, 255, 80)),
            movable=True
        )
        self.roi_plot_item.addItem(self.roi)
        self.roi.sigRegionChanged.connect(self._handle_roi_changed)

        # Add ROI plot area to the container
        self.plot_container.addWidget(self.roi_plot_area)

    def handle_mouse_clicked(self, event):
        """Handle mouse clicks for autoscaling."""
        if event.double():
            # scene_point = event.scenePos()
            # # transform = QTransform()
            # # clicked_item = self.main_plot_itemplot_item.scene().itemAt(scene_point, transform)
            
            # # Check if clicked on an isolated axis
            # for trace_id, axis in self.trace_axes.items():
            #     if axis.boundingRect().contains(axis.mapFromScene(scene_point)):
            #         if trace_id in self.trace_view_boxes:
            #             self.trace_view_boxes[trace_id].autoRange(padding=0)
            #         return
                    
            # If not on an axis, autoscale main plot
            self.main_plot_item.autoRange()

    def set_model(self, model_id: str) -> None:
        """
        Set the plot model and initialize all components.
        Extends BaseWidget.set_model to handle plot-specific initialization.
        """
        # Call base class implementation first
        super().set_model(model_id)
        
        if not self.model:
            logger.error(f"Failed to set model: {model_id}")
            return
            
        try:
            # Update basic plot settings
            self._update_plot_settings()
            
            # Initialize handlers TODO: Clean this up?  Why is the pattern different?
            self.trace_handler = TraceHandler(self.main_plot_item, self.plot_layout)
            self.cursor_handler = CursorHandler(self.main_plot_item, self.state)
            self.marker_handler = MarkerHandler(self.main_plot_item, self.state)
            
            # Initialize existing traces
            for trace in self.model.get_traces():
                self.trace_handler.add_trace(trace)
                self._create_or_update_roi_curve(trace)
                logger.debug(f"Initialized trace {trace.id} during model set")
            
            # Initialize existing cursors
            for cursor in self.model.get_cursors():
                self.cursor_handler.add_cursor(cursor)
                logger.debug(f"Initialized cursor {cursor.id} during model set")
                
            # Initialize existing markers
            for marker in self.model.get_markers():
                self.marker_handler.add_marker(marker)
                logger.debug(f"Initialized marker {marker.id} during model set")
                
            # Set initial ROI state if available
            roi = self.model.get_property("roi", None)
            if roi and len(roi) == 2:
                self.roi.setRegion(roi)
            # Set ROI visibility
            roi_visible = self.model.get_property("roi_visible", True)
            self.roi_plot_area.setVisible(roi_visible)
            
            # Queue an immediate ROI update
            self._queue_roi_update()
                
        except Exception as e:
            logger.error(f"Error during plot model initialization: {e}")

    def _is_descendant(self, model_id: str, ancestor_id: str) -> bool:
        """Return True if the model with model_id is a descendant of the model with ancestor_id."""
        current = self.state.get_parent(model_id)
        while current:
            if current.id == ancestor_id:
                return True
            current = self.state.get_parent(current.id)
        return False

    @Slot(str, str, str, object)
    def _handle_model_changed(self, model_id: str, model_type: str, prop: str, value: Any) -> None:
        """
        Handle property changes. We only process changes for:
        - This Plot itself (model_id == self.model_id)
        - A Trace/Cursor/Marker whose *immediate* parent is this Plot.
        """
        try:

            if model_id == self.model_id and model_type == "Plot":
                # This is the Plot itself
                if prop == 'roi':
                    self._suppress_roi_updates = True
                    self.roi.setRegion(value)
                    self.main_plot_item.setXRange(*value, padding=0)
                    self._suppress_roi_updates = False
                    self._queue_roi_update()  # Debounced update
                elif prop == 'roi_visible':
                    self.roi_plot_area.setVisible(value)
                    if value and not self._roi_connected:
                        self.roi.sigRegionChanged.connect(self._handle_roi_changed)
                        self._roi_connected = True
                    elif not value and self._roi_connected:
                        try:
                            self.roi.sigRegionChanged.disconnect(self._handle_roi_changed)
                        except Exception:
                            pass
                        self._roi_connected = False
                else:
                    self._handle_plot_property_change(prop, value)
                return

            # For traces, cursors, markers: only update if I'm their *immediate* parent
            if model_type in ("Trace", "Cursor", "Marker"):
                parent = self.state.get_parent(model_id)
                if parent and parent.id == self.model_id:
                    if model_type == "Trace":
                        self.trace_handler.handle_property_change(model_id, model_type, prop, value)
                        trace_model = self.state.get_model(model_id)
                        if trace_model:
                            self._create_or_update_roi_curve(trace_model)
                        if self.roi_plot_area.isVisible():
                            self._queue_roi_update()  # Debounced update
                    elif model_type == "Cursor":
                        self.cursor_handler.handle_property_change(model_id, model_type, prop, value)
                    elif model_type == "Marker":
                        self.marker_handler.handle_property_change(model_id, model_type, prop, value)
                return

        except Exception as e:
            logger.error(f"Error handling model change: {e}")


    @Slot(str)
    def _handle_model_registered(self, model_id: str) -> None:
        """
        Handle new model registration. Only add it if its *immediate* parent is this Plot.
        """
        try:
            model = self.state.get_model(model_id)
            if not model:
                return

            if model.model_type in ("Trace", "Cursor", "Marker"):
                parent = self.state.get_parent(model_id)
                if parent and parent.id == self.model_id:
                    if model.model_type == "Trace":
                        self.trace_handler.add_trace(model)
                        self._create_or_update_roi_curve(model)
                        if self.roi_plot_area.isVisible():
                            self._queue_roi_update()
                    elif model.model_type == "Cursor":
                        self.cursor_handler.add_cursor(model)
                    elif model.model_type == "Marker":
                        self.marker_handler.add_marker(model)

        except Exception as e:
            logger.error(f"Error handling model registration: {e}")


    @Slot(str)
    def _handle_model_removed(self, model_id: str) -> None:
        """
        Remove a model from the appropriate handler if I'm its *immediate* parent.
        """
        try:
            # If it's in the trace handler
            if model_id in getattr(self.trace_handler, 'traces', {}):
                parent = self.state.get_parent(model_id)
                if parent and parent.id == self.model_id:
                    self.trace_handler.remove_trace(model_id)
                    if model_id in self.roi_curves:
                        self.roi_plot_item.removeItem(self.roi_curves[model_id])
                        del self.roi_curves[model_id]

            # If it's in the cursor handler
            elif model_id in getattr(self.cursor_handler, 'cursors', {}):
                parent = self.state.get_parent(model_id)
                if parent and parent.id == self.model_id:
                    self.cursor_handler.remove_cursor(model_id)

            # If it's in the marker handler
            elif model_id in getattr(self.marker_handler, 'markers', {}):
                parent = self.state.get_parent(model_id)
                if parent and parent.id == self.model_id:
                    self.marker_handler.remove_marker(model_id)

        except Exception as e:
            logger.error(f"Error handling model removal: {e}")

    def _handle_plot_property_change(self, prop: str, value: Any) -> None:
        """Handle plot-specific property changes."""
        try:
            if prop == "background_color":
                self.plot_layout.setBackground(value)
            elif prop == "grid_enabled":
                self.main_plot_item.showGrid(x=value, y=value, alpha=0.3)
            elif prop == "x_lim":  # Changed from x_range to x_lim
                if value and isinstance(value, (list, tuple)) and len(value) == 2:
                    self.main_plot_item.setXRange(value[0], value[1], padding=0)
            elif prop == "y_lim":  # Changed from y_range to y_lim
                if value and isinstance(value, (list, tuple)) and len(value) == 2:
                    self.main_plot_item.setYRange(value[0], value[1], padding=0)
            elif prop == "title":
                self.main_plot_item.setTitle(value, size="20pt", color='w')
        except Exception as e:
            logger.error(f"Error handling plot property change: {e}")

    def _update_plot_settings(self) -> None:
        """Update all plot settings from model."""
        if not self.model:
            return

        try:
            title = self.model.get_property('title', '')
            self.main_plot_item.setTitle(title, size="20pt", color='w')

            grid_enabled = self.model.get_property('grid_enabled', True)
            grid_alpha = self.model.get_property('grid_alpha', 0.3)
            self.main_plot_item.showGrid(x=grid_enabled, y=grid_enabled, alpha=grid_alpha)

            bg_color = self.model.get_property('background_color', '#1E1E1E')
            fg_color = self.model.get_property('foreground_color', '#FFFFFF')
            self.plot_layout.setBackground(bg_color)
            
            for axis in [self.main_plot_item.getAxis('left'), self.main_plot_item.getAxis('bottom')]:
                axis.setPen(pg.mkPen(fg_color))
                axis.setTextPen(pg.mkPen(fg_color))

            self._update_axis_labels()
            self._update_plot_ranges()

        except Exception as e:
            logger.error(f"Error updating plot settings: {e}")

    def _update_axis_labels(self) -> None:
        """Update axis labels and units."""
        try:
            x_label = self.model.get_property('x_label', '')
            y_label = self.model.get_property('y_label', '')
            x_unit = self.model.get_property('x_unit', '')
            y_unit = self.model.get_property('y_unit', '')

            if x_unit:
                x_label = f"{x_label} ({x_unit})"
            if y_unit:
                y_label = f"{y_label} ({y_unit})"

            self.main_plot_item.setLabel('bottom', x_label)
            self.main_plot_item.setLabel('left', y_label)

        except Exception as e:
            logger.error(f"Error updating axis labels: {e}")

    def _update_plot_ranges(self) -> None:
        """Update plot ranges and scaling."""
        try:
            x_lim = self.model.get_property('x_lim')  # Changed from x_range to x_lim
            y_lim = self.model.get_property('y_lim')  # Changed from y_range to y_lim
            
            if x_lim is not None and isinstance(x_lim, (list, tuple)) and len(x_lim) == 2:
                self.main_plot_item.setXRange(x_lim[0], x_lim[1], padding=0)
            if y_lim is not None and isinstance(y_lim, (list, tuple)) and len(y_lim) == 2:
                self.main_plot_item.setYRange(y_lim[0], y_lim[1], padding=0)

            vb = self.main_plot_item.getViewBox()
            vb.invertX(self.model.get_property('x_inverted', False))
            vb.invertY(self.model.get_property('y_inverted', False))

            self.main_plot_item.setLogMode(
                x=self.model.get_property('x_log', False),
                y=self.model.get_property('y_log', False)
            )
        except Exception as e:
            logger.error(f"Error updating plot ranges: {e}")

    def _queue_geometry_update(self) -> None:
        """Queue a geometry update with debouncing."""
        self._geometry_update_needed = True
        self._geometry_update_timer.start(16)  # ~60fps

    def _queue_roi_update(self) -> None:
        """Queue an ROI update with debouncing (~20fps)."""
        if not self._roi_update_timer.isActive():
            self._roi_update_timer.start(100)

    def _update_geometries(self) -> None:
        """Update geometries of all components."""
        if not self._geometry_update_needed:
            return
            
        try:
            rect = self.main_plot_item.getViewBox().sceneBoundingRect()
            self.trace_handler.update_geometry(rect)
            self.marker_handler.update_label_positions()
            self._geometry_update_needed = False
            
        except Exception as e:
            logger.error(f"Error updating geometries: {e}")

    def resizeEvent(self, event) -> None:
        """Handle widget resize efficiently."""
        super().resizeEvent(event)
        self._queue_geometry_update()

    def showEvent(self, event) -> None:
        """Handle widget show efficiently."""
        super().showEvent(event)
        self._queue_geometry_update()

    def clear(self) -> None:
        """Clean up all items and disconnect signals."""
        try:
            self.trace_handler.clear_all()
            self.cursor_handler.clear_all()
            self.marker_handler.clear_all()
            
            self._geometry_update_timer.stop()
            self._roi_update_timer.stop()
            
            try:
                self.state.model_registered.disconnect(self._handle_model_registered)
                self.state.model_changed.disconnect(self._handle_model_changed)
                self.state.model_removed.disconnect(self._handle_model_removed)
            except Exception:
                pass
            
            logger.debug("PlotView cleared")

        except Exception as e:
            logger.error(f"Error clearing PlotView: {e}")

    def _handle_main_plot_range_changed(self, viewbox, ranges):
        """Update ROI when main plot range changes."""
        try:
            if self._suppress_roi_updates:
                return
            # Update the ROI region to match main plot's x-range
            self.roi.setRegion(ranges[0])
            self._queue_roi_update()  # Debounced ROI update
                
        except Exception as e:
            logger.error(f"Error in _handle_main_plot_range_changed: {e}")

    def _handle_roi_changed(self):
        """Handle ROI region changes immediately."""
        try:
            if not self.model or self._suppress_roi_updates:
                return
                
            region = self.roi.getRegion()
            region_list = [float(x) for x in region]
            
            if region_list != self.model.get_property('roi'):
                self.model.set_property('roi', region_list)
                self._suppress_roi_updates = True
                self.main_plot_item.setXRange(*region, padding=0)
                self._suppress_roi_updates = False
                
        except Exception as e:
            logger.error(f"Error handling ROI change: {e}")

    def _apply_roi_update(self):
        """Apply ROI updates by refreshing the ROI plot area with visible traces.
        
        Only update if the ROI plot area is visible and only for traces associated
        with this plot view instance.
        """
        if not self.roi_plot_area.isVisible():
            return

        try:
            # Iterate over traces stored in the trace handler (each is a (model, curve) tuple)
            traces = [tm for tm, curve in self.trace_handler.traces.values()]
            
            # Determine overall x-range using the trace model's data
            x_ranges = []
            for trace in traces:
                data = trace.data  # Assuming trace.data is a tuple (x_data, y_data)
                if data[0].size > 0:
                    x_ranges.append((np.nanmin(data[0]), np.nanmax(data[0])))
            if x_ranges:
                x_min = min(r[0] for r in x_ranges)
                x_max = max(r[1] for r in x_ranges)
                if np.isfinite(x_min) and np.isfinite(x_max):
                    padding = (x_max - x_min) * 0.05
                    self.roi_plot_item.setXRange(x_min - padding, x_max + padding, padding=0)

            # Update or create each ROI curve using the trace model.
            for trace in traces:
                self._create_or_update_roi_curve(trace)

            # Ensure the ROI selector is present.
            if self.roi not in self.roi_plot_item.items:
                self.roi_plot_item.addItem(self.roi)

        except Exception as e:
            logger.error(f"Error applying ROI update for model {self.model_id}: {e}")

    def _create_or_update_roi_curve(self, trace) -> None:
        """
        Create or update an ROI curve for a trace belonging to this plot view instance.
        """
        trace_id = getattr(trace, 'model_id', None) or getattr(trace, 'id', None)
        if trace_id is None:
            logger.error("Trace has no model_id or id; skipping ROI update.")
            return

        # Skip if ROI plot area is not visible
        if not self.roi_plot_area.isVisible():
            # logger.debug(
            #     f"ROI plot area is not visible for model: {self.model_id}. "
            #     f"Skipping ROI curve update for trace '{trace_id}'."
            # )
            return

        # logger.debug(f"Creating/updating ROI curve for trace '{trace_id}' in model: {self.model_id}")

        try:
            # Use the trace model to get data and properties
            data = trace.data  # (x_data, y_data)
            color = trace.color if trace.color is not None else 'w'
            width = trace.width
            style = trace.style
            pen = pg.mkPen(color=color, width=width, style=TraceHandler._get_qt_line_style(style))
            visible = trace.visible

            if trace_id in self.roi_curves:
                roi_curve = self.roi_curves[trace_id]
                roi_curve.setData(data[0], data[1])
                roi_curve.setPen(pen)
                roi_curve.setVisible(visible)
            else:
                roi_curve = self.roi_plot_area.plot(
                    data[0],
                    data[1],
                    pen=pen,
                    name=str(trace_id)
                )
                roi_curve.setVisible(visible)
                self.roi_curves[trace_id] = roi_curve

        except Exception as e:
            logger.error(f"Error in _create_or_update_roi_curve for trace '{trace_id}' in model {self.model_id}: {e}")



================================================================================
*** trace_handler.py ***
### src/pymetr/ui/views/plot/trace_handler.py ###
================================================================================

from PySide6.QtCore import QObject, Qt
import pyqtgraph as pg
import numpy as np
from typing import Dict, Any, Tuple
from pymetr.core.logging import logger

class TraceHandler(QObject):
    """
    High-performance trace handler optimized for real-time visualization.
    """
    
    def __init__(self, plot_item: pg.PlotItem, plot_layout: pg.GraphicsLayoutWidget):
        super().__init__()
        self.plot_item = plot_item
        self.plot_layout = plot_layout
        
        # Store tuple: (trace_model, curve)
        self.traces: Dict[str, Tuple[Any, pg.PlotDataItem]] = {}
        self.isolated_axes: Dict[str, pg.AxisItem] = {}
        self.isolated_view_boxes: Dict[str, pg.ViewBox] = {}
        
        logger.debug("TraceHandler initialized")

    def add_trace(self, trace_model) -> None:
        """Add a new trace from model."""
        trace_id = trace_model.id
        if trace_id in self.traces:
            return

        try:
            # Create curve with initial properties
            pen = pg.mkPen(
                color=trace_model.get_property('color', '#ffffff'),
                width=trace_model.get_property('width', 1),
                style=self._get_qt_line_style(trace_model.get_property('style', 'solid'))
            )

            curve = pg.PlotDataItem(
                trace_model.x_data,
                trace_model.y_data,
                pen=pen,
                name=trace_model.get_property('name', ''),
                connect='finite'
            )

            # Store both model and curve
            self.traces[trace_id] = (trace_model, curve)
            
            # Handle isolation mode
            mode = trace_model.get_property('mode', 'Group')
            logger.debug(f"Adding trace {trace_id} in {mode} mode")
            
            if mode == "Isolate":
                self._setup_isolated_view(trace_id, curve, trace_model)
            else:
                self.plot_item.addItem(curve)

            # Set initial visibility
            curve.setVisible(trace_model.get_property('visible', True))

        except Exception as e:
            logger.error(f"Error adding trace {trace_id}: {e}")
            self.remove_trace(trace_id)

    def handle_property_change(self, model_id: str, model_type: str, prop: str, value: Any):
        """Handle trace property changes."""
        if model_id not in self.traces:
            return

        try:
            _, curve = self.traces[model_id]
            
            if prop == "data":
                x_data, y_data = value
                curve.setData(x_data, y_data, connect='finite')
                
            elif prop == "color":
                pen = curve.opts['pen']
                pen.setColor(pg.mkColor(value))
                curve.setPen(pen)
                if model_id in self.isolated_axes:
                    self.isolated_axes[model_id].setPen(pg.mkPen(value))
                    
            elif prop == "visible":
                curve.setVisible(value)
                if model_id in self.isolated_axes:
                    self.isolated_axes[model_id].setVisible(value)
                    
            elif prop == "width":
                pen = curve.opts['pen']
                pen.setWidth(value)
                curve.setPen(pen)
                
            elif prop == "style":
                pen = curve.opts['pen']
                pen.setStyle(self._get_qt_line_style(value))
                curve.setPen(pen)
                
            elif prop == "mode":
                # Remove from current location
                if curve.scene() == self.plot_item.scene():
                    self.plot_item.removeItem(curve)
                elif model_id in self.isolated_view_boxes:
                    self.isolated_view_boxes[model_id].removeItem(curve)
                    self.plot_layout.removeItem(self.isolated_view_boxes[model_id])
                    del self.isolated_view_boxes[model_id]
                    self.plot_layout.removeItem(self.isolated_axes[model_id])
                    del self.isolated_axes[model_id]
                
                # Add to new location
                if value == "Isolate":
                    model = self.traces[model_id][0]  # Get the model from stored tuple
                    self._setup_isolated_view(model_id, curve, model)
                else:
                    self.plot_item.addItem(curve)

        except Exception as e:
            logger.error(f"Error updating trace {model_id}: {e}")

    def _setup_isolated_view(self, trace_id: str, curve: pg.PlotDataItem, model) -> None:
        """Create an isolated view for a trace."""
        try:
            color = model.get_property('color', '#ffffff')
            axis = pg.AxisItem("right")
            axis.setPen(pg.mkPen(color))
            
            next_col = len(self.isolated_axes) + 1
            self.plot_layout.addItem(axis, row=0, col=next_col)
            self.isolated_axes[trace_id] = axis

            view_box = pg.ViewBox()
            axis.linkToView(view_box)
            view_box.setXLink(self.plot_item.vb)
            
            self.plot_layout.scene().addItem(view_box)
            view_box.setGeometry(self.plot_item.vb.sceneBoundingRect())
            self.isolated_view_boxes[trace_id] = view_box
            
            view_box.addItem(curve)

            # Set initial range if data exists
            y_data = model.y_data
            if y_data.size > 0:
                ymin, ymax = np.nanmin(y_data), np.nanmax(y_data)
                if np.isfinite(ymin) and np.isfinite(ymax):
                    padding = (ymax - ymin) * 0.1
                    view_box.setYRange(ymin - padding, ymax + padding)

        except Exception as e:
            logger.error(f"Error setting up isolated view for {trace_id}: {e}")

    def remove_trace(self, trace_id: str) -> None:
        """Remove a trace and clean up resources."""
        if trace_id not in self.traces:
            return

        try:
            _, curve = self.traces[trace_id]
            
            # Remove from main plot if present
            if curve.scene() == self.plot_item.scene():
                self.plot_item.removeItem(curve)
            
            # Clean up isolated view if exists
            if trace_id in self.isolated_view_boxes:
                viewbox = self.isolated_view_boxes[trace_id]
                viewbox.removeItem(curve)
                self.plot_layout.removeItem(viewbox)
                del self.isolated_view_boxes[trace_id]
                
            if trace_id in self.isolated_axes:
                self.plot_layout.removeItem(self.isolated_axes[trace_id])
                del self.isolated_axes[trace_id]
            
            # Remove from traces dictionary
            del self.traces[trace_id]
            
        except Exception as e:
            logger.error(f"Error removing trace {trace_id}: {e}")

    def clear_all(self) -> None:
        """Remove all traces."""
        for trace_id in list(self.traces.keys()):
            self.remove_trace(trace_id)

    @staticmethod
    def _get_qt_line_style(style_str: str) -> Qt.PenStyle:
        """Convert string style to Qt PenStyle."""
        styles = {
            'solid': Qt.SolidLine,
            'dash': Qt.DashLine,
            'dot': Qt.DotLine,
            'dashdot': Qt.DashDotLine
        }
        return styles.get(style_str.lower(), Qt.SolidLine)

    def update_geometry(self, main_rect) -> None:
        """Update geometry of isolated view boxes."""
        for view_box in self.isolated_view_boxes.values():
            view_box.setGeometry(main_rect)


================================================================================
*** __init__.py ***
### tests/__init__.py ###
================================================================================




================================================================================
*** conftest.py ***
### tests/conftest.py ###
================================================================================

# tests/conftest.py
import pytest
from PySide6.QtWidgets import QApplication
from pymetr.state import ApplicationState
from pymetr.models.base import BaseModel
from pymetr.ui.views.manager import ViewType  # Add this import
from pymetr.actions.commands import Result

# Base test models that can be used across all tests
@pytest.mark.no_collect
class TestModel(BaseModel):
    """Generic test model for testing"""
    def __init__(self, name: str, model_id: str = None):
        super().__init__(model_id)
        self.set_property('name', name)

@pytest.mark.no_collect
class TestScript(BaseModel):
    """Test script model for testing"""
    def __init__(self, name: str, model_id: str = None):
        super().__init__(model_id)
        self.set_property('name', name)

@pytest.mark.no_collect
class TestResult(BaseModel):
    """Test result model for testing"""
    def __init__(self, name: str, model_id: str = None):
        super().__init__(model_id)
        self.set_property('name', name)

# Fixtures that can be used across all tests
@pytest.fixture(scope="session")
def qapp():
    """Create the Qt Application"""
    return QApplication([])

@pytest.fixture
def state():
    """Create a fresh application state for each test"""
    return ApplicationState()

@pytest.fixture
def test_model(state):
    """Create a test model and register it with the state"""
    model = TestModel("Test Model")
    state.registry.register(model)
    return model

@pytest.fixture
def test_script(state):
    """Create a test script and register it with the state"""
    script = TestScript("Test Script")
    state.registry.register(script)
    return script

@pytest.fixture
def test_result(state):
    """Create a test result and register it with the state"""
    result = TestResult("Test Result")
    state.registry.register(result)
    return result

@pytest.fixture
def success_result():
    """Fixture for successful command result"""
    return Result(success=True)

@pytest.fixture
def failed_result():
    """Fixture for failed command result"""
    return Result(success=False, error="Test error")


================================================================================
*** test_actions.py ***
### tests/test_actions.py ###
================================================================================

# tests/test_actions.py
import pytest
from pymetr.actions.commands import Command, ModelCommand, Result
from pymetr.actions.manager import ActionManager
from .conftest import TestModel
from pymetr.state import ApplicationState

class SetNameCommand(ModelCommand):
    def __init__(self, state: 'ApplicationState', model_id: str, name: str):
        super().__init__(state, model_id)
        self.new_name = name
    
    def execute(self) -> Result:
        self.store_model_state()
        model = self.state.registry.get_model(self.model_id)
        if model:
            model.set_property('name', self.new_name)
            return Result(True)
        return Result(False, error="Model not found")
    
    def undo(self) -> bool:
        return self.restore_model_state()

def test_command_execution(state, test_model):
    action_manager = ActionManager(state)
    action_manager.register_command('set_name', SetNameCommand)
    
    result = action_manager.execute('set_name', model_id=test_model.id, name="Updated")
    
    assert result.success
    assert state.registry.get_model(test_model.id).get_property('name') == "Updated"

def test_command_undo(state, test_model):
    action_manager = ActionManager(state)
    action_manager.register_command('set_name', SetNameCommand)
    
    original_name = test_model.get_property('name')
    action_manager.execute('set_name', model_id=test_model.id, name="Updated")
    
    result = action_manager.undo()
    assert result.success
    assert state.registry.get_model(test_model.id).get_property('name') == original_name


================================================================================
*** test_core.py ***
### tests/test_core.py ###
================================================================================

# tests/test_core.py
import pytest
from pymetr.registry import ModelRegistry
from .conftest import TestModel

def test_model_creation_and_registration(state):
    # Create and register a model
    model = TestModel("Test1")
    state.registry.register(model)
    
    retrieved = state.registry.get_model(model.id)
    assert retrieved is not None
    assert retrieved.get_property('name') == "Test1"

def test_model_relationships(state):
    parent = TestModel("Parent")
    child = TestModel("Child")
    
    state.registry.register(parent)
    state.registry.register(child)
    
    state.registry.link(parent.id, child.id)
    
    children = state.registry.get_children(parent.id)
    assert len(children) == 1
    assert children[0] == child.id

def test_model_type_query(state):
    model1 = TestModel("Test1")
    model2 = TestModel("Test2")
    
    state.registry.register(model1)
    state.registry.register(model2)
    
    test_models = state.registry.get_models_by_type(TestModel)
    assert len(test_models) == 2
    names = {m.get_property('name') for m in test_models}
    assert names == {"Test1", "Test2"}


================================================================================
*** test_main.py ***
### tests/test_main.py ###
================================================================================

# tests/test_main.py
import pytest
from unittest.mock import Mock, patch
from pymetr.__main__ import main

def test_main():
    with patch('pymetr.__main__.create_application') as mock_create:
        with patch('sys.exit') as mock_exit:
            # Create mock app and window
            mock_app = Mock()
            mock_window = Mock()
            mock_create.return_value = (mock_app, mock_window)
            
            main()
            
            # Verify application was created and executed
            mock_create.assert_called_once()
            mock_app.exec.assert_called_once()
            mock_exit.assert_called_once()


================================================================================
*** test_main_window.py ***
### tests/test_main_window.py ###
================================================================================

# tests/test_main_window.py
import pytest
from PySide6.QtWidgets import QDockWidget, QMessageBox
from PySide6.QtCore import Qt
from pymetr.ui.views.windows.main_window import MainWindow
from pymetr.actions.commands import Result  # Add this import

def test_window_creation(state, qapp, qtbot):
    """Test basic window creation and components"""
    window = MainWindow(state)
    qtbot.addWidget(window)
    
    # Verify core components exist
    assert window.tree_view is not None
    assert window.tab_manager is not None
    assert window.ribbon is not None
    
    # Check tree view is properly docked
    docks = window.findChildren(QDockWidget)
    assert len(docks) > 0
    model_dock = next((d for d in docks if d.windowTitle() == "Models"), None)
    assert model_dock is not None
    assert model_dock.widget() == window.tree_view

def test_action_handling_success(state, qapp, qtbot, test_script):
    """Test successful action handling"""
    window = MainWindow(state)
    qtbot.addWidget(window)
    
    # Mock successful action execution
    state.actions.execute = lambda action_id: Result(success=True)
    
    # Trigger action
    with qtbot.wait_signal(window.ribbon.action_triggered):
        window.ribbon.action_triggered.emit("test_action")

def test_action_handling_failure(state, qapp, qtbot, monkeypatch):
    """Test failed action handling shows error message"""
    window = MainWindow(state)
    qtbot.addWidget(window)
    
    # Mock QMessageBox to capture error display
    shown_messages = []
    def mock_warning(parent, title, message):
        shown_messages.append((title, message))
    
    monkeypatch.setattr(QMessageBox, 'warning', mock_warning)
    
    # Mock failed action execution
    state.actions.execute = lambda action_id: Result(success=False, error="Test error")
    
    # Trigger action
    window.ribbon.action_triggered.emit("test_action")
    
    # Verify error was shown
    assert len(shown_messages) == 1
    assert "Action Failed" in shown_messages[0][0]
    assert "Test error" in shown_messages[0][1]

def test_window_layout_constraints(state, qapp, qtbot):
    """Test window layout and size constraints"""
    window = MainWindow(state)
    qtbot.addWidget(window)
    
    # Verify minimum size
    assert window.minimumSize().width() >= 800
    assert window.minimumSize().height() >= 600
    
    # Verify dock widget areas
    model_dock = next(d for d in window.findChildren(QDockWidget) 
                     if d.windowTitle() == "Models")
    assert model_dock.allowedAreas() & Qt.LeftDockWidgetArea
    assert model_dock.allowedAreas() & Qt.RightDockWidgetArea


================================================================================
*** test_ribbon.py ***
### tests/test_ribbon.py ###
================================================================================

# tests/test_ribbon.py
import pytest
from pymetr.ui.views.ribbon.context import (
    RibbonContext, DefaultContext, ScriptContext, PlotContext,
    ActionCategory, RibbonAction
)
from pymetr.ui.views.ribbon.manager import RibbonManager

def test_default_context(state, qapp):
    ribbon_manager = RibbonManager(state)
    context = DefaultContext(state)
    actions = context.get_actions()
    
    assert any(a.id == "new_script" for a in actions)
    assert any(a.category == ActionCategory.FILE for a in actions)

def test_script_context(state, qapp, test_script):
    ribbon_manager = RibbonManager(state)
    
    # Set active model
    state.set_active_model(test_script.id)
    
    assert isinstance(ribbon_manager._current_context, ScriptContext)
    actions = ribbon_manager._current_context.get_actions()
    assert any(a.id == "run_script" for a in actions)
    assert any(a.id == "stop_script" for a in actions)

def test_action_triggering(state, qapp, test_script, qtbot):
    ribbon_manager = RibbonManager(state)
    qtbot.addWidget(ribbon_manager)

    # Track triggered actions
    triggered_actions = []
    ribbon_manager.action_triggered.connect(
        lambda aid: triggered_actions.append(aid)
    )

    # Create a context with known actions
    context = ScriptContext(state)
    ribbon_manager._set_context(context)

    state.set_active_model(test_script.id)

    # Find and trigger the run action
    run_toolbar = ribbon_manager.toolbars[ActionCategory.RUN]
    run_actions = run_toolbar.actions()
    assert len(run_actions) > 0, "No actions found in RUN category"
    
    run_action = run_actions[0]
    run_action.trigger()

    assert len(triggered_actions) == 1
    assert triggered_actions[0] == "run_script"


================================================================================
*** test_state.py ***
### tests/test_state.py ###
================================================================================

# tests/test_state.py
import pytest
from pymetr.state import ApplicationState, SignalManager
from .conftest import TestModel

def test_create_model(state):
    model = state.create_model(TestModel, name="Test1")
    assert model.get_property('name') == "Test1"
    assert state.registry.get_model(model.id) is not None

def test_signal_emission(state):
    received_signals = []
    
    def handler(model_id, model_type):
        received_signals.append((model_id, model_type))
    
    state.signals.connect('model_created', handler)
    model = state.create_model(TestModel, name="Test1")
    
    assert len(received_signals) == 1
    assert received_signals[0][1] == "TestModel"

def test_active_model(state):
    model1 = state.create_model(TestModel, name="Test1")
    model2 = state.create_model(TestModel, name="Test2")
    
    changes = []
    state.signals.connect('active_model_changed', 
                         lambda new_id, old_id: changes.append((new_id, old_id)))
    
    state.set_active_model(model1.id)
    assert state.get_active_model().id == model1.id
    assert len(changes) == 1
    
    state.set_active_model(model2.id)
    assert state.get_active_model().id == model2.id
    assert len(changes) == 2


================================================================================
*** test_tab_manager.py ***
### tests/test_tab_manager.py ###
================================================================================

# tests/test_tab_manager.py
import pytest
from PySide6.QtWidgets import QWidget
from pymetr.ui.views.tab_manager import TabManager
from pymetr.ui.views.manager import ViewType

# Mock view classes for testing
class MockScriptView(QWidget):
    def __init__(self, state, model_id, parent=None):
        super().__init__(parent)
        self.state = state
        self.model_id = model_id

class MockResultView(QWidget):
    def __init__(self, state, model_id, parent=None):
        super().__init__(parent)
        self.state = state
        self.model_id = model_id

def test_tab_creation(state, qapp, test_script):
    tab_manager = TabManager(state)
    # Override view creation for testing
    tab_manager._create_view = lambda model_id, view_type: (
        MockScriptView(state, model_id) if view_type == ViewType.SCRIPT
        else MockResultView(state, model_id)
    )
    
    # Simulate active model change
    state.set_active_model(test_script.id)
    
    assert test_script.id in tab_manager._tabs
    assert isinstance(tab_manager._tabs[test_script.id], MockScriptView)
    assert tab_manager.currentWidget() == tab_manager._tabs[test_script.id]

def test_tab_switching(state, qapp, test_script, test_result):
    tab_manager = TabManager(state)
    tab_manager._create_view = lambda model_id, view_type: (
        MockScriptView(state, model_id) if view_type == ViewType.SCRIPT
        else MockResultView(state, model_id) if view_type == ViewType.RESULT
        else None
    )
    
    # Activate first model
    state.set_active_model(test_script.id)
    first_tab = tab_manager.currentWidget()
    
    # Activate second model
    state.set_active_model(test_result.id)
    second_tab = tab_manager.currentWidget()
    
    assert first_tab != second_tab
    assert isinstance(first_tab, MockScriptView)
    assert isinstance(second_tab, MockResultView)


================================================================================
*** test_tree_view.py ***
### tests/test_tree_view.py ###
================================================================================

# tests/test_tree_view.py
import pytest
from pymetr.ui.views.test_tree_view import ModelTreeView
from .conftest import TestScript, TestResult

def test_model_creation(state, qapp, test_script):
    tree_view = ModelTreeView(state)
    
    # Emit model created signal
    state.signals.emit('model_created', test_script.id, type(test_script).__name__)
    
    # Verify tree node created
    assert test_script.id in tree_view._item_map
    item = tree_view._item_map[test_script.id]
    assert '' in item.text(0)  # Script icon
    assert "Test Script" in item.text(0)

def test_model_hierarchy(state, qapp, test_script, test_result):
    tree_view = ModelTreeView(state)
    
    # Emit creation signals
    state.signals.emit('model_created', test_script.id, type(test_script).__name__)
    state.signals.emit('model_created', test_result.id, type(test_result).__name__)
    
    # Link models
    state.signals.emit('models_linked', test_script.id, test_result.id)
    
    # Verify hierarchy
    script_item = tree_view._item_map[test_script.id]
    result_item = tree_view._item_map[test_result.id]
    assert result_item.parent() == script_item

def test_selection_signal(state, qapp, test_script, qtbot):
    tree_view = ModelTreeView(state)
    state.signals.emit('model_created', test_script.id, type(test_script).__name__)
    
    # Track selection signal
    with qtbot.wait_signal(tree_view.selection_changed) as blocker:
        item = tree_view._item_map[test_script.id]
        item.setSelected(True)
    
    assert blocker.args == [test_script.id]

def test_selection_triggers_tab_and_context(state, qapp, test_script, qtbot):
    """Test that selecting an item updates tabs and context"""
    tree_view = ModelTreeView(state)
    qtbot.addWidget(tree_view)
    
    # Track selection signal
    selection_signals = []
    tree_view.selection_changed.connect(lambda mid: selection_signals.append(mid))
    
    # Create and select item
    state.signals.emit('model_created', test_script.id, type(test_script).__name__)
    
    # Get the created item and select it
    item = tree_view._item_map[test_script.id]
    tree_view.setCurrentItem(item)
    
    # Verify selection was handled
    assert len(selection_signals) > 0
    assert selection_signals[-1] == test_script.id
    assert state.get_active_model().id == test_script.id


================================================================================
*** test_views.py ***
### tests/test_views.py ###
================================================================================

# tests/test_views.py
import pytest
from pymetr.ui.views.manager import ViewManager, ViewType, ViewState

def test_view_registration(state, test_script):  # Added test_script fixture
    view_manager = ViewManager(state)
    
    # Register view for test model
    view_state = view_manager.register_view(
        'view1',
        ViewType.SCRIPT,
        test_script.id
    )
    
    assert view_state.view_type == ViewType.SCRIPT
    assert view_state.model_id == test_script.id
    assert not view_state.is_dirty
    assert test_script.id in view_manager._model_views

def test_active_view(state, test_script, test_result):  # Using both fixtures
    view_manager = ViewManager(state)
    
    # Register two views
    view_manager.register_view('view1', ViewType.SCRIPT, test_script.id)
    view_manager.register_view('view2', ViewType.RESULT, test_result.id)
    
    # Set active view
    view_manager.set_active_view('view1')
    
    # Verify active states
    assert view_manager._active_view == 'view1'
    assert view_manager._views['view1'].is_active
    assert not view_manager._views['view2'].is_active
    
    # Verify active model in state
    assert state.get_active_model().id == test_script.id

def test_model_change_propagation(state, test_script):  # Added test_script fixture
    view_manager = ViewManager(state)
    view_manager.register_view('view1', ViewType.SCRIPT, test_script.id)
    
    # Update model
    test_script.set_property('name', "Updated")
    state.notify_model_changed(test_script.id, 'name', "Updated")
    
    # Verify view is marked dirty
    view_state = view_manager.get_view_state('view1')
    assert view_state.is_dirty

def test_model_deletion(state, test_script):  # Added test_script fixture
    view_manager = ViewManager(state)
    
    # Register two views for same model
    view_manager.register_view('view1', ViewType.SCRIPT, test_script.id)
    view_manager.register_view('view2', ViewType.SCRIPT, test_script.id)
    
    # Delete model
    state.delete_model(test_script.id)
    
    # Verify views are cleaned up
    assert test_script.id not in view_manager._model_views
    assert 'view1' not in view_manager._views
    assert 'view2' not in view_manager._views

def test_view_properties(state, test_script):  # Added test_script fixture
    view_manager = ViewManager(state)
    view_manager.register_view('view1', ViewType.SCRIPT, test_script.id)
    
    # Set view property
    view_manager.set_view_property('view1', 'cursor_position', 100)
    
    # Verify property
    view_state = view_manager.get_view_state('view1')
    assert view_state.properties['cursor_position'] == 100


================================================================================
# End of Project Source Code Collection
