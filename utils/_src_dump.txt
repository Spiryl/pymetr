# Project Source Code Collection
# Generated: 2025-02-01 14:08:46.332755
# Root Directory: C:\Users\rsmith\Documents\GitHub\pymetr


================================================================================
*** setup.py ***
### setup.py ###
================================================================================

from setuptools import setup, find_packages

setup(
    # Basic info
    name='PyMetr',
    version='0.1.0',
    author='Ryan.C.Smith',
    author_email='bellstate@gmail.com',

    # A short description of the project
    description='A comprehensive Python library for connecting, controlling, and managing test and measurement instruments.',
    
    # A long description, can be the same as your GitHub README.md
    long_description=open('README.md').read(),
    long_description_content_type='text/markdown',  # This is important to render markdown correctly on PyPI

    # The project's main homepage.
    url='https://github.com/pymetr/pymetr',

    # Find all packages in the project
    packages=find_packages(),

    # What does your project relate to?
    keywords='instrumentation control SCPI test measurement plotting real-time data',
)



================================================================================
*** __init__.py ***
### src/pymetr/__init__.py ###
================================================================================




================================================================================
*** __main__.py ***
### src/pymetr/__main__.py ###
================================================================================

# src/pymetr/__main__.py
import sys
import pandas as pd
from PySide6.QtWidgets import QApplication
from pathlib import Path

from .state import ApplicationState
from .views.windows.main_window import MainWindow
from .models.base import BaseModel
from .models.data_table import DataTable
from .models.test_script import TestScript
from .models.test_result import TestResult
from .logging import logger

VOLTAGE_SCRIPT = '''# Voltage Test Script
import time
from instrument_utils import get_dut

def test_voltage():
    """Run automated voltage measurements."""
    # Get the DUT
    dut = get_dut()
    
    # Configure voltage measurement
    set_test_progress(10, "Configuring voltage measurement...")
    dut.configure_voltage_measurement()
    
    # Take measurements
    set_test_progress(50, "Taking voltage measurements...")
    result = new_result("Voltage Test")
    measurements = dut.measure_voltage()
    
    # Process data
    set_test_progress(75, "Processing measurements...")
    for value in measurements:
        result.add_data_point(value)
        time.sleep(0.1)  # Simulate processing
    
    # Save data and complete
    set_test_progress(90, "Saving results...")
    result.add_data(measurements)
    set_test_progress(100, "Test complete!")
    
    return result
'''

CURRENT_SCRIPT = '''# Current Test Script
import time
from instrument_utils import get_dut

def test_current():
    """Run automated current measurements."""
    # Get the DUT
    dut = get_dut()
    
    # Configure current measurement
    set_test_progress(10, "Configuring current measurement...")
    dut.configure_current_measurement()
    
    # Take measurements
    set_test_progress(50, "Taking current measurements...")
    result = new_result("Current Test")
    measurements = dut.measure_current()
    time.sleep(0.5)  # Simulation
    
    # Test paused at 50% for demonstration
    return result
'''

def create_test_data(state: ApplicationState):
    logger.info("Creating test data...")

    # Create example script files if they don't exist
    scripts_dir = Path(__file__).parent / "example_scripts"
    scripts_dir.mkdir(exist_ok=True)

    voltage_script = scripts_dir / "voltage_test.py"
    current_script = scripts_dir / "current_test.py"

    # Write script content
    voltage_script.write_text(VOLTAGE_SCRIPT)
    current_script.write_text(CURRENT_SCRIPT)

    # Create test scripts with file paths
    script1 = TestScript(
        name="Voltage Test",
        script_path=voltage_script
    )
    script2 = TestScript(
        name="Current Test",
        script_path=current_script
    )
    
    # Set different progress values
    script1.progress = 100  # Completed
    script1.status = "Complete"
    script2.progress = 50   # In progress
    script2.status = "Running"
    
    state.registry.register(script1)
    state.registry.register(script2)
    logger.debug(f"Registered test scripts: {script1.id}, {script2.id}")

    # Create test results with meaningful names
    result1 = TestResult("Voltage Measurements")
    result2 = TestResult("Current Measurements")
    state.registry.register(result1)
    state.registry.register(result2)
    logger.debug(f"Registered test results: {result1.id}, {result2.id}")

    # Link results to test scripts
    state.registry.link(script1.id, result1.id)
    state.registry.link(script2.id, result2.id)

    # Emit signals for scripts and results
    state.signals.emit('model_created', script1.id, 'TestScript')
    state.signals.emit('model_created', script2.id, 'TestScript')
    state.signals.emit('model_created', result1.id, 'TestResult')
    state.signals.emit('model_created', result2.id, 'TestResult')
    state.signals.emit('models_linked', script1.id, result1.id)
    state.signals.emit('models_linked', script2.id, result2.id)

    # Create sample data tables with descriptive names
    data1 = pd.DataFrame({
        "Voltage (V)": [1.2, 2.3, 3.4], 
        "Current (A)": [0.5, 0.8, 1.1]
    })
    data_table1 = DataTable(result_id=result1.id, name="Voltage vs Current Data", data=data1)
    state.registry.register(data_table1)
    state.registry.link(result1.id, data_table1.id)

    data2 = pd.DataFrame({
        "Resistance (Î©)": [100, 200, 300], 
        "Power (W)": [0.6, 1.2, 1.8]
    })
    data_table2 = DataTable(result_id=result2.id, name="Resistance vs Power Data", data=data2)
    state.registry.register(data_table2)
    state.registry.link(result2.id, data_table2.id)

    logger.debug(f"Registered data tables: {data_table1.id}, {data_table2.id}")

    # Emit signals for data tables
    state.signals.emit('model_created', data_table1.id, 'DataTable')
    state.signals.emit('model_created', data_table2.id, 'DataTable')
    state.signals.emit('models_linked', result1.id, data_table1.id)
    state.signals.emit('models_linked', result2.id, data_table2.id)

    logger.info("Test data creation completed.")

def main():
    app = QApplication(sys.argv)
    
    # Create application state and main window
    state = ApplicationState()
    window = MainWindow(state)

    # Add test data
    create_test_data(state)

    # Show the main window
    window.show()
    
    return app.exec()

if __name__ == "__main__":
    sys.exit(main())


================================================================================
*** logging.py ***
### src/pymetr/logging.py ###
================================================================================

# app/logging.py

import logging
import sys
from pathlib import Path
from datetime import datetime

def setup_logging(log_to_file: bool = True):
    """Configure application-wide logging with detailed formatting."""
    logger = logging.getLogger('scpi')
    logger.setLevel(logging.DEBUG)

    # Detailed formatter
    formatter = logging.Formatter(
        '%(levelname)s - %(filename)s:%(lineno)d:%(funcName)s - %(message)s'
    )

    # Console handler
    if not logger.handlers:
        console = logging.StreamHandler(sys.stdout)
        console.setLevel(logging.DEBUG)
        console.setFormatter(formatter)
        logger.addHandler(console)

        # File handler (optional)
        if log_to_file:
            log_dir = Path("logs")
            log_dir.mkdir(exist_ok=True)
            
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            file_handler = logging.FileHandler(
                log_dir / f"scpi_{timestamp}.log",
                encoding='utf-8'
            )
            file_handler.setLevel(logging.DEBUG)
            file_handler.setFormatter(formatter)
            logger.addHandler(file_handler)

    return logger

# Initialize logger
logger = setup_logging()


================================================================================
*** registry.py ***
### src/pymetr/registry.py ###
================================================================================

# src/registry.py
from typing import Dict, Set, Optional, List, TypeVar, Type
from .models.base import BaseModel

T = TypeVar('T', bound=BaseModel)

class ModelRegistry:
    """Central registry for all application models"""
    def __init__(self):
        self._models: Dict[str, BaseModel] = {}
        self._relationships: Dict[str, Set[str]] = {}
        self._type_index: Dict[str, Set[str]] = {}
        
    def register(self, model: BaseModel) -> None:
        """Register a model in the registry"""
        self._models[model.id] = model
        model_type = type(model).__name__
        if model_type not in self._type_index:
            self._type_index[model_type] = set()
        self._type_index[model_type].add(model.id)
        
    def unregister(self, model_id: str) -> None:
        """Remove a model from the registry"""
        if model_id in self._models:
            model = self._models[model_id]
            model_type = type(model).__name__
            self._type_index[model_type].discard(model_id)
            del self._models[model_id]
            # Cleanup relationships
            self._relationships.pop(model_id, None)
            for parent_id in self._relationships:
                self._relationships[parent_id].discard(model_id)
                
    def get_model(self, model_id: str) -> Optional[BaseModel]:
        """Retrieve a model by ID"""
        return self._models.get(model_id)
        
    def get_models_by_type(self, model_type: Type[T]) -> List[T]:
        """Get all models of a specific type"""
        type_name = model_type.__name__
        if type_name in self._type_index:
            return [self._models[mid] for mid in self._type_index[type_name]]
        return []
        
    def link(self, parent_id: str, child_id: str) -> None:
        """Create a relationship between models"""
        if parent_id not in self._relationships:
            self._relationships[parent_id] = set()
        self._relationships[parent_id].add(child_id)
        
    def unlink(self, parent_id: str, child_id: str) -> None:
        """Remove a relationship between models"""
        if parent_id in self._relationships:
            self._relationships[parent_id].discard(child_id)
            
    def get_children(self, parent_id: str) -> List[str]:
        """Get all child models for a parent"""
        return list(self._relationships.get(parent_id, set()))


================================================================================
*** state.py ***
### src/pymetr/state.py ###
================================================================================

# src/pymetr/state.py
from typing import Dict, Any, Optional, List, Callable, Type
from .registry import ModelRegistry
from .models.base import BaseModel
from .views.manager import ViewManager  # Add this import
from .actions.manager import ActionManager  # Add this import

class SignalManager:
    """Manages signal/event handling"""
    def __init__(self):
        self._handlers: Dict[str, List[Callable]] = {}
        
    def connect(self, signal: str, handler: Callable) -> None:
        """Connect a handler to a signal"""
        if signal not in self._handlers:
            self._handlers[signal] = []
        self._handlers[signal].append(handler)
        
    def emit(self, signal: str, *args, **kwargs) -> None:
        """Emit a signal with arguments"""
        if signal in self._handlers:
            for handler in self._handlers[signal]:
                try:
                    handler(*args, **kwargs)
                except Exception as e:
                    # In real implementation, we'd want proper logging here
                    print(f"Error in signal handler: {e}")
                    
    def disconnect(self, signal: str, handler: Callable) -> None:
        """Disconnect a handler from a signal"""
        if signal in self._handlers:
            self._handlers[signal] = [h for h in self._handlers[signal] if h != handler]

class ApplicationState:
    """Centralizes application state management"""
    def __init__(self):
        self.registry = ModelRegistry()
        self.signals = SignalManager()
        self.views = ViewManager(self)
        self.actions = ActionManager(self)
        self._active_model_id: Optional[str] = None

    def create_model(self, model_type: Type[BaseModel], **kwargs) -> BaseModel:
        """Create and register a new model"""
        model = model_type(**kwargs)
        self.registry.register(model)
        self.signals.emit('model_created', model.id, type(model).__name__)
        return model
        
    def delete_model(self, model_id: str) -> None:
        """Delete a model and its relationships"""
        model = self.registry.get_model(model_id)
        if model:
            # First emit signal for cleanup
            self.signals.emit('model_deleting', model_id, type(model).__name__)
            # Remove from registry
            self.registry.unregister(model_id)
            # Notify deletion complete
            self.signals.emit('model_deleted', model_id)
            
    def set_active_model(self, model_id: Optional[str]) -> None:
        """Set the currently active model"""
        old_id = self._active_model_id
        self._active_model_id = model_id
        self.signals.emit('active_model_changed', model_id, old_id)
        
    def get_active_model(self) -> Optional[BaseModel]:
        """Get the currently active model"""
        if self._active_model_id:
            return self.registry.get_model(self._active_model_id)
        return None
        
    def link_models(self, parent_id: str, child_id: str) -> None:
        """Create a relationship between models"""
        self.registry.link(parent_id, child_id)
        self.signals.emit('models_linked', parent_id, child_id)
        
    def unlink_models(self, parent_id: str, child_id: str) -> None:
        """Remove a relationship between models"""
        self.registry.unlink(parent_id, child_id)
        self.signals.emit('models_unlinked', parent_id, child_id)
        
    def get_model_children(self, model_id: str) -> List[BaseModel]:
        """Get all child models for a given model"""
        child_ids = self.registry.get_children(model_id)
        return [self.registry.get_model(cid) for cid in child_ids if self.registry.get_model(cid)]
        
    def notify_model_changed(self, model_id: str, property_name: str, value: Any) -> None:
        """Notify system of model property changes"""
        self.signals.emit('model_changed', model_id, property_name, value)


================================================================================
*** __init__.py ***
### src/pymetr/actions/__init__.py ###
================================================================================




================================================================================
*** commands.py ***
### src/pymetr/actions/commands.py ###
================================================================================

# src/pymetr/actions/commands.py
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, TYPE_CHECKING
from dataclasses import dataclass

if TYPE_CHECKING:
        from pymetr.state import ApplicationState

@dataclass
class Result:
    """Command execution result"""
    success: bool
    data: Dict[str, Any] = None
    error: str = ""

class Command(ABC):
    """Base command interface"""
    def __init__(self, state: 'ApplicationState'):
        self.state = state
        self._stored_state: Dict[str, Any] = {}
    
    @abstractmethod
    def execute(self) -> Result:
        """Execute the command"""
        pass
        
    @abstractmethod
    def undo(self) -> bool:
        """Reverse the command effects"""
        pass
    
    def can_execute(self) -> bool:
        """Check if command can be executed"""
        try:
            return self.validate()
        except Exception as e:
            return False
    
    def validate(self) -> bool:
        """Validate command preconditions"""
        return True

class ModelCommand(Command):
    """Base for commands that modify models"""
    def __init__(self, state: 'ApplicationState', model_id: str):
        super().__init__(state)
        self.model_id = model_id
        self._previous_state: Optional[Dict[str, Any]] = None
        
    def store_model_state(self):
        """Store model state for undo"""
        model = self.state.registry.get_model(self.model_id)
        if model:
            self._previous_state = model.to_dict()
            
    def restore_model_state(self) -> bool:
        """Restore model to previous state"""
        if self._previous_state and self.model_id:
            model = self.state.registry.get_model(self.model_id)
            if model:
                for key, value in self._previous_state.get('properties', {}).items():
                    model.set_property(key, value)
                return True
        return False


================================================================================
*** history.py ***
### src/pymetr/actions/history.py ###
================================================================================

# src/pymetr/actions/history.py
from typing import List, Optional
from .commands import Command

class CommandHistory:
    """Manages command history for undo/redo"""
    def __init__(self, max_size: int = 100):
        self._history: List[Command] = []
        self._current: int = -1
        self._max_size = max_size
    
    def push(self, command: Command) -> None:
        """Add command to history"""
        # Clear any redoable commands
        if self._current < len(self._history) - 1:
            self._history = self._history[:self._current + 1]
            
        self._history.append(command)
        self._current += 1
        
        # Maintain size limit
        if len(self._history) > self._max_size:
            self._history.pop(0)
            self._current -= 1
    
    def can_undo(self) -> bool:
        return self._current >= 0
    
    def can_redo(self) -> bool:
        return self._current < len(self._history) - 1
    
    def undo(self) -> Optional[Command]:
        """Get the command to undo"""
        if self.can_undo():
            command = self._history[self._current]
            self._current -= 1
            return command
        return None
    
    def redo(self) -> Optional[Command]:
        """Get the command to redo"""
        if self.can_redo():
            self._current += 1
            return self._history[self._current]
        return None


================================================================================
*** manager.py ***
### src/pymetr/actions/manager.py ###
================================================================================

# src/pymetr/actions/manager.py
from typing import Dict, Any, Type, Optional, TYPE_CHECKING
from .commands import Command, Result
from .history import CommandHistory

if TYPE_CHECKING:
        from pymetr.state import ApplicationState

class ActionManager:
    """Manages command execution and history"""
    def __init__(self, state: 'ApplicationState'):
        self.state = state
        self.history = CommandHistory()
        self._command_types: Dict[str, Type[Command]] = {}
    
    def register_command(self, action_id: str, command_class: Type[Command]) -> None:
        """Register a command type for an action"""
        self._command_types[action_id] = command_class
    
    def execute(self, action_id: str, **params) -> Result:
        """Execute an action with parameters"""
        command_class = self._command_types.get(action_id)
        if not command_class:
            return Result(False, error=f"Unknown action: {action_id}")
            
        try:
            command = command_class(self.state, **params)
            if command.can_execute():
                result = command.execute()
                if result.success:
                    self.history.push(command)
                return result
            return Result(False, error="Command validation failed")
        except Exception as e:
            return Result(False, error=str(e))
    
    def undo(self) -> Result:
        """Undo last command"""
        command = self.history.undo()
        if command and command.undo():
            return Result(True)
        return Result(False, error="Undo failed")
    
    def redo(self) -> Result:
        """Redo previously undone command"""
        command = self.history.redo()
        if command:
            return command.execute()
        return Result(False, error="No command to redo")


================================================================================
*** __init__.py ***
### src/pymetr/drivers/__init__.py ###
================================================================================

# drivers/__init__.py

from .base import (
    Instrument, SCPIInstrument, Subsystem, Sources, 
    Property, ValueProperty, SwitchProperty, 
    SelectProperty, DataProperty, DataBlockProperty
)
from .connections import (
    ConnectionInterface, PyVisaConnection, RawSocketConnection
)

from .registry import DRIVER_REGISTRY, get_driver_info

__all__ = [
    'Instrument',
    'SCPIInstrument',
    'Subsystem',
    'Sources',
    'Property',
    'ValueProperty',
    'SwitchProperty',
    'SelectProperty',
    'DataProperty',
    'DataBlockProperty',
    'ConnectionInterface',
    'PyVisaConnection',
    'RawSocketConnection',
    'Registry'
]



================================================================================
*** base.py ***
### src/pymetr/drivers/base.py ###
================================================================================

# base.py

import logging
import time
from abc import ABCMeta, abstractmethod
from PySide6.QtCore import QObject, Signal
from PySide6.QtWidgets import QApplication
from typing import Optional, Any, Dict, List
import numpy as np
import concurrent.futures

from drivers.connections import PyVisaConnection
from drivers.connections import RawSocketConnection
from drivers.connections import ConnectionInterface


logger = logging.getLogger(__name__)

class ABCQObjectMeta(type(QObject), ABCMeta):
    """Metaclass that combines QObject and ABC functionality."""
    pass

class Instrument(QObject, metaclass=ABCQObjectMeta):
    """
    Base Instrument class supporting both blocking and UI-responsive modes.
    """

    commandSent = Signal(str)               # Command that was sent
    responseReceived = Signal(str, str)     # (command, response)
    exceptionOccured = Signal(str)
    traceDataReady = Signal(np.ndarray, np.ndarray)  # (freq_array, amp_array)

    def __init__(self, connection: ConnectionInterface,
                 read_after_write: bool = False, read_timeout: float = 1.5,
                 parent: Optional[QObject] = None):
        super().__init__(parent)
        self.connection = connection
        self.read_after_write = read_after_write
        self.read_timeout = read_timeout

        # State flags
        self.continuous_mode = False
        self._ready_for_data = True
        self.unique_id = None

        # Check if we're in a GUI context
        self._has_gui = QApplication.instance() is not None

    def open(self):
        """Opens the connection to the instrument."""
        try:
            self.connection.open()
            logger.info("Instrument connection opened")
        except Exception as e:
            logger.exception(f"Failed to open connection: {e}")
            raise

    def close(self):
        """Closes the connection to the instrument."""
        logger.debug("Closing instrument connection")
        try:
            self.connection.close()
            logger.info("Instrument connection closed")
        except Exception as e:
            logger.exception(f"Failed to close connection: {e}")
            raise

    def _read_with_events(self) -> str:
        """
        Read from instrument while processing GUI events.
        Uses direct event processing to maintain UI responsiveness.

        Returns:
            str: Complete response string
        """
        buffer = bytearray()
        start_time = time.time()

        # Ensure terminator is in bytes
        terminator = (self.connection.read_termination.encode(self.connection.encoding) 
                    if isinstance(self.connection.read_termination, str) 
                    else self.connection.read_termination)

        while True:
            # Check timeout
            if time.time() - start_time > self.read_timeout:
                raise TimeoutError("Read operation timed out")

            # Try to read available data
            if self.connection.has_data():
                chunk = self.connection.read_available()
                if chunk:
                    buffer.extend(chunk)

                    # Check for complete message
                    if terminator in buffer:
                        # Find terminator position
                        term_pos = buffer.find(terminator)
                        # Extract message
                        message = buffer[:term_pos].decode(self.connection.encoding)
                        # Save remaining data in connection's buffer
                        remaining = buffer[term_pos + len(terminator):]
                        if remaining:
                            self.connection._read_buffer = remaining
                        return message

            # Keep UI responsive when in GUI context
            if self._has_gui:
                QApplication.processEvents()

            # Small sleep to prevent busy-waiting
            time.sleep(0.002)

    def write(self, command: str) -> None:
        """Write a command to the instrument."""
        desc = f"WRITE: {command}"
        logger.debug(desc)

        try:
            self.connection.write(command)
            self.commandSent.emit(command)

            if self.read_after_write:
                return self.read()

        except Exception as e:
            logger.exception(f"Error executing {desc}: {e}")
            self.exceptionOccured.emit(f"{desc} -> {e}")
            raise

    def read(self) -> str:
        """
        Read from the instrument using either async or sync mode.

        Returns:
            str: The response string
        """
        desc = "READ"
        logger.debug(desc)

        try:
            if self._has_gui:
                response = self._read_with_events()
            else:
                # Use synchronous read for non-GUI or sync mode
                response = self.connection.read_available().decode(self.connection.encoding).strip()

            self.responseReceived.emit("READ", response)
            return response

        except Exception as e:
            logger.exception(f"Error executing {desc}: {e}")
            self.exceptionOccured.emit(f"{desc} -> {e}")
            raise

    def query(self, command: str) -> str:
        """
        Send a query and get the response.

        Args:
            command: The query command

        Returns:
            str: The response string
        """
        desc = f"QUERY: {command}"
        logger.debug(desc)

        try:
            self.write(command)
            response = self.read()
            self.responseReceived.emit(command, response)
            return response

        except Exception as e:
            logger.exception(f"Error executing {desc}: {e}")
            self.exceptionOccured.emit(f"{desc} -> {e}")
            raise

    def set_continuous_mode(self, mode: bool):
        """Set continuous mode flag."""
        logger.debug(f"Set continuous mode to {mode}")
        self.continuous_mode = mode
        self._ready_for_data = not mode

    def set_unique_id(self, uid: str):
        """Set unique identifier for this instrument."""
        self.unique_id = uid

    @abstractmethod
    def fetch_trace(self, *args, **kwargs):
        """
        Abstract method for fetching trace data.
        Must be implemented by derived classes.
        """
        pass

    @staticmethod
    def gui_command(func):
        """Decorator for GUI-related commands."""
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        return wrapper

    @classmethod
    def list_instruments(cls, model_filter: Optional[List[str]] = None) -> Dict[str, Dict[str, str]]:
        """
        List available instruments by combining PyVISA and Raw Socket discoveries.
        Optionally filter instruments based on a list of model substrings.

        Args:
            model_filter (List[str], optional): List of model substrings to filter instruments.

        Returns:
            Dict[str, Dict[str, str]]: A dictionary mapping unique IDs to instrument details.
        """
        logger.debug(f"Listing instruments with model_filter: '{model_filter}'")
        instruments = {}

        try:
            # Get raw resource strings from both methods
            pyvisa_resources = PyVisaConnection.list_instruments()
            raw_socket_resources = RawSocketConnection.list_instruments()

            has_gui = QApplication.instance() is not None

            # Combine resources
            all_resources = list(pyvisa_resources.values()) + list(raw_socket_resources.values())

            logger.debug(f"Total resources to query: {len(all_resources)}")

            # Define a helper function for querying IDN
            def query_idn(resource):
                if has_gui:
                    QApplication.processEvents()
                try:
                    if resource.startswith("TCPIP") and "SOCKET" in resource:
                        # Raw socket connection
                        host, port = RawSocketConnection.parse_resource_string(resource)
                        conn = RawSocketConnection(host=host, port=port)
                    else:
                        # VISA connection
                        conn = PyVisaConnection(resource)

                    conn.open()
                    # Try to get IDN - use short timeout
                    conn.timeout = 1.0
                    idn = conn.query("*IDN?").strip()
                    conn.close()

                    # If we got an IDN and it matches filter (if any), return it
                    if idn:
                        # Parse IDN: Manufacturer, Model, Serial, Firmware
                        idn_parts = [part.strip() for part in idn.split(",")]
                        if len(idn_parts) >= 4:
                            manufacturer, model, serial, firmware = idn_parts[:4]
                        else:
                            manufacturer, model, serial, firmware = idn_parts + [""]*(4-len(idn_parts))

                        # Apply model filter if provided
                        if model_filter:
                            if any(model_filter_item.lower() in model.lower() for model_filter_item in model_filter):
                                unique_id = f"{model}, {serial}"
                                instruments[unique_id] = {
                                    'manufacturer': manufacturer,
                                    'model': model,
                                    'serial': serial,
                                    'firmware': firmware,
                                    'resource': resource
                                }
                                logger.info(f"Found matching instrument - IDN: {unique_id}, Resource: {resource}")
                        else:
                            unique_id = f"{model}, {serial}"
                            instruments[unique_id] = {
                                'manufacturer': manufacturer,
                                'model': model,
                                'serial': serial,
                                'firmware': firmware,
                                'resource': resource
                            }
                            logger.info(f"Found instrument - IDN: {unique_id}, Resource: {resource}")

                except Exception as e:
                    logger.debug(f"Could not get IDN from {resource}: {e}")
                    return

            # Utilize ThreadPoolExecutor for parallel querying
            with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
                futures = {executor.submit(query_idn, resource): resource for resource in all_resources}
                concurrent.futures.wait(futures)

        except Exception as e:
            logger.exception(f"Failed during instrument discovery: {e}")

        logger.info(f"Discovered instruments: {instruments}")
        return instruments


class SCPIInstrument(Instrument):
    """
    A specialized Instrument for SCPI-compatible devices.
    
    Args:
        connection (ConnectionInterface): The connection to use
        async_mode (bool): Whether to use UI-responsive mode (default: True)
        read_after_write (bool): Whether to read after every write (default: False)
        timeout (int): Default timeout for operations in milliseconds (default: 5000)
        parent (QObject): Parent QObject (default: None)
    """

    def __init__(self, connection, read_after_write=False, timeout=5000, parent=None):
        super().__init__(connection, read_after_write=read_after_write, parent=parent)
        self._data_mode = "ASCII"
        self._data_type = "B"  # Default data type for binary transfers
        self.timeout = timeout
        
        # Status tracking
        self._last_status = None
        self._error_queue = []

    @property
    def data_mode(self) -> str:
        """Gets or sets the data transfer mode ('ASCII' or 'BINARY')."""
        return self._data_mode
    
    @data_mode.setter
    def data_mode(self, mode: str):
        mode = mode.upper()
        if mode not in ["ASCII", "BINARY"]:
            raise ValueError("data_mode must be 'ASCII' or 'BINARY'")
        self._data_mode = mode
        logger.debug(f"Set data_mode to {self._data_mode}")

    @property
    def data_type(self) -> str:
        """Gets or sets the binary data type (e.g., 'B' for unsigned char)."""
        return self._data_type
    
    @data_type.setter
    def data_type(self, dtype: str):
        self._data_type = dtype
        logger.debug(f"Set data_type to {self._data_type}")

    # IEEE 488.2 Common Commands

    def idn(self) -> str:
        """
        Queries the instrument identity (*IDN?).
        
        Returns:
            str: The identification string
        """
        logger.debug("Querying instrument identity (*IDN?)")
        response = self._execute_command(self.connection.query, "*IDN?")
        logger.debug(f"Received IDN response: {response}")
        return response
    
    def get_identity(self) -> str:
        """
        Queries the instrument identity (*IDN?).
        
        Returns:
            str: The identification string
        """
        logger.debug("Querying instrument identity (*IDN?)")
        response = self.query("*IDN?")
        logger.debug(f"Received IDN response: {response}")
        return response
    
    def query_operation_complete(self):
        """Waits for operation complete (*OPC?)."""
        logger.info("Waiting for operation complete (*OPC?)")
        return self.query("*OPC?")

    def reset(self):
        """Resets the instrument (*RST)."""
        logger.info("Performing instrument reset (*RST)")
        self.write("*RST")

    def clear_status_registers(self):
        """Clears the status registers (*CLS)."""
        logger.info("Clearing status registers (*CLS)")
        self.write("*CLS")

    def set_operation_complete(self):
        """Sets the operation complete flag (*OPC)."""
        logger.info("Setting operation complete flag (*OPC)")
        self.write("*OPC")

    def check_error_queue(self) -> List[str]:
        """
        Queries the error queue (SYST:ERR?).
        
        Returns:
            List[str]: List of error messages
        """
        logger.debug("Checking error queue (SYST:ERR?)")
        errors = []
        
        while True:
            response = self.query("SYST:ERR?")
            if "No error" in response.lower() or response.startswith("0,"):
                logger.debug("No more errors in the error queue.")
                break
            errors.append(response)
            logger.warning(f"Instrument error: {response}")
        
        return errors

    # Helper Methods for Data Handling

    def _parse_binary_header(self, response: bytes) -> tuple:
        """
        Parses IEEE 488.2 binary block header.
        Format: '#' + num_of_length_digits + data_length + data
        
        Returns:
            tuple: (data_bytes, header_length)
        """
        if not response.startswith(b'#'):
            raise ValueError("Invalid binary block format")
            
        num_digits = int(response[1:2])
        header_len = 2 + num_digits
        data_len = int(response[2:header_len])
        
        return response[header_len:header_len + data_len], header_len

    def _format_binary_data(self, data: np.ndarray) -> bytes:
        """
        Formats data array as IEEE 488.2 binary block.
        
        Args:
            data: Numpy array to format
            
        Returns:
            bytes: Formatted binary data
        """
        raw_data = data.tobytes()
        len_str = str(len(raw_data))
        header = f"#{len(len_str)}{len_str}".encode()
        return header + raw_data

    def write_binary_data(self, command: str, data: np.ndarray):
        """
        Writes binary data to instrument with proper formatting.
        
        Args:
            command: SCPI command
            data: Numpy array to send
        """
        binary_data = self._format_binary_data(data)
        full_command = command.encode() + b' ' + binary_data
        self._execute_command(self.connection.write, full_command)

    def read_binary_data(self) -> np.ndarray:
        """
        Reads binary data from instrument and converts to numpy array.
        
        Returns:
            numpy.ndarray: Parsed data array
        """
        response = self._execute_command(self.connection.read)
        data, _ = self._parse_binary_header(response)
        return np.frombuffer(data, dtype=self._data_type)
    

class Subsystem:
    """
    Base class for creating instrument subsystems, supporting both simple and indexed instantiation, 
    and enabling nested subsystem command prefix cascading.
    """

    def __init__(self, instr, cmd_prefix="", index=None):
        """
        Initializes a Subsystem instance.

        Args:
            instr (Instrument or Subsystem): The parent instrument or subsystem this instance belongs to.
            cmd_prefix (str): The command prefix specific to this subsystem.
            index (int, optional): If provided, specifies the index for this instance.
        """
        self.instr = instr
        logger.debug(f"Initializing subsystem with instrument {instr}, prefix '{cmd_prefix}', and index {index}")
        # Handle cascading of command prefixes for nested subsystems
        self.cmd_prefix = f"{instr.cmd_prefix}{cmd_prefix}" if hasattr(instr, 'cmd_prefix') else cmd_prefix
        if index is not None:
            self.cmd_prefix += str(index)
        logger.debug(f"Subsystem command prefix set to '{self.cmd_prefix}'")

    def write(self, command: str) -> None:
        """
        Forward write command to parent instrument.

        Args:
            command (str): The SCPI command string to send.
        """
        logger.debug(f"Subsystem forwarding WRITE command: '{command}'")
        return self.instr.write(command)

    def read(self) -> str:
        """
        Forward read command to parent instrument.

        Returns:
            str: The response string from the instrument.
        """
        logger.debug("Subsystem forwarding READ command")
        return self.instr.read()

    def query(self, command: str) -> str:
        """
        Forward query command to parent instrument.

        Args:
            command (str): The SCPI query command string.

        Returns:
            str: The response string from the instrument.
        """
        logger.debug(f"Subsystem forwarding QUERY command: '{command}'")
        return self.instr.query(command)

    def _execute_command(self, func, *args, **kwargs):
        """
        Forward command execution to parent instrument.

        Args:
            func (callable): The function to execute (e.g., write, read, query).
            *args: Positional arguments for the function.
            **kwargs: Keyword arguments for the function.

        Returns:
            Any: The result of the executed function.
        """
        logger.debug(f"Subsystem executing command with function: '{func.__name__}'")
        return self.instr._execute_command(func, *args, **kwargs)

    @classmethod
    def build(cls, parent, cmd_prefix, indices=None):
        """
        Class method to instantiate subsystems. Handles both single and indexed instances.

        Args:
            parent (Instrument or Subsystem): The parent object for the new subsystem(s).
            cmd_prefix (str): The SCPI command prefix.
            indices (int, optional): Number of indexed instances to create.

        Returns:
            Subsystem or list of Subsystem: Single instance or list of indexed instances.
        """
        if indices is None:
            # Single instance (no indexing)
            logger.debug(f"Building single instance of {cls.__name__} with prefix '{cmd_prefix}'")
            return cls(parent, cmd_prefix)
        
        subsystems = [None]  # Dummy element at index=0 for 1-based indexing
        if isinstance(indices, int) and indices > 0:
            # Create indexed instances from 1 to indices
            for i in range(1, indices + 1):
                logger.debug(f"Building indexed instance {i} of {cls.__name__} with prefix '{cmd_prefix}'")
                subsystems.append(cls(parent, cmd_prefix, i))
            return subsystems
        else:
            raise ValueError("Unsupported type or value for indices. Must be a positive integer or None.")

import logging
logger = logging.getLogger(__name__)
from enum import Enum
from collections.abc import Iterable
from PySide6.QtCore import QObject, Signal
import logging

class Sources(QObject):
    """
    Handles the management and operation of sources for SCPI instruments.

    Attributes:
        source_changed (Signal): Emitted when the list of active sources changes.
    """

    source_changed = Signal(list)

    def __init__(self, sources):
        """
        Initializes the Sources object with the available sources.

        Args:
            sources (list): List of available sources.
        """
        super().__init__()
        self._sources = [source.value if isinstance(source, Enum) else source for source in sources]
        self._source = []
        logger.info("Sources initialized with: %s", self._sources)

    @property
    def source(self):
        """
        Returns the list of active sources.

        Returns:
            list: Active sources.
        """
        return self._source

    @source.setter
    def source(self, sources):
        """
        Sets the active sources from the available sources.

        Args:
            sources (list): List of sources to set as active.
        """
        self._source = [source for source in sources if source in self._sources]
        logger.debug("Active source set to: %s", self._source)
        self.source_changed.emit(self._source)

    @property
    def sources(self):
        """
        Returns the list of available sources.

        Returns:
            list: Available sources.
        """
        return self._sources

    def add_source(self, source):
        """
        Adds a source to the list of active sources if it's available and not already active.

        Args:
            source (str or Enum): Source to add to the active sources.
        """
        source = source.value if isinstance(source, Enum) else source
        if source in self._sources and source not in self._source:
            self._source.append(source)
            logger.info("Added active source: %s", source)
            self.source_changed.emit(self._source)

    def remove_source(self, source):
        """
        Removes a source from the list of active sources if it's currently active.

        Args:
            source (str or Enum): Source to remove from the active sources.
        """
        source = source.value if isinstance(source, Enum) else source
        if source in self._source:
            self._source.remove(source)
            logger.info("Removed active source: %s", source)
            self.source_changed.emit(self._source)

    def set_sources(self, sources):
        """
        Sets the list of active sources from the available sources.

        Args:
            sources (list): List of sources to set as active.
        """
        self._source = [source.value if isinstance(source, Enum) else source for source in sources if source in self._sources]
        logger.debug("Active sources set to: %s", self._source)
        self.source_changed.emit(self._source)

    @staticmethod
    def source_command(command_template=None, formatter=None, single=False, join_str=', '):
        """
        Decorator for source-related commands.

        The `source_command` decorator is used to handle source-related commands in a flexible manner.
        It allows you to specify a command template, source formatting, and whether to handle sources
        individually or collectively.

        Usage Examples:
            @Sources.source_command(":DIGitize {}", single=True)
            def digitize(self, source):
                # Digitizes the specified source individually.
                pass

            @Sources.source_command(":calculate:measurement {}", formatter="'{}'", join_str=', ')
            def calculate_measurement(self, *sources):
                # Calculates the measurement for the specified sources.
                pass

            @Sources.source_command(single=True)
            def custom_function_single(self, source):
                # Performs a custom operation on each source individually.
                pass

            @Sources.source_command()
            def custom_function_multi(self, *sources):
                # Performs a custom operation on multiple sources.
                pass

        Args:
            command_template (str, optional): Template for the SCPI command. Defaults to None.
            formatter (str, optional): Formatter for the sources. Defaults to None.
            single (bool, optional): Whether to handle sources individually. Defaults to False.
            join_str (str, optional): String to join multiple sources. Defaults to ', '.

        Returns:
            function: Decorated function.
        """
        def decorator(func):
            def wrapper(self, *args, **kwargs):
                sources_to_use = self.sources.source if not args else args

                if isinstance(sources_to_use, Enum):
                    sources_to_use = [sources_to_use]
                elif not isinstance(sources_to_use, Iterable) or isinstance(sources_to_use, str):
                    sources_to_use = [sources_to_use]

                cleaned_sources = [source.value if isinstance(source, Enum) else source for source in sources_to_use]

                if formatter:
                    cleaned_sources = [formatter.format(source) for source in cleaned_sources]

                if command_template:
                    if single:
                        for source in cleaned_sources:
                            command = command_template.format(source)
                            logger.debug(f"Executing command: {command}")
                            self.write(command)
                            func(self, source, **kwargs)
                    else:
                        command = command_template.format(join_str.join(cleaned_sources))
                        logger.debug(f"Executing command: {command}")
                        self.write(command)
                        return func(self, *cleaned_sources, **kwargs)
                else:
                    if single:
                        for source in cleaned_sources:
                            func(self, source, **kwargs)
                    else:
                        return func(self, *cleaned_sources, **kwargs)

            return wrapper
        return decorator
    
# properties.py

"""
SCPI Property System - Simplified Implementation

This module provides descriptor classes for handling SCPI instrument properties.
Each property class implements specific behavior for different types of instrument
settings while relying on the base Instrument class for communication handling.
"""

from abc import ABC, abstractmethod
import logging
from typing import Any, Optional, Union, Tuple, List, Type, Callable
from enum import Enum
from dataclasses import dataclass
import numpy as np

logger = logging.getLogger(__name__)

@dataclass
class PropertyResponse:
    """
    Tracks the response and status of property operations.

    Attributes:
        value: The converted/processed value from the instrument
        raw_response: The raw string response from the instrument
        success: Whether the operation completed successfully
        error: Error message if the operation failed
    """
    value: Any = None
    raw_response: str = ""
    success: bool = True
    error: Optional[str] = None

class Property(ABC):
    """
    Base class for all SCPI property descriptors.

    This class implements the descriptor protocol and provides basic functionality
    for getting and setting SCPI instrument properties. It relies on the instrument's
    write/read/query methods for communication.

    Args:
        cmd_str: The SCPI command string associated with this property
        doc_str: Documentation string describing the property
        access: Access mode ('read', 'write', or 'read-write')
        join_char: Character used to join command and value
    """

    def __init__(self, cmd_str: str, doc_str: str = "", access: str = "read-write", join_char: str = " "):
        logger.debug(f"Initializing Property with cmd_str='{cmd_str}', access='{access}'")
        self.cmd_str = cmd_str
        self.doc_str = doc_str
        self.access = access.lower()
        self.join_char = join_char
        self.last_response = PropertyResponse()

    def __get__(self, instance, owner):
        """Descriptor get implementation."""
        if instance is None:
            logger.debug(f"Property accessed on class, returning self")
            return self
            
        if self.access not in ["read", "read-write"]:
            msg = f"Property '{self.cmd_str}' is write-only"
            logger.error(msg)
            raise AttributeError(msg)
            
        return self.getter(instance)

    def __set__(self, instance, value):
        """Descriptor set implementation."""
        if self.access not in ["write", "read-write"]:
            msg = f"Property '{self.cmd_str}' is read-only"
            logger.error(msg)
            raise AttributeError(msg)
            
        self.setter(instance, value)

    @abstractmethod
    def getter(self, instance) -> Any:
        """Abstract getter method to be implemented by subclasses."""
        pass

    @abstractmethod
    def setter(self, instance, value):
        """Abstract setter method to be implemented by subclasses."""
        pass

class ValueProperty(Property):
    """
    Numeric property with range validation and unit handling.

    Args:
        cmd_str: SCPI command string
        type: Data type ('float' or 'int')
        range: Optional tuple of (min, max) values
        units: Optional unit string to append to values
        doc_str: Documentation string
        access: Access mode ('read', 'write', or 'read-write')
        join_char: Character used to join command and value
    """

    def __init__(self, cmd_str: str, type: str = None, range: Optional[Tuple] = None,
                 units: str = "", doc_str: str = "", access: str = "read-write",
                 join_char: str = " "):
        super().__init__(cmd_str, doc_str, access, join_char)
        self.type = type
        self.range = range
        self.units = units
        logger.debug(
            f"Initialized ValueProperty: type='{type}', range={range}, "
            f"units='{units}'"
        )

    def _validate_value(self, value: Any) -> Union[float, int]:
        """
        Validate and convert a value according to type and range constraints.

        Args:
            value: Value to validate and convert

        Returns:
            Converted and validated value
        """
        logger.debug(f"Validating value: {value}")
        try:
            # Convert value to proper type
            if self.type == "float":
                value = float(value)
            elif self.type == "int":
                value = int(float(value))  # Handle scientific notation
            else:
                value = value  # No conversion if type is None

            # Check range if specified
            if self.range:
                min_val, max_val = self.range
                if (min_val is not None and value < min_val) or \
                   (max_val is not None and value > max_val):
                    msg = f"Value {value} outside range [{min_val}, {max_val}]"
                    logger.error(msg)
                    raise ValueError(msg)

            logger.debug(f"Value {value} validated successfully")
            return value

        except (ValueError, TypeError) as e:
            msg = f"Validation error for '{value}': {str(e)}"
            logger.error(msg)
            raise ValueError(msg)

    def getter(self, instance) -> Union[float, int]:
        """Get the current numeric value from the instrument."""
        logger.debug(f"Getting value for '{self.cmd_str}'")
        try:
            response = instance.query(f"{self.cmd_str}?")
            value = self._validate_value(response)
            self.last_response = PropertyResponse(
                value=value,
                raw_response=response
            )
            return value
        except Exception as e:
            logger.error(f"Error in getter for '{self.cmd_str}': {e}")
            self.last_response = PropertyResponse(
                success=False,
                error=str(e)
            )
            raise

    def setter(self, instance, value):
        """Set a numeric value on the instrument."""
        logger.debug(f"Setting '{self.cmd_str}' to {value}")
        try:
            validated_value = self._validate_value(value)
            command = f"{self.cmd_str}{self.join_char}{validated_value}{self.units}"
            instance.write(command)
            self.last_response = PropertyResponse(
                value=validated_value,
                raw_response=command
            )
        except Exception as e:
            logger.error(f"Error in setter for '{self.cmd_str}': {e}")
            self.last_response = PropertyResponse(
                success=False,
                error=str(e)
            )
            raise

class SwitchProperty(Property):
    """
    Boolean property with configurable true/false representation.
    
    Args:
        cmd_str: SCPI command string
        doc_str: Documentation string
        format: Format for sending values ('ON_OFF', 'TRUE_FALSE', '1_0')
        access: Access mode ('read', 'write', or 'read-write')
        join_char: Character used to join command and value
    """

    # Define standard format mappings
    FORMAT_MAPS = {
        'ON_OFF': {'true': 'ON', 'false': 'OFF'},
        'TRUE_FALSE': {'true': 'TRUE', 'false': 'FALSE'},
        '1_0': {'true': '1', 'false': '0'}
    }

    def __init__(self, cmd_str: str, doc_str: str = "", format: str = '1_0', 
                 access: str = "read-write", join_char: str = " "):
        super().__init__(cmd_str, doc_str, access, join_char)
        
        # Validate and set format
        format = format.upper()
        if format not in self.FORMAT_MAPS:
            raise ValueError(f"Invalid format '{format}'. Must be one of: {list(self.FORMAT_MAPS.keys())}")
        self.format = format
        
        # Define accepted input values (case-insensitive)
        self.true_values = {'on', '1', 'true', 'yes'}
        self.false_values = {'off', '0', 'false', 'no'}
        logger.debug(f"Initialized SwitchProperty with format '{format}'")

    def _convert_to_bool(self, value: Union[str, bool]) -> bool:
        """Convert various inputs to boolean values."""
        if isinstance(value, bool):
            return value
            
        value_str = str(value).lower().strip()
        if value_str in self.true_values:
            return True
        if value_str in self.false_values:
            return False
            
        raise ValueError(f"Invalid boolean value: '{value}'")

    def _format_bool(self, value: bool) -> str:
        """Convert boolean to the configured string format."""
        return self.FORMAT_MAPS[self.format]['true' if value else 'false']

    def getter(self, instance) -> bool:
        """Get the current boolean state from the instrument."""
        logger.debug(f"Getting boolean value for '{self.cmd_str}'")
        try:
            response = instance.query(f"{self.cmd_str}?")
            value = self._convert_to_bool(response)
            self.last_response = PropertyResponse(
                value=value,
                raw_response=response
            )
            return value
        except Exception as e:
            logger.error(f"Error in getter for '{self.cmd_str}': {e}")
            self.last_response = PropertyResponse(
                success=False,
                error=str(e)
            )
            raise

    def setter(self, instance, value):
        """Set a boolean value on the instrument."""
        logger.debug(f"Setting '{self.cmd_str}' to {value}")
        try:
            bool_value = self._convert_to_bool(value)
            formatted_value = self._format_bool(bool_value)
            command = f"{self.cmd_str}{self.join_char}{formatted_value}"
            instance.write(command)
            self.last_response = PropertyResponse(
                value=bool_value,
                raw_response=command
            )
        except Exception as e:
            logger.error(f"Error in setter for '{self.cmd_str}': {e}")
            self.last_response = PropertyResponse(
                success=False,
                error=str(e)
            )
            raise

class SelectProperty(Property):
    """
    Property that handles selection from a predefined set of choices.

    Args:
        cmd_str: SCPI command string
        choices: List of valid choices (strings) or Enum class
        doc_str: Documentation string
        access: Access mode ('read', 'write', or 'read-write')
        join_char: Character used to join command and value
    """

    def __init__(self, cmd_str: str, choices: Union[List[str], Type[Enum]], 
                 doc_str: str = "", access: str = "read-write", join_char: str = " "):
        super().__init__(cmd_str, doc_str, access, join_char)
        
        # Handle both enum and list inputs
        self.enum_class = None
        if isinstance(choices, type) and issubclass(choices, Enum):
            self.enum_class = choices
            self.choices = [e.value for e in choices]
        else:
            self.choices = [str(c) for c in choices]
            
        logger.debug(f"Initialized SelectProperty with choices: {self.choices}")

    def _find_match(self, value: Union[str, Enum]) -> str:
        """Find the best match for a value in the choices list."""
        logger.debug(f"Finding match for value: {value}")
        
        # Handle enum input
        if isinstance(value, Enum):
            logger.debug(f"Value is an Enum: {value}")
            return value.value

        # Handle string input
        value_str = str(value).strip().upper()
        logger.debug(f"Normalized string value: {value_str}")
        
        # Create normalized versions of choices for comparison
        norm_choices = {c.strip().upper(): c for c in self.choices}
        
        # Try exact match first
        if value_str in norm_choices:
            logger.debug(f"Found exact match: {norm_choices[value_str]}")
            return norm_choices[value_str]
            
        # Try prefix match
        matches = [
            orig for norm, orig in norm_choices.items()
            if norm.startswith(value_str) or value_str.startswith(norm)
        ]
        
        if len(matches) == 1:
            logger.debug(f"Found unique prefix match: {matches[0]}")
            return matches[0]
            
        if not matches:
            msg = f"Invalid choice: '{value}'. Valid options: {', '.join(self.choices)}"
            logger.error(msg)
            raise ValueError(msg)
        else:
            msg = f"Ambiguous value '{value}' matches multiple choices: {', '.join(matches)}"
            logger.error(msg)
            raise ValueError(msg)

    def getter(self, instance) -> Union[str, Enum]:
        """Get the current selection from the instrument."""
        logger.debug(f"Getting selection for '{self.cmd_str}'")
        try:
            response = instance.query(f"{self.cmd_str}?")
            matched_value = self._find_match(response)
            
            # Convert to enum if applicable
            if self.enum_class:
                result = self.enum_class(matched_value)
                logger.debug(f"Converted to enum: {result}")
            else:
                result = matched_value
                logger.debug(f"Using string value: {result}")
                
            self.last_response = PropertyResponse(
                value=result,
                raw_response=response
            )
            return result
        except Exception as e:
            logger.error(f"Error in getter for '{self.cmd_str}': {e}")
            self.last_response = PropertyResponse(
                success=False,
                error=str(e)
            )
            raise

    def setter(self, instance, value):
        """Set a selection on the instrument."""
        logger.debug(f"Setting '{self.cmd_str}' to {value}")
        try:
            matched_value = self._find_match(value)
            command = f"{self.cmd_str}{self.join_char}{matched_value}"
            instance.write(command)
            self.last_response = PropertyResponse(
                value=matched_value,
                raw_response=command
            )
        except Exception as e:
            logger.error(f"Error in setter for '{self.cmd_str}': {e}")
            self.last_response = PropertyResponse(
                success=False,
                error=str(e)
            )
            raise

class DataProperty(Property):
    """
    Property for handling basic ASCII data arrays.
    
    This property type handles simple arrays of ASCII values like comma-separated 
    lists of numbers. It provides validation and conversion of array data.

    Args:
        cmd_str: SCPI command string
        access: Access mode ('read', 'write', or 'read-write')
        doc_str: Documentation string
        container: Container type for the data (default: numpy.array)
        converter: Function to convert individual values (default: float)
        separator: String separator between values
        join_char: Character used to join command and value
        terminator: Read termination character(s)
    """

    def __init__(self, cmd_str: str, access: str = "read-write", doc_str: str = "",
                 container=np.array, converter: Callable = float, separator: str = ",", 
                 join_char: str = " ", terminator: str = '\n'):
        super().__init__(cmd_str, doc_str, access, join_char)
        self.container = container
        self.converter = converter
        self.separator = separator
        self.terminator = terminator
        logger.debug(
            f"Initialized DataProperty with separator='{separator}', "
            f"terminator='{terminator}'"
        )

    def _convert_to_array(self, response: str) -> Any:
        """Convert a response string into an array of values."""
        logger.debug("Converting response to array")
        try:
            # Split response and filter out empty strings
            values = [v.strip() for v in response.strip().split(self.separator)]
            values = [v for v in values if v]
            
            # Convert values using specified converter
            converted = [self.converter(v) for v in values]
            logger.debug(f"Converted {len(converted)} values")
            
            # Return in specified container
            return self.container(converted)
        except Exception as e:
            msg = f"Error converting response to array: {e}"
            logger.error(msg)
            raise ValueError(msg)

    def _format_array(self, value: Any) -> str:
        """Format an array of values for sending to instrument."""
        logger.debug("Formatting array for transmission")
        try:
            # Convert each value and join with separator
            formatted = self.separator.join(str(self.converter(v)) for v in value)
            if self.terminator and not formatted.endswith(self.terminator):
                formatted += self.terminator
            return formatted
        except Exception as e:
            msg = f"Error formatting array: {e}"
            logger.error(msg)
            raise ValueError(msg)

    def getter(self, instance) -> Any:
        """Get array data from the instrument."""
        logger.debug(f"Getting array data for '{self.cmd_str}'")
        try:
            response = instance.query(f"{self.cmd_str}?")
            array_data = self._convert_to_array(response)
            self.last_response = PropertyResponse(
                value=array_data,
                raw_response=response
            )
            return array_data
        except Exception as e:
            logger.error(f"Error in getter for '{self.cmd_str}': {e}")
            self.last_response = PropertyResponse(
                success=False,
                error=str(e)
            )
            raise

    def setter(self, instance, value):
        """Set array data on the instrument."""
        logger.debug(f"Setting array data for '{self.cmd_str}'")
        if not hasattr(value, '__iter__'):
            raise ValueError(f"Value must be iterable, got {type(value)}")
            
        try:
            formatted_data = self._format_array(value)
            command = f"{self.cmd_str}{self.join_char}{formatted_data}"
            instance.write(command)
            self.last_response = PropertyResponse(
                value=value,
                raw_response=command
            )
        except Exception as e:
            logger.error(f"Error in setter for '{self.cmd_str}': {e}")
            self.last_response = PropertyResponse(
                success=False,
                error=str(e)
            )
            raise

class DataBlockProperty(Property):
    """
    Property for handling binary data blocks with IEEE headers.

    This property type handles binary data transfers with IEEE 488.2 binary block 
    format, often used for waveform data and other large datasets.

    Args:
        cmd_str: SCPI command string
        access: Access mode ('read', 'write', or 'read-write')
        doc_str: Documentation string
        container: Container type for the data (default: numpy.array)
        dtype: NumPy dtype for binary data (default: np.float32)
        ieee_header: Whether to expect/generate IEEE headers (default: True)
    """

    def __init__(self, cmd_str: str, access: str = "read-write", doc_str: str = "",
                 container=np.array, dtype=np.float32, ieee_header: bool = True):
        super().__init__(cmd_str, doc_str, access)
        self.container = container
        self.dtype = dtype
        self.ieee_header = ieee_header
        logger.debug(
            f"Initialized DataBlockProperty with dtype={dtype}, "
            f"ieee_header={ieee_header}"
        )

    def _parse_ieee_header(self, data: bytes) -> Tuple[bytes, int]:
        """
        Parse IEEE 488.2 binary block header.
        Format: '#' + number_of_digits + data_length + data
        Example: #42000 means 4 digits follow, data length is 2000 bytes
        """
        logger.debug("Parsing IEEE header")
        if not data.startswith(b'#'):
            raise ValueError("Invalid IEEE block header: missing '#' marker")

        try:
            num_digits = int(data[1:2])
            header_len = 2 + num_digits
            data_len = int(data[2:header_len])
            logger.debug(f"Found IEEE header: {num_digits} digits, {data_len} bytes")
            return data[header_len:header_len + data_len], header_len
        except Exception as e:
            msg = f"Error parsing IEEE header: {e}"
            logger.error(msg)
            raise ValueError(msg)

    def _format_ieee_block(self, data: np.ndarray) -> bytes:
        """Format data as IEEE 488.2 binary block."""
        logger.debug("Formatting IEEE block")
        try:
            # Convert data to bytes
            raw_data = data.astype(self.dtype).tobytes()
            
            # Create IEEE header
            length_str = str(len(raw_data)).encode()
            header = b'#' + str(len(length_str)).encode() + length_str
            
            return header + raw_data
        except Exception as e:
            msg = f"Error formatting IEEE block: {e}"
            logger.error(msg)
            raise ValueError(msg)

    def getter(self, instance) -> np.ndarray:
        """Get binary block data from the instrument."""
        logger.debug(f"Getting binary data for '{self.cmd_str}'")
        try:
            response = instance.query(f"{self.cmd_str}?")
            
            # Handle binary response
            if isinstance(response, bytes):
                if self.ieee_header:
                    data_bytes, _ = self._parse_ieee_header(response)
                else:
                    data_bytes = response
                    
                # Convert to numpy array
                array_data = np.frombuffer(data_bytes, dtype=self.dtype)
                
            # Handle ASCII response
            else:
                values = [float(v) for v in response.strip().split(',')]
                array_data = np.array(values, dtype=self.dtype)
            
            array_data = self.container(array_data)
            self.last_response = PropertyResponse(
                value=array_data,
                raw_response=response
            )
            return array_data
            
        except Exception as e:
            logger.error(f"Error in getter for '{self.cmd_str}': {e}")
            self.last_response = PropertyResponse(
                success=False,
                error=str(e)
            )
            raise

    def setter(self, instance, value):
        """Set binary block data on the instrument."""
        logger.debug(f"Setting binary data for '{self.cmd_str}'")
        try:
            # Convert input to numpy array if needed
            if not isinstance(value, np.ndarray):
                value = np.array(value, dtype=self.dtype)
                
            # Format data
            if self.ieee_header:
                data = self._format_ieee_block(value)
                command = f"{self.cmd_str}{self.join_char}".encode() + data
            else:
                # Fall back to ASCII if no IEEE header
                command = f"{self.cmd_str}{self.join_char}" + \
                         ",".join(str(x) for x in value)
            
            instance.write(command)
            self.last_response = PropertyResponse(
                value=value,
                raw_response=str(command)
            )
        except Exception as e:
            logger.error(f"Error in setter for '{self.cmd_str}': {e}")
            self.last_response = PropertyResponse(
                success=False,
                error=str(e)
            )
            raise


================================================================================
*** connections.py ***
### src/pymetr/drivers/connections.py ###
================================================================================

# connections.py

"""
Defines the abstract base class (interface) for all instrument connections.
Adds support for non-blocking reads and data availability checking.
"""

from abc import ABC, abstractmethod
import logging
import socket
import select
import time
from typing import Optional, Dict, List
import ipaddress
from zeroconf import ServiceBrowser, Zeroconf
import concurrent.futures
import pyvisa
from PySide6.QtWidgets import QApplication

logger = logging.getLogger(__name__)

class ConnectionInterface(ABC):
    """
    An abstract base class representing the low-level connection or transport layer.
    Every specific transport (PyVISA, raw socket, serial, etc.) must implement these methods.
    """

    def __init__(self, read_termination: str = '\n', write_termination: str = '\n', encoding: str = 'ascii'):
        """
        Initialize common connection parameters.

        Args:
            read_termination: Character(s) marking end of received messages
            write_termination: Character(s) to append to sent messages
            encoding: Character encoding for string conversion
        """
        self.read_termination = read_termination.encode(encoding) if isinstance(read_termination, str) else read_termination
        self.write_termination = write_termination
        self.encoding = encoding
        self._read_buffer = bytearray()
        self._has_gui = QApplication.instance() is not None

    def _process_events(self):
        """Process GUI events if in GUI context."""
        if self._has_gui:
            QApplication.processEvents()
            
    @abstractmethod
    def open(self):
        """Opens the connection to the instrument."""
        pass

    @abstractmethod
    def close(self):
        """Closes the connection to the instrument."""
        pass

    @abstractmethod
    def write(self, command: str):
        """
        Writes a command string to the instrument.

        Args:
            command: The command string to send
        """
        pass

    @abstractmethod
    def has_data(self) -> bool:
        """
        Check if there is data available to read without blocking.

        Returns:
            bool: True if data is available to read without blocking
        """
        pass

    @abstractmethod
    def read_available(self) -> bytes:
        """
        Read whatever data is currently available without blocking.

        Returns:
            bytes: The currently available data (may be empty)
        """
        pass

    def read(self) -> str:
        """
        Default implementation of blocking read that uses has_data() and read_available().
        Can be overridden by subclasses if a more efficient implementation exists.

        Returns:
            str: The complete response string
        """
        while True:
            # Check for complete message in buffer
            if self.read_termination in self._read_buffer:
                # Find the terminator
                term_pos = self._read_buffer.find(self.read_termination)
                # Extract the message
                message = self._read_buffer[:term_pos].decode(self.encoding)
                # Remove processed data from buffer
                self._read_buffer = self._read_buffer[term_pos + len(self.read_termination):]
                return message

            # Read any available data
            if self.has_data():
                chunk = self.read_available()
                if chunk:
                    self._read_buffer.extend(chunk)
                continue

            # No data available and no complete message - block until data arrives
            chunk = self.read_available()  # This should block
            if chunk:
                self._read_buffer.extend(chunk)

    def query(self, command: str) -> str:
        """
        Default implementation of write followed by read.
        Can be overridden by subclasses if a more efficient implementation exists.

        Args:
            command: The command string to send

        Returns:
            str: The response string
        """
        self.write(command)
        return self.read()

    def clear_buffer(self):
        """Clear any partially read data from the buffer."""
        self._read_buffer.clear()


class PyVisaConnection(ConnectionInterface):
    """
    Implements the ConnectionInterface using PyVISA to communicate with instruments.
    Supports non-blocking reads through PyVISA's asynchronous I/O capabilities.
    """

    def __init__(self, resource_string: str, timeout: int = 5000,
                 read_termination: str = '\n', write_termination: str = '\n',
                 encoding: str = 'ascii'):
        """
        Initialize PyVISA connection parameters.

        Args:
            resource_string: VISA resource identifier
            timeout: I/O timeout in milliseconds
            read_termination: Character(s) marking end of received messages
            write_termination: Character(s) to append to sent messages
            encoding: Character encoding for string conversion
        """
        super().__init__(read_termination=read_termination,
                        write_termination=write_termination,
                        encoding=encoding)
        self.resource_string = resource_string
        self.timeout = timeout
        self.rm = pyvisa.ResourceManager()
        self.inst = None
        self._last_status = 0

    @staticmethod
    def list_instruments(query: str = "TCPIP?*::INSTR") -> Dict[str, str]:
        """List VISA resources without querying IDN."""
        logger.debug(f"PyVISA list_instruments called with query: '{query}'")
        discovered_devices = {}
        try:
            rm = pyvisa.ResourceManager()
            resources = rm.list_resources(query)
            logger.debug(f"PyVISA discovered resources: {list(resources)}")
            
            # Just map resource strings to themselves
            for resource in resources:
                discovered_devices[resource] = resource
                
        except Exception as e:
            logger.exception(f"PyVISA failed to list instruments: {e}")
                
        return discovered_devices
    
    @staticmethod
    def select_instrument(filter_query="TCPIP?*::INSTR"):
        """Utility method to interactively list and select VISA resources."""
        try:
            rm = pyvisa.ResourceManager()
            resources = rm.list_resources(filter_query)
            if not resources:
                print("No VISA instruments found matching your filter. Check connections.")
                raise SystemExit(0)

            print("\nAvailable Instruments:")
            for i, r in enumerate(resources, start=1):
                print(f"{i}. {r}")

            selection = input("\nSelect an instrument by number (or 'exit' to quit): ")
            if selection.lower() == 'exit':
                raise SystemExit(0)

            index = int(selection) - 1
            if index < 0 or index >= len(resources):
                raise ValueError("Invalid selection.")

            return resources[index]
        except Exception as e:
            logger.exception(f"select_instrument failed: {e}")
            raise

    def read_sync(self) -> str:
        """
        Synchronous (blocking) read operation for non-GUI contexts.
        This provides a simpler, more efficient read when async operation isn't needed.

        Returns:
            str: The complete response string
        """
        if not self.inst:
            raise ConnectionError("PyVISA instrument not open. Call open() first.")
            
        try:
            response = self.inst.read()
            logger.debug(f"PyVISA sync read response: {response}")
            return response
        except Exception as e:
            logger.exception(f"Error in sync read: {e}")
            raise

    def open(self):
        """Open the VISA session and configure it for asynchronous operation."""
        logger.debug(f"Opening PyVISA connection for resource: {self.resource_string}")
        self.inst = self.rm.open_resource(self.resource_string)
        self.inst.timeout = self.timeout
        self.inst.read_termination = self.write_termination
        self.inst.write_termination = self.write_termination

        # Enable Service Request generation if supported
        try:
            # Enable SRQ on data available
            self.inst.write("*SRE 16")  # Enable MAV bit in SRE
            self._srq_supported = True
        except pyvisa.Error:
            logger.debug("SRQ not supported by instrument")
            self._srq_supported = False

        logger.info(f"PyVISA connection opened for {self.resource_string}")

    def close(self):
        """Close the VISA session."""
        if self.inst is not None:
            logger.debug(f"Closing PyVISA connection for resource: {self.resource_string}")
            try:
                self.inst.close()
            finally:
                self.inst = None
                logger.info(f"PyVISA connection closed for {self.resource_string}")

    def write(self, command: str):
        """
        Write a command string to the instrument.

        Args:
            command: The command string to send
        """
        if not self.inst:
            raise ConnectionError("PyVISA instrument not open. Call open() first.")
        logger.debug(f"PyVISA write: {command}")
        self.inst.write(command)

    def has_data(self) -> bool:
        """
        Check if data is available to read without blocking.

        Returns:
            bool: True if data is available
        """
        if not self.inst:
            raise ConnectionError("PyVISA instrument not open. Call open() first.")

        try:
            if self._srq_supported:
                # Use STB polling for data availability
                stb = self.inst.read_stb()
                return bool(stb & 0x10)  # Check MAV bit
            else:
                # Fall back to VI_ATTR_TMO_VALUE=0 read attempt
                orig_timeout = self.inst.timeout
                self.inst.timeout = 0
                try:
                    self.inst.read_bytes(1)
                    return True
                except pyvisa.VisaIOError as e:
                    if e.error_code == pyvisa.constants.StatusCode.error_timeout:
                        return False
                    raise
                finally:
                    self.inst.timeout = orig_timeout
        except Exception as e:
            logger.exception(f"Error checking for data: {e}")
            raise

    def read_available(self) -> bytes:
        """
        Read whatever data is currently available.
        If no data is available, blocks for up to timeout period.

        Returns:
            bytes: The currently available data (may be empty)
        """
        if not self.inst:
            raise ConnectionError("PyVISA instrument not open. Call open() first.")

        try:
            # If data is available, read it
            if self.has_data():
                return self.inst.read_raw()

            # No immediate data - wait for timeout period
            if self._srq_supported:
                # Wait for SRQ
                if self.inst.wait_for_srq(self.timeout / 1000):
                    return self.inst.read_raw()
            else:
                # Regular timeout-based read
                try:
                    return self.inst.read_raw()
                except pyvisa.VisaIOError as e:
                    if e.error_code == pyvisa.constants.StatusCode.error_timeout:
                        return b''
                    raise

            return b''

        except Exception as e:
            logger.exception(f"Error reading available data: {e}")
            raise


class RawSocketConnection(ConnectionInterface):
    """
    Implements a raw socket-based connection for instruments that communicate over TCP/IP
    without requiring a VISA driver. Supports non-blocking reads.
    """

    # Default discovery port for Microchip TCP/IP Stack (PIC32MX/MZ)
    DISCOVERY_PORT = 30303

    @staticmethod
    def parse_resource_string(resource: str) -> tuple[str, int]:
        """Parse various resource string formats into host and port."""
        # Handle TCPIP resource string format
        if resource.startswith("TCPIP::"):
            parts = resource.split("::")
            if len(parts) >= 3:
                return parts[1], int(parts[2])
        
        # Handle direct IP:port format
        if ":" in resource:
            host, port = resource.split(":")
            return host.strip(), int(port)
            
        # If just an IP/hostname is provided
        return resource, 5025  # Default SCPI port
    
    def __init__(self, host: str, port: int = 5025, timeout: float = 2.5,
                 encoding: str = 'ascii', read_termination: str = '\n',
                 write_termination: str = '\n'):
        """
        Initialize socket connection parameters.
        
        Args:
            host: IP address, hostname, or resource string
            port: TCP port number (default: 5025 for SCPI)
            timeout: Socket timeout in seconds
            encoding: Character encoding for string conversion
            read_termination: Character(s) marking end of received messages
            write_termination: Character(s) to append to sent messages
        """
        super().__init__(read_termination=read_termination,
                        write_termination=write_termination,
                        encoding=encoding)
                        
        # Handle if host is actually a resource string
        if isinstance(host, str) and ("::" in host or ":" in host):
            self.host, parsed_port = self.parse_resource_string(host)
            self.port = port if port != 5025 else parsed_port  # Use explicitly provided port if given
        else:
            self.host = host
            self.port = port
            
        self.timeout = timeout
        self.sock = None

    def open(self):
        """Open the socket connection to the instrument."""
        logger.debug(f"Opening raw socket connection to {self.host}:{self.port}")
        try:
            self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            self.sock.settimeout(self.timeout)
            self.sock.connect((self.host, self.port))
            # Set non-blocking mode after connection
            self.sock.setblocking(False)
            logger.info(f"Raw socket connection established to {self.host}:{self.port}")
        except socket.error as e:
            logger.exception(f"Failed to connect to {self.host}:{self.port} - {e}")
            raise

    def close(self):
        """Close the socket connection."""
        if self.sock is not None:
            logger.debug(f"Closing raw socket connection to {self.host}:{self.port}")
            try:
                self.sock.close()
            finally:
                self.sock = None
                logger.info(f"Raw socket connection closed for {self.host}:{self.port}")

    def write(self, command: str):
        """
        Send a command string to the instrument.

        Args:
            command: The command string to send
        """
        if not self.sock:
            raise ConnectionError("Raw socket not open. Call open() first.")

        # Append termination if not already present
        if not command.endswith(self.write_termination):
            command += self.write_termination

        data = command.encode(self.encoding)
        logger.debug(f"Raw socket write: {command.strip()}")

        try:
            self.sock.sendall(data)
        except socket.error as e:
            logger.exception(f"Failed to send data to {self.host}:{self.port} - {e}")
            raise

    def has_data(self) -> bool:
        """
        Check if data is available to read without blocking.

        Returns:
            bool: True if data is available
        """
        if not self.sock:
            raise ConnectionError("Raw socket not open. Call open() first.")

        try:
            readable, _, _ = select.select([self.sock], [], [], 0)
            return bool(readable)
        except select.error as e:
            logger.exception(f"Select error checking for data: {e}")
            raise

    def read_available(self) -> bytes:
        """
        Read whatever data is currently available without blocking.
        If no data is available, blocks for up to timeout seconds.

        Returns:
            bytes: The currently available data (may be empty)
        """
        if not self.sock:
            raise ConnectionError("Raw socket not open. Call open() first.")

        try:
            # If data is immediately available, read it
            if self.has_data():
                return self.sock.recv(4096)

            # No data available - wait for timeout period
            readable, _, _ = select.select([self.sock], [], [], self.timeout)
            if readable:
                return self.sock.recv(4096)
            return b''
        except socket.error as e:
            logger.exception(f"Failed to read data from {self.host}:{self.port} - {e}")
            raise

    @staticmethod
    def list_instruments(methods: List[str] = ['udp', 'mdns', 'scan'], timeout: float = 5.0) -> Dict[str, str]:
        """
        Discover raw socket instruments using various methods.

        Args:
            methods (list): Methods to use for discovery ('udp', 'mdns', 'scan').
            timeout (float): Timeout for discovery methods in seconds.

        Returns:
            dict[str, str]: A dictionary mapping unique IDs to resource strings.
        """
        discovered_devices = {}

        # Discover all local IP ranges
        local_ip_ranges = RawSocketConnection.get_all_local_ip_ranges()
        logger.debug(f"Detected local IP ranges: {local_ip_ranges}")

        for ip_range in local_ip_ranges:
            if 'udp' in methods:
                devices = RawSocketConnection._discover_udp(timeout, ip_range)
                discovered_devices.update(devices)

            # Implement these in a full scan.
            # if 'mdns' in methods and not discovered_devices:
            #     devices = RawSocketConnection._discover_mdns(timeout)
            #     discovered_devices.update(devices)

            # if 'scan' in methods and not discovered_devices:
            #     devices = RawSocketConnection._discover_scan(ip_range=ip_range, timeout=timeout)
            #     discovered_devices.update(devices)

        logger.debug(f"RawSocket discovered devices before filtering: {discovered_devices}")

        # Filtering will be handled externally in Instrument.list_instruments

        return discovered_devices

    @staticmethod
    def _discover_udp(timeout: float, ip_range: str) -> Dict[str, str]:
        """Discover instruments via UDP broadcast within a specific IP range."""
        discovered_devices = {}
        discovered_ips = set()  
        port = 30303  # PIC32 discovery port

        # Check for GUI context once
        has_gui = QApplication.instance() is not None

        # Derive broadcast address from IP range
        network = ipaddress.ip_network(ip_range, strict=False)
        broadcast_address = str(network.broadcast_address)

        logger.debug(f"Starting UDP discovery on {broadcast_address}:{port}")

        try:
            with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
                sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
                sock.bind(('', port))
                sock.settimeout(timeout)

                # Send discovery message
                discovery_message = b"Discovery: Who is out there!"
                sock.sendto(discovery_message, (broadcast_address, port))
                logger.debug(f"Sent UDP discovery message to {broadcast_address}:{port}")

                # Collect responses
                start_time = time.time()
                while time.time() - start_time < timeout:
                    try:
                        data, addr = sock.recvfrom(4096)
                        logger.debug(f"Received UDP response from {addr}")
                        discovered_ips.add(addr[0])
                    except socket.timeout:
                        pass
                    
                    if has_gui:
                        QApplication.processEvents()

        except Exception as e:
            logger.exception(f"Failed to perform UDP discovery: {e}")

        # Now try to identify devices on standard ports using parallel scanning
        instrument_ports = [9760]
        discovered_resources = {}

        def scan_port(ip, port):
            if has_gui:
                QApplication.processEvents()
            try:
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                    sock.settimeout(0.5)  # Reduced timeout for faster scanning
                    sock.connect((ip, port))
                    resource = f"TCPIP::{ip}::{port}::SOCKET"
                    logger.info(f"Found device at {ip}:{port}")
                    return resource, resource  # Don't query IDN
            except (socket.timeout, ConnectionRefusedError):
                return None
            except Exception as e:
                logger.debug(f"Error checking {ip}:{port} - {e}")
                return None

        with concurrent.futures.ThreadPoolExecutor(max_workers=100) as executor:
            futures = [
                executor.submit(scan_port, ip, port) 
                for ip in discovered_ips 
                for port in instrument_ports
            ]
            for future in concurrent.futures.as_completed(futures):
                result = future.result()
                if result:
                    unique_id, resource = result
                    discovered_resources[unique_id] = resource

        logger.debug(f"RawSocket discovered devices before filtering: {discovered_resources}")

        # Filtering will be handled externally in Instrument.list_instruments

        return discovered_resources

    @staticmethod
    def get_all_local_ip_ranges(default: str = "192.168.1.0/24") -> List[str]:
        """
        Retrieve all local IPv4 addresses and derive their subnets.

        Args:
            default (str): Default subnet to use if no valid IPs are found

        Returns:
            List[str]: A list of IP ranges in CIDR notation
        """
        ip_ranges = []
        try:
            hostname = socket.gethostname()
            logger.debug(f"Host name: {hostname}")
            host_info = socket.gethostbyname_ex(hostname)
            # host_info[2] contains a list of IP addresses
            for ip in host_info[2]:
                try:
                    # Exclude loopback and non-private IPs
                    if ip.startswith("127.") or not RawSocketConnection.is_private_ip(ip):
                        continue
                    network = ipaddress.IPv4Network(f"{ip}/24", strict=False)
                    ip_ranges.append(str(network))
                    logger.debug(f"Derived network from IP {ip}: {network}")
                except ValueError as ve:
                    logger.warning(f"Invalid IP address '{ip}': {ve}")
        except Exception as e:
            logger.error(f"Failed to retrieve local IP addresses: {e}")
            ip_ranges.append(default)
            logger.debug(f"Using default IP range: {default}")

        return ip_ranges if ip_ranges else [default]

    @staticmethod
    def is_private_ip(ip: str) -> bool:
        """
        Check if the given IP address is within a private network range.

        Args:
            ip (str): IP address to check

        Returns:
            bool: True if private, False otherwise
        """
        private_networks = [
            ipaddress.IPv4Network('10.0.0.0/8'),
            ipaddress.IPv4Network('172.16.0.0/12'),
            ipaddress.IPv4Network('192.168.0.0/16'),
        ]
        ip_addr = ipaddress.IPv4Address(ip)
        return any(ip_addr in network for network in private_networks)
    
    @staticmethod
    def parse_datagram(datagram: bytes) -> str:
        """
        Parse PIC32 UDP response datagram.
        PIC32 devices using Microchip's TCP/IP stack typically respond with ASCII text
        containing device information and network configuration.

        Args:
            datagram (bytes): The received UDP datagram.

        Returns:
            str: The parsed device identifier or empty string if parsing fails.
        """
        try:
            # PIC32 responses are typically ASCII
            data_str = datagram.decode('ascii').strip()
            logger.debug(f"Parsing PIC32 response: {data_str}")
            
            # Extract device identifier (usually first part of response)
            device_id = data_str.split(',')[0].strip()
            return device_id

        except Exception as e:
            logger.error(f"Failed to parse PIC32 response '{datagram.hex()}': {e}")
            return ""
    
    @staticmethod
    def _discover_mdns(timeout: float) -> Dict[str, str]:
        """
        Discover instruments via mDNS.

        Args:
            timeout (float): Timeout for discovery in seconds.

        Returns:
            dict[str, str]: A dictionary mapping unique IDs to resource strings.
        """
        discovered_devices = {}
        service_type = "_instrument._tcp.local."  # Replace with your instrument's service type

        logger.debug(f"Starting mDNS discovery for service type: {service_type}")

        class InstrumentListener:
            def __init__(self):
                self.devices = {}

            def remove_service(self, zeroconf, type, name):
                logger.debug(f"Service {name} removed")

            def add_service(self, zeroconf, type, name):
                info = zeroconf.get_service_info(type, name)
                if info:
                    addr = socket.inet_ntoa(info.addresses[0])
                    port = info.port
                    properties = info.properties
                    unique_id = properties.get(b'unique_id', b'').decode('utf-8')
                    if unique_id:
                        resource = f"TCPIP::{addr}::{port}::SOCKET"
                        self.devices[unique_id] = resource
                        logger.info(f"Discovered mDNS Instrument - ID: {unique_id}, Resource: {resource}")

            def update_service(self, zeroconf, type, name):
                logger.debug(f"Service {name} updated")
                self.add_service(zeroconf, type, name)

        zeroconf = Zeroconf()
        listener = InstrumentListener()
        browser = ServiceBrowser(zeroconf, service_type, listener)

        try:
            logger.debug(f"Waiting for mDNS responses for {timeout} seconds...")
            time.sleep(timeout)
        finally:
            zeroconf.close()

        discovered_devices = listener.devices
        logger.debug(f"mDNS discovery completed. Devices found: {discovered_devices}")

        return discovered_devices

    @staticmethod
    def _discover_scan(ip_range: Optional[str] = None, ports: list = [5025, 9760, 1234], 
                      timeout: float = 3.0) -> Dict[str, str]:
        """
        Discover instruments by scanning a range of IP addresses and specific ports.

        Args:
            ip_range (str, optional): IP range in CIDR notation. If None, detect automatically.
            ports (list): List of port numbers to scan.
            timeout (float): Timeout for each connection attempt in seconds.

        Returns:
            dict[str, str]: A dictionary mapping unique IDs to resource strings.
        """
        if ip_range is None:
            ip_ranges = RawSocketConnection.get_all_local_ip_ranges()
        else:
            ip_ranges = [ip_range]

        discovered_devices = {}
        logger.debug(f"Starting network scan on IP range(s): {ip_ranges}, Ports: {ports}")

        for current_ip_range in ip_ranges:
            try:
                network = ipaddress.ip_network(current_ip_range, strict=False)
            except ValueError as e:
                logger.error(f"Invalid IP range '{current_ip_range}': {e}")
                continue

            def scan_ip(ip, port):
                if QApplication.instance() is not None:
                    QApplication.processEvents()
                    
                with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
                    sock.settimeout(timeout)
                    try:
                        sock.connect((str(ip), port))
                        resource = f"TCPIP::{ip}::{port}::SOCKET"
                        logger.info(f"Found device at {ip}:{port}")
                        return resource, resource  # Don't query IDN
                    except (socket.timeout, ConnectionRefusedError):
                        pass
                    except Exception as e:
                        logger.debug(f"Error scanning {ip}:{port} - {e}")
                return None

            # Utilize ThreadPoolExecutor for efficient scanning
            with concurrent.futures.ThreadPoolExecutor(max_workers=100) as executor:
                futures = [executor.submit(scan_ip, ip, port) 
                          for ip in network.hosts() 
                          for port in ports]
                
                for future in concurrent.futures.as_completed(futures):
                    result = future.result()
                    if result:
                        unique_id, resource = result
                        discovered_devices[unique_id] = resource

        logger.debug(f"Network scan completed. Devices found: {discovered_devices}")

        return discovered_devices



================================================================================
*** dsox1204g.py ***
### src/pymetr/drivers/dsox1204g.py ###
================================================================================

# dsox1204g.py
"""
Keysight DSOX1204G Oscilloscope Driver

Rewritten to use the new queue-based architecture:
 - Inherits from SCPIInstrument (async read/write/query).
 - Removes direct QThread/QTimer references.
 - Each method enqueues commands for the worker to process.
 - 'fetch_trace()' is turned into an asynchronous method that returns data 
   after an acquisition is complete, using a DataBlockProperty or a callback.

Usage in your scripts or UI code remains mostly the same, but be aware all 
communication is now asynchronous.
"""

import logging
import numpy as np

from scpi.core.scpi_instrument import SCPIInstrument
from scpi.core.subsystem import Subsystem
from scpi.core.sources import Sources
from scpi.core.trace import Trace
from scpi.core.properties import (
    SwitchProperty,
    SelectProperty,
    ValueProperty,
    DataProperty,
    DataBlockProperty
)

logger = logging.getLogger(__name__)


class Dsox1204g(SCPIInstrument):
    """
    Driver for Keysight DSOX1204G. Demonstrates:
     - Asynchronous SCPI commands
     - Subsystems for waveforms, triggers, timebase, etc.
     - fetch_trace() example using DataBlockProperty
    """

    def __init__(self, connection):
        """
        Args:
            connection: a ConnectionInterface object 
                        (PyVisaConnection, RawSocketConnection, etc.).
        """
        super().__init__(connection)

        self._format = "BYTE"  # Global data format
        self.sources = Sources(['CHAN1', 'CHAN2', 'CHAN3', 'CHAN4'])
        self.sources.source = ["CHAN1"]

        # X-axis data caching for repeated fetches
        self.x_data = {}

        # Build subsystems
        self.waveform = Waveform.build(self, ':WAVeform')
        self.trigger  = Trigger.build(self, ':TRIGger')
        self.timebase = Timebase.build(self, ':TIMebase')
        self.wavegen  = WaveGen.build(self, ':WGEN')
        self.acquire  = Acquire.build(self, ':ACQuire')
        self.channel  = Channel.build(self, ':CHANnel', indices=4)

    # ------------------------------------------------
    # "format" property controlling global data format
    # ------------------------------------------------
    @property
    def format(self):
        return self._format

    @format.setter
    def format(self, new_fmt):
        if new_fmt not in ["ASCII", "BYTE", "WORD"]:
            raise ValueError("Invalid data format. Must be 'ASCII', 'BYTE', or 'WORD'.")
        self._format = new_fmt

    # ------------------------------------------------
    # GUI Commands (decorators)
    # ------------------------------------------------
    @SCPIInstrument.gui_command
    @Sources.source_command(":AUTOScale {}")
    def autoscale(self, *sources):
        """
        Autoscale the scope for given channels. 
        Because the decorator is used, the UI can auto-generate a button.
        """
        pass

    @SCPIInstrument.gui_command
    def digitize(self, *sources):
        """
        Calls fetch_trace() (async) to get a fresh trace from the scope.
        """
        logger.debug("Digitize command called.")
        self.fetch_trace()

    @SCPIInstrument.gui_command
    def single(self):
        """
        Performs a single acquisition:
         1) Stop
         2) *OPC? wait
         3) :SINGle
         4) Wait for armed + acquisition done
         5) fetch_trace()
        """
        logger.debug("Single trigger command received.")
        self.continuous_mode = False
        self.write(":STOP")
        self.query_operation_complete()   # async *OPC?
        self.write(":SINGle")
        self._enqueue_check_trigger_armed()

    @SCPIInstrument.gui_command
    def stop(self):
        logger.debug("Stop command received.")
        self.write(":STOP")
        self.continuous_mode = False

    @SCPIInstrument.gui_command
    def run(self):
        """
        Puts scope in continuous run mode, then starts checking triggers 
        in the background if desired. 
        """
        logger.debug("Run command received.")
        self.write(":RUN")
        self.continuous_mode = True
        # If you want to keep polling the scope in the background, 
        # you can do something like self._enqueue_check_trigger_armed() again.
        # but let's keep it minimal unless you need continuous data

    # ------------------------------------------------
    # Checking armed or acquisition done
    # ------------------------------------------------
    def _enqueue_check_trigger_armed(self):
        """
        We enqueue a command to query(":AER?"), then parse the response 
        in responseReceived to see if armed=1. 
        If not armed, we re-enqueue a short 'delay' or re-check. 
        Once armed, call wait_for_acquisition_complete.
        """
        logger.debug("Enqueue check_trigger_armed -> :AER?")
        self.query(":AER?")

    def _enqueue_check_acquisition_done(self):
        logger.debug("Enqueue check_acquisition_done -> :OPERegister:CONDition?")
        self.query(":OPERegister:CONDition?")

    # If you want to handle these in responseReceived, you can parse the value 
    # and re-enqueue if not done, or call fetch_trace when done.

    # ------------------------------------------------
    # Asynchronous fetch_trace
    # ------------------------------------------------
    @Sources.source_command(":DIGitize {}")
    def fetch_trace(self, *sources):
        """
        1) :DIGitize (enqueued by decorator).
        2) *OPC? wait or manual check (we can do query_operation_complete here).
        3) read the waveforms for each active channel, build a list of Trace objects, return them.

        Because of the @trace_thread decorator, the returning data 
        is automatically emitted to `traceDataReady` signal as well.
        """
        self.query_operation_complete()
        logger.debug(f"Fetching trace data from scope {self}")
        if not sources:
            sources = self.sources.source

        traces = []
        for source in sources:
            time_vals = self._fetch_time(source)
            data_vals = self._fetch_data(source)
            trace_obj = Trace(data_vals, x_data=time_vals, label=source)
            traces.append(trace_obj)

        return traces

    def _fetch_time(self, source=None):
        """
        Gets the horizontal scale info from the waveform preamble, builds time array.
        """
        if source:
            self.waveform.source = source

        try:
            preamble = self.waveform.preamble
            self._x_increment, self._x_origin, self._x_reference = preamble[4], preamble[5], int(preamble[6])
            self._y_increment, self._y_origin, self._y_reference = preamble[7], preamble[8], int(preamble[9])
            self.waveform.format = self._format

            count_points = self.waveform.points
            timestamps = (np.arange(count_points) - self._x_reference) * self._x_increment + self._x_origin
            return timestamps
        except Exception as e:
            raise ValueError(f"Issue fetching or parsing preamble: {e}")

    def _fetch_data(self, source=None):
        """
        Fetch raw data from self.waveform.data, convert if binary, etc.
        """
        if source:
            self.waveform.source = source

        self.waveform.format = self.format
        is_unsigned = self.waveform.unsigned

        if self._format in ["BYTE", "WORD"]:
            # e.g. 'B' vs 'b' for data_type
            data_type = 'B' if is_unsigned else 'b'
            self.data_type = data_type
            self.data_mode = "BINARY"
        else:
            self.data_type = 'B'
            self.data_mode = "ASCII"

        # read the raw data
        raw_data = self.waveform.data

        # Convert if binary:
        if self._format in ["BYTE", "WORD"]:
            voltages = (raw_data - self._y_reference) * self._y_increment + self._y_origin
        elif self._format == "ASCII":
            voltages = raw_data
        else:
            raise ValueError(f"Unsupported data format: {self.format}")

        return voltages


# ---------------------------------------------------------------------------
# Subsystems
# ---------------------------------------------------------------------------
class Acquire(Subsystem):
    mode         = SelectProperty(":MODE", ['RTIMe', 'SEGMmented'], "Acquisition mode")
    type         = SelectProperty(":TYPE", ['NORMal','AVERage','HRESolution','PEAK'], "Acq type")
    sample_rate  = ValueProperty(":SRATe",  type="float", range=[0.1, 1e9], units="S/s", doc_str="Sample rate")
    count        = ValueProperty(":COUNt", type="int",   range=[1, 10000],  doc_str="Averaging count / acquisitions")

class Channel(Subsystem):
    coupling = SelectProperty(":COUPling", ['AC', 'DC'], "Channel coupling")
    display  = SwitchProperty(":DISPlay",  "Channel on/off")
    scale    = ValueProperty(":SCALe",     type="float", range=[1e-3,1e3], units="V", doc_str="Vert scale")
    offset   = ValueProperty(":OFFSet",    type="float", range=[-1e2,1e2], units="V", doc_str="Vertical offset")
    probe    = ValueProperty(":PROBe",     type="float", doc_str="Probe attenuation")

class Timebase(Subsystem):
    mode       = SelectProperty(":MODE",       ['MAIN','WIND','XY','ROLL'], "Timebase mode")
    reference  = SelectProperty(":REFerence",  ['LEFT','CENTer','RIGHT'],   "Timebase ref")
    scale      = ValueProperty(":SCALe",       type="float", range=[1e-9,1.0],units="s", doc_str="Timebase scale")
    position   = ValueProperty(":POSition",    type="float", range=[-5.0,5.0],units="s", doc_str="Timebase pos")
    range      = ValueProperty(":RANGe",       type="float", range=[2e-9,50], units="s", doc_str="Timebase range")

class Trigger(Subsystem):
    mode   = SelectProperty(":MODe",   ['EDGE','GLITch','PATTern','SHOL','NONE'], "Trig mode")
    source = SelectProperty(":SOURce", ['CHAN1','CHAN2','CHAN3','CHAN4','EXT','LINE','WGEN'], "Trig source")
    slope  = SelectProperty(":SLOPe",  ['POSitive','NEGative'], "Trig slope")
    sweep  = SelectProperty(":SWEep",  ['AUTO','NORMAL'],       "Sweep mode")
    level  = ValueProperty(":LEVel",   type="float", range=[-5,5],units="V", doc_str="Trig level")

class WaveGen(Subsystem):
    function   = SelectProperty(":FUNC",  ['SIN','SQUare','RAMP','PULSe','NOISe','DC'], "Wavegen function")
    output     = SwitchProperty(":OUTP", "Wavegen output on/off")
    frequency  = ValueProperty(":FREQ",  type="float", range=[1e-3,1e8], units="Hz", doc_str="Wavegen freq")
    amplitude  = ValueProperty(":VOLT",  type="float", range=[1e-3,10],  units="V",  doc_str="Wavegen amplitude")
    offset     = ValueProperty(":VOLT:OFFS",type="float",range=[-5,5],   units="V",  doc_str="Wavegen offset")

class Waveform(Subsystem):
    source       = SelectProperty(":SOURce", ['CHAN1','CHAN2','CHAN3','CHAN4','FUNC','MATH','FFT','WMEM','BUS1','BUS2','EXT'], "Waveform src")
    format       = SelectProperty(":FORMat", ['ASCII','WORD','BYTE'],  "Waveform data fmt")
    points_mode  = SelectProperty(":POINts:MODE", ['NORMal','MAXimum','RAW'], "Points mode")
    byte_order   = SelectProperty(":BYTeorder", ['LSBFirst','MSBFirst'],      "Byte order")
    unsigned     = SwitchProperty(":UNSigned", "Data signed or unsigned")
    points       = ValueProperty(":POINts",  type="int", access='write', doc_str="Trace points to fetch")
    x_increment  = DataProperty(":XINCrement", doc_str="Waveform X incr")
    x_origin     = DataProperty(":XORigin",     doc_str="Waveform X origin")
    x_reference  = DataProperty(":XREFerence",  doc_str="Waveform X ref")
    y_increment  = DataProperty(":YINCrement", doc_str="Waveform Y incr")
    y_origin     = DataProperty(":YORigin",     doc_str="Waveform Y origin")
    y_reference  = DataProperty(":YREFerence",  doc_str="Waveform Y ref")
    preamble     = DataProperty(":PREamble", access='read', doc_str="Pre info")
    data         = DataBlockProperty(":DATa",   access='read', ieee_header=True, doc_str="Waveform data array")



================================================================================
*** hp8563a.py ***
### src/pymetr/drivers/hp8563a.py ###
================================================================================

# hp8563a.py

"""
HP 8563A Spectrum Analyzer Driver with improved non-blocking trace acquisition
"""

import logging
from enum import Enum
import numpy as np

from scpi.core.subsystem import Subsystem
from scpi.core.scpi_instrument import SCPIInstrument
from scpi.core.properties import (
    ValueProperty, SelectProperty, SwitchProperty, DataProperty
)

logger = logging.getLogger(__name__)

class TriggerMode(Enum):
    FREE = "FREE"
    SINGLE = "SNGLS"
    LINE = "LINE"
    VIDEO = "VID"
    EXTERNAL = "EXT"

class ScaleType(Enum):
    LINEAR = "LIN"
    LOG = "LOG"

class DetectorMode(Enum):
    NORMAL = "NRM"
    POSITIVE = "POS"
    NEGATIVE = "NEG"
    SAMPLE = "SMP"

class FrequencySubsystem(Subsystem):
    """Frequency control subsystem"""
    center = ValueProperty("CF", type="float", doc_str="Center freq (e.g. '1GHz')")
    span = ValueProperty("SP", type="float", doc_str="Span freq (e.g. '100MHz')")
    start = ValueProperty("FA", type="float", doc_str="Start frequency")
    stop = ValueProperty("FB", type="float", doc_str="Stop frequency")

class AmplitudeSubsystem(Subsystem):
    """Amplitude and attenuation control"""
    reference_level = ValueProperty("RL", type="float", range=(-139.9, 30), units="dBm", doc_str="Reference level")
    attenuation = ValueProperty("AT", type="float", range=(0, 70), units="dB", doc_str="Input attenuation")
    scale_type = SelectProperty("SCAL", ["LIN", "LOG"], doc_str="Amplitude scale type")

class BandwidthSubsystem(Subsystem):
    """Resolution and video bandwidth control"""
    resolution = ValueProperty("RB", type="float", range=(10, 3e6), units="Hz", doc_str="Resolution bandwidth")
    video = ValueProperty("VB", type="float", range=(1, 3e6), units="Hz", doc_str="Video bandwidth")

class SweepSubsystem(Subsystem):
    """Sweep control subsystem"""
    time = ValueProperty("ST", type="float", range=(20e-6, 100), units="s", doc_str="Sweep time")
    auto_time = SwitchProperty("ST AUTO", doc_str="Auto sweep time")
    trigger_mode = SelectProperty("TM", TriggerMode, doc_str="Trigger mode selection")
    continuous = SwitchProperty("CONTS", doc_str="Continuous sweep")

class TraceSubsystem(Subsystem):
    """Trace data and display control"""
    detector = SelectProperty("DET", DetectorMode, doc_str="Trace detector mode")
    data = DataProperty("TRA", access='read', doc_str="Trace A data (601 points)", 
                       container=np.array, converter=float, separator=',', terminator='\r\n')

class HP8563A(SCPIInstrument):
    """
    HP8563A Spectrum Analyzer driver with improved non-blocking trace acquisition.
    
    Features:
    - Full frequency control (start/stop/center/span)
    - Resolution and video bandwidth
    - Reference level and attenuation
    - Sweep and trigger controls
    - Non-blocking trace data acquisition
    """

    def __init__(self, connection):
        super().__init__(connection)
        logger.debug("Initializing HP8563A Spectrum Analyzer Driver")

        # Build subsystems
        logger.debug("Building subsystems")
        self.frequency = FrequencySubsystem.build(self, "")
        self.amplitude = AmplitudeSubsystem.build(self, "")
        self.bandwidth = BandwidthSubsystem.build(self, "")
        self.sweep = SweepSubsystem.build(self, "")
        self.trace = TraceSubsystem.build(self, "")
        logger.debug("Subsystems initialized successfully")

        # Initialize state
        self._sweep_in_progress = False
        self._sweep_complete = False

    def fetch_trace(self):
        """
        Start trace acquisition and emit signal when complete.
        Uses non-blocking reads to prevent UI blocking.
        """
        try:
            logger.debug("Starting trace acquisition")
            
            # Clear any previous sweep state
            self._sweep_in_progress = False
            self._sweep_complete = False
            
            # Put in single sweep mode and start sweep
            self.sweep.trigger_mode = TriggerMode.SINGLE
            self.write("SNGLS")
            self._sweep_in_progress = True
            
            # Get sweep parameters using property system
            start_freq = self.frequency.start
            stop_freq = self.frequency.stop
            sweep_time = self.sweep.time
            
            # Now read the trace data - this will use our non-blocking read implementation
            amp_data = self.trace.data
            
            # Create frequency axis
            freq_points = len(amp_data)
            freq_axis = np.linspace(start_freq, stop_freq, freq_points)
            
            # Emit the data
            self.traceDataReady.emit(freq_axis, amp_data)
            logger.debug(f"Emitted trace data: {freq_points} points")
            
            self._sweep_complete = True
            self._sweep_in_progress = False
            
            return freq_axis, amp_data
        
        except Exception as e:
            self._sweep_in_progress = False
            logger.error(f"Error in fetch_trace: {e}")
            self.exceptionOccured.emit(str(e))
            raise

    def is_sweep_complete(self) -> bool:
        """Check if the current sweep operation is complete."""
        if not self._sweep_in_progress:
            return self._sweep_complete
            
        try:
            # Check sweep status
            response = self.query("DONE?")
            if response.strip() == "1":
                self._sweep_in_progress = False
                self._sweep_complete = True
                
        except Exception as e:
            logger.error(f"Error checking sweep status: {e}")
            self._sweep_in_progress = False
            
        return self._sweep_complete

    def abort_sweep(self):
        """Abort the current sweep operation."""
        try:
            self.write("ABORT")
            self._sweep_in_progress = False
            self._sweep_complete = False
        except Exception as e:
            logger.error(f"Error aborting sweep: {e}")
            raise

    def single_sweep(self):
        """Initiates a single sweep."""
        logger.debug("Initiating single sweep")
        try:
            self.sweep.trigger_mode = TriggerMode.SINGLE
            self.write("SNGLS")
            self._sweep_in_progress = True
            self._sweep_complete = False
        except Exception as e:
            logger.error(f"Error initiating single sweep: {e}")
            raise

    def continuous_sweep(self):
        """Sets continuous sweep mode."""
        logger.debug("Setting continuous sweep mode")
        try:
            self.sweep.trigger_mode = TriggerMode.FREE
            self.write("CONT")
            self._sweep_in_progress = False
            self._sweep_complete = False
        except Exception as e:
            logger.error(f"Error setting continuous sweep mode: {e}")
            raise

    def preset(self):
        """Presets the instrument to default state."""
        logger.debug("Presetting instrument to default state")
        try:
            self.write("IP")
            self._sweep_in_progress = False
            self._sweep_complete = False
        except Exception as e:
            logger.error(f"Error presetting instrument: {e}")
            raise

    def get_identity(self) -> str:
        """
        Query the instrument identity (*IDN?).
        
        Returns:
            str: The instrument's identification string
        """
        logger.debug("Querying instrument identity")
        try:
            identity = self.query("ID?")
            logger.debug(f"Instrument identity: {identity}")
            return identity
        except Exception as e:
            logger.error(f"Error querying instrument identity: {e}")
            raise

    def check_error(self) -> tuple[int, str]:
        """
        Query the error queue.
        
        Returns:
            tuple: (error_code, error_message)
        """
        try:
            response = self.query("ERR?")
            code = int(response)
            msg = {
                0: "No error",
                -410: "Query INTERRUPTED",
                -420: "Query UNTERMINATED",
                -430: "Query DEADLOCKED"
            }.get(code, "Unknown error")
            return code, msg
        except Exception as e:
            logger.error(f"Error checking error queue: {e}")
            raise


================================================================================
*** hs9000.py ***
### src/pymetr/drivers/hs9000.py ###
================================================================================

import logging
from scpi.core.scpi_instrument import SCPIInstrument
from scpi.core.subsystem import Subsystem
from scpi.core.properties import (
    ValueProperty, SelectProperty, SwitchProperty
)

logger = logging.getLogger(__name__)

class HSXSynth(SCPIInstrument):
    """
    HSX Series Synthesizer Driver

    Features:
    - Multiple channels (CH1..CHn) for freq/power/phase control
    - Reference clock selection and monitoring
    - Built-in diagnostics
    - Network configuration
    - Temperature monitoring

    Usage:
        synth = HSXSynth(connection, channels=4)
        synth.ch[1].frequency = "2105MHz"
        synth.ch[2].output = True
        synth.ref.source = "EXT:10MHz"
        synth.diag.start()
    """

    def __init__(self, connection, channels: int = 4):
        super().__init__(connection)
        
        # Build subsystems
        self.ch = Channel_Subsystem.build(self, ":CH", indices=channels)
        self.ref = Reference_Subsystem.build(self, ":REF")
        self.diag = HSXDiagnostics.build(self, ":HSX:DIAG")
        self.ip = IP_Subsystem.build(self, ":IP")
        self.comm = Communication_Subsystem.build(self, ":COMM")

        # Set response mode based on read_after_write flag
        if self.read_after_write:
            self.comm.respond = True

class Channel_Subsystem(Subsystem):
    """
    Represents a single synthesizer channel (n) with properties and methods.
    Commands use the pattern :CHn:<command>
    """
    # Frequency settings with unit suffixes
    frequency = ValueProperty(":FREQ", type="float", range=(10e6, 6e9), units="Hz", doc_str="Channel output frequency", join_char=":")
    freq_min = ValueProperty(":FREQ:MIN", access='read', doc_str="Min freq for this channel", join_char=":")
    freq_max = ValueProperty(":FREQ:MAX", access='read', doc_str="Max freq for this channel", join_char=":")

    # Power settings
    power = ValueProperty(":PWR", type="float", range=(-20, 20), units="dBm",doc_str="Channel output power", join_char=":")
    output = SwitchProperty(":PWR:RF", doc_str="RF output state", join_char=":")
    power_mode = SelectProperty(":PWR:MODE", ["AUTO", "HIGH", "NORMAL", "FIX"],doc_str="Power/attenuator mode", join_char=":")

    # Phase settings
    phase = ValueProperty(":PHASE", type="float", range=(0, 360), units="deg",doc_str="Phase offset", join_char=":")
    phase_max = ValueProperty(":PHASE:MAX", access='read', doc_str="Max phase for current freq", join_char=":")
    phase_res = ValueProperty(":PHASE:RES", access='read',doc_str="Phase resolution", join_char=":")

    # Temperature monitoring
    temperature = ValueProperty(":TEMP", access='read', type="float", doc_str="Channel temperature in Â°C", join_char=":")

class Reference_Subsystem(Subsystem):
    """
    Reference clock subsystem.
    Commands use pattern :REF:<command>
    """
    source = SelectProperty("", ["EXT:10MHz", "INT:100MHz"], doc_str="Reference clock source", join_char=":")

class IP_Subsystem(Subsystem):
    """
    IP address configuration subsystem.
    Commands use pattern :IP:<command>
    """
    mode = SelectProperty(":STATUS", ["STATIC", "DHCP"], doc_str="IP address mode", join_char=":")
    address = ValueProperty(":ADDR", doc_str="Static IP address", join_char=":")
    subnet = ValueProperty(":SUBNET", doc_str="Subnet mask", join_char=":")
    gateway = ValueProperty(":GATEWAY", doc_str="Gateway address", join_char=":")

class Communication_Subsystem(Subsystem):
    """
    Communication settings subsystem.
    Commands use pattern :COMM:<command>
    """
    respond = SwitchProperty(":RESPOND", doc_str="Enable responses for all commands", join_char=":")

class HSXDiagnostics(Subsystem):
    """
    Diagnostics subsystem.
    Commands use pattern :HSX:DIAG:<command>
    """
    def start(self):
        """Start mini diagnostics routine."""
        self.write(f"{self.cmd_prefix}:MIN:START")

    def get_status(self) -> str:
        """Query diagnostics status."""
        return self.query(f"{self.cmd_prefix}:DONE")

    def get_errors(self) -> str:
        """Query diagnostic errors."""
        return self.query(f"{self.cmd_prefix}:ERROR")
        
    def get_board_info(self) -> str:
        """Query board information."""
        return self.query(f"{self.cmd_prefix}:INFO:BOARDS")


================================================================================
*** registry.py ***
### src/pymetr/drivers/registry.py ###
================================================================================

"""
Registry mapping instrument model numbers to their driver implementations.
"""

from typing import Dict

DRIVER_REGISTRY: Dict[str, Dict[str, str]] = {
    "HP8563A": {
        "module": "drivers.hp8563a",
        "class": "HP8563A"
    },
    "HP8564E": {
        "module": "drivers.hp8564e",
        "class": "HP8564E"
    },
    "HP8657B": {
        "module": "drivers.hp8657b",
        "class": "HP8657B"
    },
    "HP437B": {
        "module": "drivers.hp437b",
        "class": "HP437B"
    },
    "HS9001B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9002B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9003B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9004B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9005B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9006B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9007B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9008B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9009B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9010B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9011B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9012B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9013B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9014B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9015B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    },
    "HS9016B": {
        "module": "drivers.hs9000.py",
        "class": "HS9000"
    }
    # Add more models as needed
}

def get_driver_info(model: str) -> Dict[str, str]:
    """
    Get driver module and class information for a given model.
    Raises ValueError if model not found.
    """
    if model not in DRIVER_REGISTRY:
        raise ValueError(f"No driver registered for model: {model}")
    return DRIVER_REGISTRY[model]


================================================================================
*** current_test.py ***
### src/pymetr/example_scripts/current_test.py ###
================================================================================

# Current Test Script
import time
from instrument_utils import get_dut

def test_current():
    """Run automated current measurements."""
    # Get the DUT
    dut = get_dut()
    
    # Configure current measurement
    set_test_progress(10, "Configuring current measurement...")
    dut.configure_current_measurement()
    
    # Take measurements
    set_test_progress(50, "Taking current measurements...")
    result = new_result("Current Test")
    measurements = dut.measure_current()
    time.sleep(0.5)  # Simulation
    
    # Test paused at 50% for demonstration
    return result



================================================================================
*** voltage_test.py ***
### src/pymetr/example_scripts/voltage_test.py ###
================================================================================

# Voltage Test Script
import time
from instrument_utils import get_dut

def test_voltage():
    """Run automated voltage measurements."""
    # Get the DUT
    dut = get_dut()
    
    # Configure voltage measurement
    set_test_progress(10, "Configuring voltage measurement...")
    dut.configure_voltage_measurement()
    
    # Take measurements
    set_test_progress(50, "Taking voltage measurements...")
    result = new_result("Voltage Test")
    measurements = dut.measure_voltage()
    
    # Process data
    set_test_progress(75, "Processing measurements...")
    for value in measurements:
        result.add_data_point(value)
        time.sleep(0.1)  # Simulate processing
    
    # Save data and complete
    set_test_progress(90, "Saving results...")
    result.add_data(measurements)
    set_test_progress(100, "Test complete!")
    
    return result



================================================================================
*** __init__.py ***
### src/pymetr/factories/__init__.py ###
================================================================================

# app/factories/__init__.py

from .instrument_factory import InstrumentFactory

__all__ = ['InstrumentFactory']



================================================================================
*** instrument_factory.py ***
### src/pymetr/factories/instrument_factory.py ###
================================================================================

# scpi/app/instrument_factory.py
import logging
logger = logging.getLogger(__name__)
import json
import ast
from gui.visitors import InstrumentVisitor

class InstrumentFactory:
    def __init__(self):
        self.current_instrument = None

    def create_instrument_data_from_driver(self, path):
        logger.debug(f"Creating instrument data from driver: {path}")
        instrument_data = self.parse_source_file(path)
        
        parameter_tree_dict = self.generate_parameter_tree_dict(instrument_data)
        gui_methods_dict = self.generate_gui_methods_dict(instrument_data)
        other_methods_dict = self.generate_other_methods_dict(instrument_data)
        sources_list = self.generate_sources_list(instrument_data)
        return {
            'parameter_tree': parameter_tree_dict,
            'gui_methods': gui_methods_dict,
            'other_methods': other_methods_dict,
            'sources': sources_list
        }

    def set_current_instrument(self, instrument):
        self.current_instrument = instrument
        logger.debug(f"Current instrument set to: {self.current_instrument}")

    def parse_source_file(self, path):
        logger.debug(f"Initiating parse of source file: {path}")
        with open(path, 'r') as file:
            source = file.read()
        tree = ast.parse(source, filename=path)
        visitor = InstrumentVisitor()
        visitor.visit(tree)
        logger.debug(f"Completed parsing. Extracted instruments: {list(visitor.instruments.keys())}")
        return visitor.instruments

    def generate_gui_methods_dict(self, instrument_data):
        logger.info("ð Starting to generate the GUI methods dictionary... ð")
        gui_methods_dict = {}
        for class_name, class_info in instrument_data.items():
            logger.info(f"ð Processing Instrument: {class_name} ð")
            for method_name, method_info in class_info.get('gui_methods', {}).items():
                logger.info(f"ð§ Adding GUI method: {method_name} ð§")
                gui_methods_dict[method_name] = method_info  # Store the method info dictionary
        logger.info("â Finished generating the GUI methods dictionary â")
        return gui_methods_dict

    def generate_other_methods_dict(self, instrument_data):
        logger.info("ð Starting to generate the other methods dictionary... ð")
        other_methods_dict = {}
        for class_name, class_info in instrument_data.items():
            logger.info(f"ð Processing Instrument: {class_name} ð")
            for method_name, method_info in class_info.get('other_methods', {}).items():
                logger.info(f"ð§ Adding other method: {method_name} ð§")
                other_methods_dict[method_name] = method_info  # Store the method info dictionary
        logger.info("â Finished generating the other methods dictionary â")
        return other_methods_dict

    def generate_properties_list(self, properties, class_name, index=None, subsystem=None):
        logger.debug(f"ð Starting to generate properties list for class '{class_name}' with index '{index}'.")
        properties_list = []
        for prop in properties:
            logger.debug(f"ð Processing property '{prop['name']}' of type '{prop['type']}' for class '{class_name}'.")
            param_dict = self.construct_param_dict(prop, class_name, index, subsystem=subsystem)
            if param_dict is not None:
                properties_list.append(param_dict)
                logger.debug(f"â Added property '{prop['name']}' to properties list with path '{param_dict.get('property_path')}'.")
        
        logger.debug(f"ð Finished generating properties list for '{class_name}': Total properties {len(properties_list)}.")
        return properties_list

    def generate_sources_list(self, instrument_data):
        """
        Generates a list of sources for the instrument.
        Args:
            instrument_data (dict): Instrument data, including sources.
        Returns:
            list: A list of sources for the instrument.
        """
        logger.info("ð Generating sources list... ð")
        for class_name, class_info in instrument_data.items():
            if 'sources' in class_info:
                logger.info(f"â Sources found for {class_name}: {class_info['sources']} â")
                return class_info['sources']
        logger.warning("â ï¸ No sources found in the instrument data â ï¸")
        return []

    def construct_param_dict(self, prop, class_name, index=None, subsystem=None):
        logger.debug(f"ð Starting construct_param_dict for '{prop['name']}' in '{class_name}' ð")
        logger.debug(f"ð Peeking at property: {prop}ð")
        property_path = f"{class_name.lower()}"
        if subsystem and subsystem.lower() != class_name.lower():
            property_path += f".{subsystem.lower()}"
        if index is not None:
            property_path += f"[{index}]"  # Fixed: appending the index to the property path
            logger.debug(f"ð Index provided. Appended to property path: [{index}] ð")
        property_path += f".{prop['name']}"
        logger.debug(f"â Property path constructed: {property_path} â")

        # Default settings including suffix and siPrefix initialized to None or False
        param_dict = {
            'name': prop['name'],
            'type': prop['type'].lower(),
            'property_path': property_path,
            'value': None,
            'default': None,
            'readonly': prop.get('access', 'read-write') == 'read',
        }

        if prop['type'] == 'SelectProperty':
            param_dict.update({
                'type': 'list',
                'limits': prop['choices'],
                'value': prop['choices'][0]
            })
        elif prop['type'] == 'ValueProperty':
            param_dict.update({
                'type': prop['type'],
                'limits': prop['range'],
                'value': 0.0
            })
        elif prop['type'] == 'SwitchProperty':
            param_dict.update({
                'type': 'bool',
                'value': False
            })
        elif prop['type'] == 'StringProperty':
            param_dict.update({
                'type': 'str',
                'value': ''
            })
        elif prop['type'] == 'DataProperty':
            # Skip DataProperty for now
            return None
        
        # Explicit check and log for units
        if 'units' in prop:
            param_dict['suffix'] = prop['units']
            param_dict['siPrefix'] = bool(prop['units'])
            logger.debug(f"ð Setting units for '{prop['name']}' to '{prop['units']}' ð")
        else:
            logger.debug(f"ð« No units found for '{prop['name']}' during construction ð«")

        logger.debug(f"â¨ Constructed parameter dict for '{prop['name']}': {param_dict} â¨")
        return param_dict
    
    def generate_parameter_tree_dict(self, instrument_data):
        """
        Generates a parameter tree dictionary from the instrument data, including subsystems and their properties.
        
        Args:
            instrument_data (dict): Instrument data, including subsystems and their properties.
        
        Returns:
            list: A parameter tree structure as a list of dictionaries.
        """
        logger.debug("ð³ Starting to generate the parameter tree... ð³")
        tree_dict = []

        for class_name, class_info in instrument_data.items():
            logger.debug(f"ð Processing class: {class_name} ð")
            class_group = {
                'name': class_name,
                'type': 'group',
                'children': []
            }

            # Add the sources group
            sources_group = {
                'name': 'Sources',
                'type': 'group',
                'children': []
            }

            # Populate the sources group with checkboxes
            sources_list = class_info.get('sources', [])
            for source in sources_list:
                source_param = {
                    'name': source,
                    'type': 'bool',
                    'value': False,  # Set the initial value to False (unchecked)
                    'default': None
                }
                sources_group['children'].append(source_param)

            class_group['children'].append(sources_group)

            # Add the subsystem properties to the dictionary
            for subsystem_name, subsystem_info in class_info.get('subsystems', {}).items():
                logger.debug(f"ð  Creating subsystem group: {subsystem_name} ð ")
                subsystem_group = self.create_subsystem_group(subsystem_name, subsystem_info)
                class_group['children'].append(subsystem_group)

            tree_dict.append(class_group)
            logger.debug(f"ð² Added class group: {class_name} to the tree ð²")

        logger.debug(f"ð Generated parameter tree dictionary: {tree_dict} ð")
        logger.debug("ð Finished generating the parameter tree ð")
        return tree_dict

    def create_subsystem_group(self, subsystem_name, subsystem_info):
        logger.debug(f"ð§ Starting to create subsystem group for: {subsystem_name} ð§")
        if subsystem_info.get('needs_indexing', False):
            logger.debug(f"âï¸ {subsystem_name} requires indexing âï¸")
            parent_group = {
                'name': subsystem_name,
                'type': 'group',
                'children': []
            }

            for index, instance_info in subsystem_info['instances'].items():
                logger.debug(f"ð Creating indexed group for {subsystem_name}{index} ð")
                indexed_group = {
                    'name': f"{subsystem_name}{index}",
                    'type': 'group',
                    'children': self.generate_properties_list(instance_info['properties'], subsystem_name, index=index)
                }
                parent_group['children'].append(indexed_group)
                logger.debug(f"ð Added indexed group for {subsystem_name}{index} ð")
            
            logger.debug(f"ð Completed indexed groups for {subsystem_name} ð")
            return parent_group
        else:
            logger.debug(f"ð Creating group for non-indexed subsystem: {subsystem_name} ð")
            group = {
                'name': subsystem_name,
                'type': 'group',
                'children': self.generate_properties_list(subsystem_info['properties'], subsystem_name)
            }
            logger.debug(f"â¨ Finished creating group for non-indexed subsystem: {subsystem_name} â¨")
            return group
    
if __name__ == "__main__":

    factory = InstrumentFactory()

    # Load a test driver
    path = 'scpi/drivers/dsox1204g.py'  
    with open(path, 'r') as file:
        source = file.read()

    instrument_data = factory.create_instrument_data_from_driver(path)

    print(json.dumps(instrument_data, indent=2))
    print(instrument_data)


================================================================================
*** __init__.py ***
### src/pymetr/models/__init__.py ###
================================================================================




================================================================================
*** base.py ***
### src/pymetr/models/base.py ###
================================================================================

# src/models/base.py
from typing import Dict, Any, Optional
import uuid

class BaseModel:
    """Base class for all models in the application"""
    def __init__(self, model_id: Optional[str] = None):
        self._id = model_id or str(uuid.uuid4())
        self._properties: Dict[str, Any] = {}
        
    @property
    def id(self) -> str:
        return self._id
        
    def get_property(self, key: str, default: Any = None) -> Any:
        return self._properties.get(key, default)
        
    def set_property(self, key: str, value: Any) -> None:
        self._properties[key] = value
        
    def to_dict(self) -> Dict[str, Any]:
        """Convert model to dictionary for serialization"""
        return {
            'id': self._id,
            'properties': self._properties.copy()
        }
        
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'BaseModel':
        """Create model instance from dictionary"""
        instance = cls(model_id=data['id'])
        instance._properties = data.get('properties', {}).copy()
        return instance


================================================================================
*** cursor.py ***
### src/pymetr/models/cursor.py ###
================================================================================

# app/models/cursor.py

from typing import Dict, Any, Optional
from PySide6.QtCore import QObject, Signal
import logging
from .base import BaseModel

logger = logging.getLogger(__name__)

class Cursor(BaseModel, QObject):
    """
    A movable measurement cursor.
    
    Signals:
        position_changed(str, float): Emitted when position changes (cursor_id, new_position)
        style_changed(str, str, Any): Emitted when style property changes (cursor_id, property_name, value)
        visibility_changed(str, bool): Emitted when visibility changes (cursor_id, is_visible)
    """
    
    position_changed = Signal(str, float)  # cursor_id, new_position
    style_changed = Signal(str, str, Any)  # cursor_id, property_name, value
    visibility_changed = Signal(str, bool)  # cursor_id, is_visible

    def __init__(
        self,
        plot_id: str,
        position: float = 0.0,
        color: str = "#0000FF",
        visible: bool = True,
        id: Optional[str] = None
    ):
        BaseModel.__init__(self, id)
        QObject.__init__(self)
        
        self.plot_id = plot_id
        self._position = position
        self._color = color
        self._visible = visible

        logger.debug(f"Created Cursor with ID: {self.id}")

    @property
    def position(self) -> float:
        return self._position

    @position.setter
    def position(self, value: float):
        old_position = self._position
        self._position = value
        logger.debug(f"Cursor ID={self.id}: Position changed from {old_position} to {value}.")
        self.position_changed.emit(self.id, value)

    @property
    def color(self) -> str:
        return self._color

    @color.setter
    def color(self, value: str):
        old_color = self._color
        self._color = value
        logger.debug(f"Cursor ID={self.id}: Color changed from {old_color} to {value}.")
        self.style_changed.emit(self.id, "color", value)

    @property
    def visible(self) -> bool:
        return self._visible

    @visible.setter
    def visible(self, value: bool):
        old_visibility = self._visible
        self._visible = value
        logger.debug(f"Cursor ID={self.id}: Visibility changed from {old_visibility} to {value}.")
        self.visibility_changed.emit(self.id, value)

    def to_dict(self) -> Dict[str, Any]:
        """Serialize the Cursor to a dictionary."""
        return {
            "id": self.id,
            "plot_id": self.plot_id,
            "position": self.position,
            "color": self.color,
            "visible": self.visible
        }

    @staticmethod
    def from_dict(data: Dict[str, Any]) -> 'Cursor':
        """Deserialize a Cursor from a dictionary."""
        cursor = Cursor(
            plot_id=data["plot_id"],
            position=data.get("position", 0.0),
            color=data.get("color", "#0000FF"),
            visible=data.get("visible", True),
            id=data.get("id")
        )
        logger.debug(f"Cursor.from_dict: Deserialized Cursor ID={cursor.id}")
        return cursor


================================================================================
*** data_table.py ***
### src/pymetr/models/data_table.py ###
================================================================================

# app/models/data_table.py

from typing import Dict, List, Optional, Any
import pandas as pd
from PySide6.QtCore import QObject, Signal
import logging
from .base import BaseModel

logger = logging.getLogger(__name__)

class DataTable(BaseModel, QObject):
    """
    A data table wrapper around pandas DataFrame with UI state tracking.
    
    Signals:
        data_changed(str): Emitted when data content changes (table_id)
        row_added(str, int): Emitted when row is added (table_id, row_index)
        row_removed(str, int): Emitted when row is removed (table_id, row_index)
        selection_changed(str, list): Emitted when row selection changes (table_id, selected_indices)
        visibility_changed(str, bool): Emitted when visibility changes (table_id, is_visible)
        sorted(str, str, bool): Emitted when data is sorted (table_id, column, ascending)
        filtered(str, str): Emitted when data is filtered (table_id, filter_condition)
    """

    data_changed = Signal(str)  # table_id
    row_added = Signal(str, int)  # table_id, row_index
    row_removed = Signal(str, int)  # table_id, row_index
    selection_changed = Signal(str, list)  # table_id, selected_indices
    visibility_changed = Signal(str, bool)  # table_id, is_visible
    sorted = Signal(str, str, bool)  # table_id, column, ascending
    filtered = Signal(str, str)  # table_id, filter_condition

    def __init__(
        self,
        result_id: str,
        name: str,
        data: Optional[pd.DataFrame] = None,
        id: Optional[str] = None
    ):
        BaseModel.__init__(self, id)
        QObject.__init__(self)
        
        self.result_id = result_id
        self.name = name
        self._data = data if data is not None else pd.DataFrame()
        self._visible = True
        self._selected_rows: List[int] = []

        logger.debug(f"Created DataTable '{self.name}' with ID: {self.id}")

    @property
    def data(self) -> pd.DataFrame:
        return self._data

    def set_data(self, data: pd.DataFrame):
        """Set the entire DataFrame."""
        self._data = data
        logger.debug(f"DataTable ID={self.id}: Set new data with shape {data.shape}")
        self.data_changed.emit(self.id)

    def add_row(self, row: Dict[str, Any]):
        """Add a new row to the DataFrame."""
        index = len(self._data)
        self._data = pd.concat([self._data, pd.DataFrame([row])], ignore_index=True)
        logger.debug(f"DataTable ID={self.id}: Added row at index {index}")
        self.row_added.emit(self.id, index)

    def remove_row(self, index: int):
        """Remove a row by index."""
        if index in self._data.index:
            self._data = self._data.drop(index).reset_index(drop=True)
            logger.debug(f"DataTable ID={self.id}: Removed row at index {index}")
            self.row_removed.emit(self.id, index)

    @property
    def visible(self) -> bool:
        return self._visible

    @visible.setter
    def visible(self, value: bool):
        if self._visible != value:
            self._visible = value
            logger.debug(f"DataTable ID={self.id}: Visibility set to {value}")
            self.visibility_changed.emit(self.id, value)

    def select_rows(self, indices: List[int]):
        """Select multiple rows by their indices."""
        self._selected_rows = indices
        logger.debug(f"DataTable ID={self.id}: Selected rows {indices}")
        self.selection_changed.emit(self.id, indices)

    def sort_by(self, column: str, ascending: bool = True):
        """Sort the DataFrame by a column."""
        if column in self._data.columns:
            self._data = self._data.sort_values(by=column, ascending=ascending)
            logger.debug(f"DataTable ID={self.id}: Sorted by '{column}' ({ascending=})")
            self.sorted.emit(self.id, column, ascending)

    def filter_by(self, condition: str):
        """Filter the DataFrame using a query string."""
        try:
            self._data = self._data.query(condition)
            logger.debug(f"DataTable ID={self.id}: Filtered with condition '{condition}'")
            self.filtered.emit(self.id, condition)
        except Exception as e:
            logger.error(f"DataTable ID={self.id}: Filter error: {e}")

    def to_dict(self) -> Dict[str, Any]:
        """Serialize to dictionary."""
        return {
            "id": self.id,
            "result_id": self.result_id,
            "name": self.name,
            "data": self._data.to_dict(orient='records'),
            "visible": self._visible,
            "selected_rows": self._selected_rows
        }

    @staticmethod
    def from_dict(data: Dict[str, Any]) -> 'DataTable':
        """Create from dictionary."""
        table = DataTable(
            result_id=data["result_id"],
            name=data["name"],
            data=pd.DataFrame(data.get("data", [])),
            id=data.get("id")
        )
        table.visible = data.get("visible", True)
        table._selected_rows = data.get("selected_rows", [])
        return table


================================================================================
*** dut.py ***
### src/pymetr/models/dut.py ###
================================================================================

# app/models/device_models.py

from typing import Dict, Optional, Any, List
from pathlib import Path
import logging

from .instrument import Instrument, ConnectionState
logger = logging.getLogger(__name__)
    
class DUT(Instrument):
    """Device Under Test - extends Instrument with test-specific attributes."""
    
    def __init__(self,
                 manufacturer: Optional[str] = None,
                 model: Optional[str] = None,
                 serial_number: Optional[str] = None,
                 firmware: Optional[str] = None,
                 resource: Optional[str] = None,
                 data_directory: Optional[Path] = None,
                 id: Optional[str] = None):
        
        super().__init__(
            manufacturer=manufacturer,
            model=model,
            serial_number=serial_number,
            firmware=firmware,
            resource=resource,
            id=id
        )
        self._data_directory = data_directory
        self._configuration: Dict[str, Any] = {}

        logger.info(f"Created DUT with ID: {self.id}")

    @property
    def data_directory(self) -> Optional[Path]:
        return self._data_directory

    @data_directory.setter
    def data_directory(self, value: Optional[Path]):
        old_value = self._data_directory
        self._data_directory = value
        self.notify_change("data_directory_changed", {
            "dut_id": self.id,
            "old_value": str(old_value) if old_value else None,
            "new_value": str(value) if value else None
        })

    @property
    def configuration(self) -> Dict[str, Any]:
        return self._configuration.copy()

    def set_config_value(self, key: str, value: Any):
        """Update a single configuration value."""
        old_value = self._configuration.get(key)
        self._configuration[key] = value
        self.notify_change("configuration_changed", {
            "dut_id": self.id,
            "key": key,
            "old_value": old_value,
            "new_value": value
        })

    def update_configuration(self, updates: Dict[str, Any]):
        """Update multiple configuration values at once."""
        old_values = {}
        for key, value in updates.items():
            old_values[key] = self._configuration.get(key)
            self._configuration[key] = value

        self.notify_change("configuration_bulk_changed", {
            "dut_id": self.id,
            "old_values": old_values,
            "new_values": updates
        })

    def to_dict(self) -> Dict[str, Any]:
        """Convert DUT state to a dictionary, including base Instrument fields."""
        data = super().to_dict()
        data.update({
            'data_directory': str(self.data_directory) if self.data_directory else None,
            'configuration': self.configuration
        })
        return data

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'DUT':
        """Create a new DUT instance from a dictionary."""
        dut = cls(
            manufacturer=data.get('manufacturer'),
            model=data.get('model'),
            serial_number=data.get('serial_number'),
            firmware=data.get('firmware'),
            resource=data.get('resource'),
            data_directory=Path(data['data_directory']) if data.get('data_directory') else None,
            id=data.get('id')
        )
        if data.get('connection_state'):
            dut._connection_state = ConnectionState(data['connection_state'])
        dut._error_message = data.get('error_message')
        dut._driver_info = data.get('driver_info', {}).copy()
        dut._parameters = data.get('parameters', {}).copy()
        dut._configuration = data.get('configuration', {}).copy()
        return dut


================================================================================
*** instrument.py ***
### src/pymetr/models/instrument.py ###
================================================================================

# app/models/device_models.py

from typing import Dict, Optional, Any, List
from pathlib import Path
from enum import Enum
from .base import BaseModel
from ..logging import logger

class ConnectionState(Enum):
    """Possible states for an instrument connection."""
    DISCONNECTED = "disconnected"
    CONNECTING = "connecting"
    CONNECTED = "connected"
    ERROR = "error"

class Instrument(BaseModel):
    """Base class for all instruments including DUTs."""
    
    def __init__(self, 
                 manufacturer: Optional[str] = None,
                 model: Optional[str] = None,
                 serial_number: Optional[str] = None,
                 firmware: Optional[str] = None,
                 resource: Optional[str] = None,
                 id: Optional[str] = None):
        super().__init__(id)
        self._manufacturer = manufacturer
        self._model = model
        self._serial_number = serial_number
        self._firmware = firmware
        self._resource = resource
        self._connection_state = ConnectionState.DISCONNECTED
        self._error_message: Optional[str] = None
        self._driver_info: Dict[str, Any] = {}
        self._parameters: Dict[str, Any] = {}

        logger.info(f"Created Instrument with ID: {self.id}")

    @property
    def manufacturer(self) -> Optional[str]:
        return self._manufacturer

    @manufacturer.setter
    def manufacturer(self, value: Optional[str]):
        old_value = self._manufacturer
        self._manufacturer = value
        self.notify_change("manufacturer_changed", {
            "instrument_id": self.id,
            "old_value": old_value,
            "new_value": value
        })

    @property
    def model(self) -> Optional[str]:
        return self._model

    @model.setter
    def model(self, value: Optional[str]):
        old_value = self._model
        self._model = value
        self.notify_change("model_changed", {
            "instrument_id": self.id,
            "old_value": old_value,
            "new_value": value
        })

    @property
    def serial_number(self) -> Optional[str]:
        return self._serial_number

    @serial_number.setter
    def serial_number(self, value: Optional[str]):
        old_value = self._serial_number
        self._serial_number = value
        self.notify_change("serial_number_changed", {
            "instrument_id": self.id,
            "old_value": old_value,
            "new_value": value
        })

    @property
    def firmware(self) -> Optional[str]:
        return self._firmware

    @firmware.setter 
    def firmware(self, value: Optional[str]):
        old_value = self._firmware
        self._firmware = value
        self.notify_change("firmware_changed", {
            "instrument_id": self.id,
            "old_value": old_value,
            "new_value": value
        })

    @property
    def resource(self) -> Optional[str]:
        return self._resource

    @resource.setter
    def resource(self, value: Optional[str]):
        old_value = self._resource
        self._resource = value
        self.notify_change("resource_changed", {
            "instrument_id": self.id,
            "old_value": old_value,
            "new_value": value
        })

    @property
    def connection_state(self) -> ConnectionState:
        return self._connection_state

    @connection_state.setter
    def connection_state(self, value: ConnectionState):
        old_value = self._connection_state
        self._connection_state = value
        self.notify_change("connection_state_changed", {
            "instrument_id": self.id,
            "old_value": old_value.value,
            "new_value": value.value
        })

    @property
    def error_message(self) -> Optional[str]:
        return self._error_message

    @error_message.setter
    def error_message(self, value: Optional[str]):
        old_value = self._error_message
        self._error_message = value
        self.notify_change("error_message_changed", {
            "instrument_id": self.id,
            "old_value": old_value,
            "new_value": value
        })

    @property
    def driver_info(self) -> Dict[str, Any]:
        return self._driver_info.copy()

    def set_driver_info(self, info: Dict[str, Any]):
        """Update driver information."""
        old_info = self._driver_info.copy()
        self._driver_info = info.copy()
        self.notify_change("driver_info_changed", {
            "instrument_id": self.id,
            "old_value": old_info,
            "new_value": self._driver_info
        })

    @property
    def parameters(self) -> Dict[str, Any]:
        return self._parameters.copy()

    def update_parameter(self, path: str, value: Any):
        """Update a single parameter value."""
        parts = path.split('.')
        current = self._parameters
        for part in parts[:-1]:
            if part not in current:
                current[part] = {}
            current = current[part]
            
        old_value = current.get(parts[-1])
        current[parts[-1]] = value
        
        self.notify_change("parameter_changed", {
            "instrument_id": self.id,
            "path": path,
            "old_value": old_value,
            "new_value": value
        })

    def set_parameters(self, parameters: Dict[str, Any]):
        """Set the complete parameter tree."""
        old_params = self._parameters.copy()
        self._parameters = parameters.copy()
        self.notify_change("parameters_changed", {
            "instrument_id": self.id,
            "old_value": old_params,
            "new_value": self._parameters
        })

    def to_dict(self) -> Dict[str, Any]:
        """Convert instrument state to a dictionary for serialization."""
        return {
            'id': self.id,
            'manufacturer': self.manufacturer,
            'model': self.model,
            'serial_number': self.serial_number,
            'firmware': self.firmware,
            'resource': self.resource,
            'connection_state': self.connection_state.value,
            'error_message': self.error_message,
            'driver_info': self.driver_info,
            'parameters': self.parameters
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Instrument':
        """Create a new instrument instance from a dictionary."""
        inst = cls(
            manufacturer=data.get('manufacturer'),
            model=data.get('model'),
            serial_number=data.get('serial_number'),
            firmware=data.get('firmware'),
            resource=data.get('resource'),
            id=data.get('id')
        )
        if data.get('connection_state'):
            inst._connection_state = ConnectionState(data['connection_state'])
        inst._error_message = data.get('error_message')
        inst._driver_info = data.get('driver_info', {}).copy()
        inst._parameters = data.get('parameters', {}).copy()
        return inst


================================================================================
*** marker.py ***
### src/pymetr/models/marker.py ###
================================================================================

# app/models/marker.py

from typing import Dict, Any, Optional
from PySide6.QtCore import QObject, Signal
import logging
from .base import BaseModel

logger = logging.getLogger(__name__)

class Marker(BaseModel, QObject):
    """
    A vertical marker line with label.
    
    Signals:
        position_changed(str, float): Emitted when position changes (marker_id, new_position)
        style_changed(str, str, Any): Emitted when style property changes (marker_id, property_name, value)
        visibility_changed(str, bool): Emitted when visibility changes (marker_id, is_visible)
    """
    
    position_changed = Signal(str, float)  # marker_id, new_position
    style_changed = Signal(str, str, Any)  # marker_id, property_name, value
    visibility_changed = Signal(str, bool)  # marker_id, is_visible

    def __init__(
        self,
        plot_id: str,
        label: str,
        position: float = 0.0,
        color: str = "#FF0000",
        visible: bool = True,
        id: Optional[str] = None
    ):
        BaseModel.__init__(self, id)
        QObject.__init__(self)
        
        self.plot_id = plot_id
        self.label = label
        self._position = position
        self._color = color
        self._visible = visible

        logger.debug(f"Created Marker '{self.label}' with ID: {self.id}")

    @property
    def position(self) -> float:
        return self._position

    @position.setter
    def position(self, value: float):
        old_position = self._position
        self._position = value
        logger.debug(f"Marker ID={self.id}: Position changed from {old_position} to {value}.")
        self.position_changed.emit(self.id, value)

    @property
    def color(self) -> str:
        return self._color

    @color.setter
    def color(self, value: str):
        old_color = self._color
        self._color = value
        logger.debug(f"Marker ID={self.id}: Color changed from {old_color} to {value}.")
        self.style_changed.emit(self.id, "color", value)

    @property
    def visible(self) -> bool:
        return self._visible

    @visible.setter
    def visible(self, value: bool):
        old_visibility = self._visible
        self._visible = value
        logger.debug(f"Marker ID={self.id}: Visibility changed from {old_visibility} to {value}.")
        self.visibility_changed.emit(self.id, value)

    def to_dict(self) -> Dict[str, Any]:
        """Serialize the Marker to a dictionary."""
        return {
            "id": self.id,
            "plot_id": self.plot_id,
            "label": self.label,
            "position": self.position,
            "color": self.color,
            "visible": self.visible
        }

    @staticmethod
    def from_dict(data: Dict[str, Any]) -> 'Marker':
        """Deserialize a Marker from a dictionary."""
        marker = Marker(
            plot_id=data["plot_id"],
            label=data["label"],
            position=data.get("position", 0.0),
            color=data.get("color", "#FF0000"),
            visible=data.get("visible", True),
            id=data.get("id")
        )
        logger.debug(f"Marker.from_dict: Deserialized Marker ID={marker.id}")
        return marker


================================================================================
*** measurement.py ***
### src/pymetr/models/measurement.py ###
================================================================================

# app/models/measurement.py

from typing import Optional
from .base import BaseModel
from ..logging import logger

class Measurement(BaseModel):
    """A calculated measurement result."""
    
    def __init__(self, test_id: str, label: str, value: float,
                 units: str = "", id: Optional[str] = None):
        super().__init__(id)
        self.test_id = test_id
        self.label = label
        self._value = value
        self._units = units
        self._position: Optional[float] = None
        self._color: str = "#00FF00"
        self._visible: bool = True
        self._pass_fail: Optional[bool] = None
    
    @property
    def value(self) -> float:
        return self._value
    
    @value.setter
    def value(self, new_value: float):
        old_value = self._value
        self._value = new_value
        self.notify_change("value", {
            "measurement_id": self.id,
            "old": old_value,
            "new": new_value,
            "label": self.label
        })
    
    @property
    def pass_fail(self) -> Optional[bool]:
        return self._pass_fail
    
    @pass_fail.setter
    def pass_fail(self, value: Optional[bool]):
        old_value = self._pass_fail
        self._pass_fail = value
        self.notify_change("pass_fail", {
            "measurement_id": self.id,
            "old": old_value,
            "new": value,
            "label": self.label
        })
    
    @property
    def position(self) -> Optional[float]:
        return self._position
    
    @position.setter
    def position(self, value: Optional[float]):
        self._position = value
        self.notify_change("position", {
            "measurement_id": self.id,
            "value": value,
            "label": self.label
        })
    
    @property
    def visible(self) -> bool:
        return self._visible
    
    @visible.setter
    def visible(self, value: bool):
        self._visible = value
        self.notify_change("visibility", {
            "measurement_id": self.id,
            "visible": value,
            "label": self.label
        })


================================================================================
*** plot.py ***
### src/pymetr/models/plot.py ###
================================================================================

# app/models/plot.py

from typing import Dict, List, Optional, Any
import numpy as np
from PySide6.QtCore import QObject, Signal, QTimer

from ..logging import logger
from .base import BaseModel
from .trace import Trace
from .marker import Marker
from .cursor import Cursor



class Plot(BaseModel, QObject):
    """
    Complete plot state including style, traces, markers, etc.
    
    Signals:
        trace_added(str, str): Emitted when a trace is added (plot_id, trace_id)
        trace_removed(str, str): Emitted when a trace is removed (plot_id, trace_id)
        marker_added(str, str): Emitted when a marker is added (plot_id, marker_id)
        marker_removed(str, str): Emitted when a marker is removed (plot_id, marker_id)
        cursor_added(str, str): Emitted when a cursor is added (plot_id, cursor_id)
        cursor_removed(str, str): Emitted when a cursor is removed (plot_id, cursor_id)
        limits_changed(str): Emitted when plot limits change (plot_id)
        style_changed(str, str, Any): Emitted when style property changes (plot_id, property_name, value)
        roi_changed(str, list): Emitted when ROI changes (plot_id, [start, end])
    """

    # Define signals
    trace_added = Signal(str, str)  # plot_id, trace_id
    trace_removed = Signal(str, str)  # plot_id, trace_id
    marker_added = Signal(str, str)  # plot_id, marker_id
    marker_removed = Signal(str, str)  # plot_id, marker_id
    cursor_added = Signal(str, str)  # plot_id, cursor_id
    cursor_removed = Signal(str, str)  # plot_id, cursor_id
    limits_changed = Signal(str)  # plot_id
    style_changed = Signal(str, str, Any)  # plot_id, property_name, value
    roi_changed = Signal(str, list)  # plot_id, [start, end]

    def __init__(self, name: str, id: Optional[str] = None):
        BaseModel.__init__(self, id)
        QObject.__init__(self)
        
        self.name = name
        self.traces: Dict[str, Trace] = {}
        self.markers: Dict[str, Marker] = {}
        self.cursors: Dict[str, Cursor] = {}
        
        # Plot properties
        self._auto_scale = True
        self._roi_visible = True
        self._roi = [0.0, 10.0]
        self._x_label = ""
        self._y_label = ""
        self._title = ""
        self._x_lim = [-1.0, 1.0]
        self._y_lim = [-1.0, 1.0]
        self._grid = True
        self._background_color = "#FFFFFF"

        # Debounce timer for limit updates
        self._limits_timer = QTimer()
        self._limits_timer.setInterval(200)  # 200ms debounce
        self._limits_timer.setSingleShot(True)
        self._limits_timer.timeout.connect(self._emit_limits_changed)
        self._limits_changed = False

        logger.debug(f"Created Plot '{self.name}' with ID: {self.id}")

    def _connect_trace_signals(self, trace: Trace):
        """Connect signals from a trace."""
        trace.data_changed.connect(lambda t_id: self._handle_trace_data_changed(t_id))
        trace.style_changed.connect(lambda t_id, prop, val: self._handle_trace_style_changed(t_id, prop, val))
        trace.visibility_changed.connect(lambda t_id, vis: self._handle_trace_visibility_changed(t_id, vis))
        trace.mode_changed.connect(lambda t_id, mode: self._handle_trace_mode_changed(t_id, mode))

    def _connect_marker_signals(self, marker: Marker):
        """Connect signals from a marker."""
        marker.position_changed.connect(lambda m_id, pos: self._handle_marker_position_changed(m_id, pos))
        marker.style_changed.connect(lambda m_id, prop, val: self._handle_marker_style_changed(m_id, prop, val))
        marker.visibility_changed.connect(lambda m_id, vis: self._handle_marker_visibility_changed(m_id, vis))

    def _connect_cursor_signals(self, cursor: Cursor):
        """Connect signals from a cursor."""
        cursor.position_changed.connect(lambda c_id, pos: self._handle_cursor_position_changed(c_id, pos))
        cursor.style_changed.connect(lambda c_id, prop, val: self._handle_cursor_style_changed(c_id, prop, val))
        cursor.visibility_changed.connect(lambda c_id, vis: self._handle_cursor_visibility_changed(c_id, vis))

    # Signal handlers
    def _handle_trace_data_changed(self, trace_id: str):
        """Handle trace data changes."""
        if self._auto_scale:
            self.update_from_data()

    def _handle_trace_style_changed(self, trace_id: str, prop: str, value: Any):
        """Handle trace style changes."""
        self.style_changed.emit(self.id, f"trace_{trace_id}_{prop}", value)

    def _handle_trace_visibility_changed(self, trace_id: str, visible: bool):
        """Handle trace visibility changes."""
        if self._auto_scale and not visible:
            self.update_from_data()

    def _handle_trace_mode_changed(self, trace_id: str, mode: str):
        """Handle trace mode changes."""
        self.style_changed.emit(self.id, f"trace_{trace_id}_mode", mode)

    def _handle_marker_position_changed(self, marker_id: str, position: float):
        """Handle marker position changes."""
        self.style_changed.emit(self.id, f"marker_{marker_id}_position", position)

    def _handle_marker_style_changed(self, marker_id: str, prop: str, value: Any):
        """Handle marker style changes."""
        self.style_changed.emit(self.id, f"marker_{marker_id}_{prop}", value)

    def _handle_marker_visibility_changed(self, marker_id: str, visible: bool):
        """Handle marker visibility changes."""
        self.style_changed.emit(self.id, f"marker_{marker_id}_visible", visible)

    def _handle_cursor_position_changed(self, cursor_id: str, position: float):
        """Handle cursor position changes."""
        self.style_changed.emit(self.id, f"cursor_{cursor_id}_position", position)

    def _handle_cursor_style_changed(self, cursor_id: str, prop: str, value: Any):
        """Handle cursor style changes."""
        self.style_changed.emit(self.id, f"cursor_{cursor_id}_{prop}", value)

    def _handle_cursor_visibility_changed(self, cursor_id: str, visible: bool):
        """Handle cursor visibility changes."""
        self.style_changed.emit(self.id, f"cursor_{cursor_id}_visible", visible)

    # Trace Management
    def add_trace(self, trace: Trace):
        """Add a new trace to the plot."""
        self.traces[trace.id] = trace
        self._connect_trace_signals(trace)
        logger.debug(f"Plot ID={self.id}: Added Trace ID={trace.id}")
        self.trace_added.emit(self.id, trace.id)
        if self._auto_scale:
            self.update_from_data()

    def remove_trace(self, trace_id: str):
        """Remove a trace from the plot."""
        if trace_id in self.traces:
            trace = self.traces.pop(trace_id)
            logger.debug(f"Plot ID={self.id}: Removed Trace ID={trace_id}")
            self.trace_removed.emit(self.id, trace_id)
            if self._auto_scale:
                self.update_from_data()

    def clear_traces(self):
        """Remove all traces from the plot."""
        trace_ids = list(self.traces.keys())
        self.traces.clear()
        for trace_id in trace_ids:
            self.trace_removed.emit(self.id, trace_id)
        logger.debug(f"Plot ID={self.id}: Cleared all traces")
        if self._auto_scale:
            self.update_from_data()

    def get_trace_by_name(self, name: str) -> Optional[Trace]:
        """Find a trace by its name rather than ID."""
        for trace in self.traces.values():
            if trace.name == name:
                return trace
        return None

    def set_trace(self, name: str, x_data=None, y_data=None, **style_kwargs) -> Trace:
        """Add or update a trace in the plot."""
        trace = self.get_trace_by_name(name)
        
        if trace is None:
            # Create new trace
            trace = Trace(
                plot_id=self.id,
                name=name,
                x_data=x_data,
                y_data=y_data,
                **style_kwargs
            )
            self.add_trace(trace)
        else:
            # Update existing trace
            if x_data is not None and y_data is not None:
                trace.set_data(x_data, y_data)
            for key, value in style_kwargs.items():
                if hasattr(trace, key):
                    setattr(trace, key, value)
        
        return trace

    # Marker Management
    def add_marker(self, marker: Marker):
        """Add a new marker to the plot."""
        self.markers[marker.id] = marker
        self._connect_marker_signals(marker)
        logger.debug(f"Plot ID={self.id}: Added Marker ID={marker.id}")
        self.marker_added.emit(self.id, marker.id)

    def remove_marker(self, marker_id: str):
        """Remove a marker from the plot."""
        if marker_id in self.markers:
            marker = self.markers.pop(marker_id)
            logger.debug(f"Plot ID={self.id}: Removed Marker ID={marker_id}")
            self.marker_removed.emit(self.id, marker_id)

    # Cursor Management
    def add_cursor(self, cursor: Cursor):
        """Add a new cursor to the plot."""
        self.cursors[cursor.id] = cursor
        self._connect_cursor_signals(cursor)
        logger.debug(f"Plot ID={self.id}: Added Cursor ID={cursor.id}")
        self.cursor_added.emit(self.id, cursor.id)

    def remove_cursor(self, cursor_id: str):
        """Remove a cursor from the plot."""
        if cursor_id in self.cursors:
            cursor = self.cursors.pop(cursor_id)
            logger.debug(f"Plot ID={self.id}: Removed Cursor ID={cursor_id}")
            self.cursor_removed.emit(self.id, cursor_id)

    # Plot Properties
    @property
    def x_label(self) -> str:
        return self._x_label

    @x_label.setter
    def x_label(self, value: str):
        self._x_label = value
        self.style_changed.emit(self.id, "x_label", value)

    @property
    def y_label(self) -> str:
        return self._y_label

    @y_label.setter
    def y_label(self, value: str):
        self._y_label = value
        self.style_changed.emit(self.id, "y_label", value)

    @property
    def title(self) -> str:
        return self._title

    @title.setter
    def title(self, value: str):
        self._title = value
        self.style_changed.emit(self.id, "title", value)

    @property
    def grid(self) -> bool:
        return self._grid

    @grid.setter
    def grid(self, value: bool):
        self._grid = value
        self.style_changed.emit(self.id, "grid", value)

    @property
    def background_color(self) -> str:
        return self._background_color

    @background_color.setter
    def background_color(self, value: str):
        self._background_color = value
        self.style_changed.emit(self.id, "background_color", value)

    @property
    def roi(self) -> List[float]:
        return self._roi

    @roi.setter
    def roi(self, value: List[float]):
        if not isinstance(value, list) or len(value) != 2:
            logger.error("ROI must be a list of two float values.")
            return
        self._roi = value
        self.roi_changed.emit(self.id, value)

    @property
    def roi_visible(self) -> bool:
        return self._roi_visible

    @roi_visible.setter
    def roi_visible(self, value: bool):
        self._roi_visible = value
        self.style_changed.emit(self.id, "roi_visible", value)

    @property
    def x_lim(self) -> List[float]:
        return self._x_lim

    @x_lim.setter
    def x_lim(self, value: List[float]):
        if not isinstance(value, list) or len(value) != 2:
            logger.error("x_lim must be a list of two float values.")
            return
        self._x_lim = value
        self._emit_limits_changed()

    @property
    def y_lim(self) -> List[float]:
        return self._y_lim

    @y_lim.setter
    def y_lim(self, value: List[float]):
        if not isinstance(value, list) or len(value) != 2:
            logger.error("y_lim must be a list of two float values.")
            return
        self._y_lim = value
        self._emit_limits_changed()

    def update_from_data(self):
        """Update plot limits from trace data."""
        if self._auto_scale:
            x_min = float('inf')
            x_max = float('-inf')
            y_min = float('inf')
            y_max = float('-inf')

            for trace in self.traces.values():
                if not trace.visible:
                    continue
                if len(trace.x_data) > 0:
                    x_min = min(x_min, np.min(trace.x_data))
                    x_max = max(x_max, np.max(trace.x_data))
                if len(trace.y_data) > 0:
                    y_min = min(y_min, np.min(trace.y_data))
                    y_max = max(y_max, np.max(trace.y_data))

            if x_min != float('inf'):
                padding = (x_max - x_min) * 0.05  # 5% padding
                self.x_lim = [x_min - padding, x_max + padding]

            if y_min != float('inf'):
                padding = (y_max - y_min) * 0.05  # 5% padding
                self.y_lim = [y_min - padding, y_max + padding]

    def _emit_limits_changed(self):
        """Emit limits changed signal."""
        if self._limits_changed:
            self._limits_changed = False
            self.limits_changed.emit(self.id)

# Serialization
    def to_dict(self) -> Dict[str, Any]:
        """Serialize the Plot to a dictionary."""
        return {
            "id": self.id,
            "name": self.name,
            "traces": {tid: trace.to_dict() for tid, trace in self.traces.items()},
            "markers": {mid: marker.to_dict() for mid, marker in self.markers.items()},
            "cursors": {cid: cursor.to_dict() for cid, cursor in self.cursors.items()},
            "auto_scale": self._auto_scale,
            "roi": self._roi,
            "roi_visible": self._roi_visible,
            "x_label": self._x_label,
            "y_label": self._y_label,
            "title": self._title,
            "x_lim": self._x_lim,
            "y_lim": self._y_lim,
            "grid": self._grid,
            "background_color": self._background_color
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'Plot':
        """Create a new Plot instance from a dictionary."""
        plot = cls(
            name=data.get('name', 'Unnamed Plot'),
            id=data.get('id')
        )
        
        # Recreate child objects
        for tid, t_data in data.get('traces', {}).items():
            trace = Trace.from_dict(t_data)
            plot.add_trace(trace)
            
        for mid, m_data in data.get('markers', {}).items():
            marker = Marker.from_dict(m_data)
            plot.add_marker(marker)
            
        for cid, c_data in data.get('cursors', {}).items():
            cursor = Cursor.from_dict(c_data)
            plot.add_cursor(cursor)

        # Set properties
        plot._auto_scale = data.get('auto_scale', True)
        plot._roi = data.get('roi', [0.0, 10.0])
        plot._roi_visible = data.get('roi_visible', True)
        plot._x_label = data.get('x_label', '')
        plot._y_label = data.get('y_label', '')
        plot._title = data.get('title', '')
        plot._x_lim = data.get('x_lim', [-1.0, 1.0])
        plot._y_lim = data.get('y_lim', [-1.0, 1.0])
        plot._grid = data.get('grid', True)
        plot._background_color = data.get('background_color', "#FFFFFF")

        logger.debug(f"Plot.from_dict: Deserialized Plot ID={plot.id}")
        return plot


================================================================================
*** test_result.py ***
### src/pymetr/models/test_result.py ###
================================================================================

# app/models/test_result.py

from pathlib import Path
from typing import Dict, List, Optional, Any
import pandas as pd
from PySide6.QtCore import QObject, Signal, QTimer
from datetime import datetime

from ..logging import logger
from .base import BaseModel
from .plot import Plot
from .trace import Trace


class TestResult(BaseModel, QObject):
    """
    A test execution result with optional plot and data.
    
    Signals:
        data_updated(str): Emitted when DataFrame data changes (result_id)
        headers_changed(str, list): Emitted when DataFrame headers change (result_id, columns)
        status_changed(str, str): Emitted when status changes (result_id, new_status)
        plot_updated(str): Emitted when plot changes (result_id)
        measurements_changed(str): Emitted when measurements change (result_id)
        error_changed(str, dict): Emitted when error info changes (result_id, error_info)
        log_added(str, dict): Emitted when a log entry is added (result_id, log_entry)
    """

    VALID_STATUSES = {
        "Not Run",
        "Running",
        "Pass",
        "Fail",
        "Error",
        "Aborted",
        "Complete"
    }

    # Define signals
    data_updated = Signal(str)  # result_id
    headers_changed = Signal(str, list)  # result_id, columns
    status_changed = Signal(str, str)  # result_id, new_status
    plot_updated = Signal(str)  # result_id
    measurements_changed = Signal(str)  # result_id
    error_changed = Signal(str, dict)  # result_id, error_info
    log_added = Signal(str, dict)  # result_id, log_entry

    def __init__(self, name: str, id: Optional[str] = None):
        BaseModel.__init__(self, id)
        QObject.__init__(self)
        
        logger.debug(f"TestResult.__init__: Creating result '{name}' with ID={self.id}")
        self.name = name
        self._status = "Not Run"
        self.plot = None
        self._data = pd.DataFrame()
        self.measurements: Dict[str, Any] = {}
        self.error: Optional[Dict[str, str]] = None
        self.logs: List[Dict[str, str]] = []

        # Debounce timer for data updates
        self._update_timer = QTimer()
        self._update_timer.setInterval(200)  # 200ms debounce
        self._update_timer.setSingleShot(True)
        self._update_timer.timeout.connect(self._emit_data_update)
        self._data_changed = False

        logger.debug(f"TestResult.__init__: Initialization complete for ID={self.id}")

    @property
    def status(self) -> str:
        return self._status

    @status.setter
    def status(self, value: str):
        if value not in self.VALID_STATUSES:
            logger.warning(f"Invalid status '{value}' for TestResult ID={self.id}. Defaulting to 'Not Run'.")
            value = "Not Run"

        if value != self._status:
            old_status = self._status
            self._status = value
            logger.debug(f"TestResult ID={self.id}: Status changed from '{old_status}' to '{value}'")
            self.status_changed.emit(self.id, value)

    @property
    def data(self) -> pd.DataFrame:
        """Returns the pandas DataFrame containing test data."""
        return self._data

    def set_data_headers(self, *columns):
        """Set or update DataFrame headers."""
        old_columns = list(self._data.columns)
        
        if len(old_columns) > 0:
            # Preserve existing data when updating headers
            self._data.columns = columns
        else:
            # Create new DataFrame with headers
            self._data = pd.DataFrame(columns=columns)
            
        logger.debug(f"TestResult ID={self.id}: Headers updated from {old_columns} to {list(columns)}")
        self.headers_changed.emit(self.id, list(columns))

    def set_data_row(self, idx: Optional[int], *values):
        """Set data row with automatic header creation if needed."""
        # Create default headers if needed
        if len(self._data.columns) == 0:
            default_headers = [f"Column_{i}" for i in range(len(values))]
            self._data = pd.DataFrame(columns=default_headers)
            logger.debug(f"TestResult ID={self.id}: Created default headers {default_headers}")
            self.headers_changed.emit(self.id, default_headers)

        # Handle value count mismatch
        if len(values) != len(self._data.columns):
            values = list(values)[:len(self._data.columns)]
            values.extend([None] * (len(self._data.columns) - len(values)))

        # Set the data
        actual_idx = idx if idx is not None else len(self._data)
        try:
            self._data.loc[actual_idx] = values
            self._data_changed = True
            
            # Start/restart debounce timer
            if not self._update_timer.isActive():
                self._update_timer.start()
                
            logger.debug(f"TestResult ID={self.id}: Set row {actual_idx}")
            return True
            
        except Exception as e:
            logger.error(f"TestResult ID={self.id}: Error setting data row: {e}")
            return False

    def _emit_data_update(self):
        """Emit data update signal if data has changed."""
        if self._data_changed:
            self._data_changed = False
            self.data_updated.emit(self.id)

    def set_trace(self, name: str, x_data=None, y_data=None, **style_kwargs) -> Trace:
        """Add or update a trace in the plot."""
        if not self.plot:
            self.plot = Plot(name=f"{self.name} Plot")
            
        trace = self.plot.set_trace(name, x_data, y_data, **style_kwargs)
        self.plot_updated.emit(self.id)
        return trace

    def update_measurements(self, measurements: Dict[str, Any]):
        """Update measurements dictionary."""
        self.measurements.update(measurements)
        self.measurements_changed.emit(self.id)

    def set_error(self, error_info: Dict[str, str]):
        """Set error information."""
        self.error = error_info
        self.error_changed.emit(self.id, error_info)

    def add_log(self, message: str, level: str = "INFO"):
        """Add a log entry with timestamp."""
        entry = {
            "timestamp": datetime.now().isoformat(),
            "message": message,
            "level": level
        }
        self.logs.append(entry)
        self.log_added.emit(self.id, entry)

    def to_dict(self) -> Dict[str, Any]:
        """Serialize to dictionary."""
        return {
            "id": self.id,
            "name": self.name,
            "status": self.status,
            "plot": self.plot.to_dict() if self.plot else None,
            "data": self._data.to_dict(orient='split'),
            "measurements": self.measurements,
            "error": self.error,
            "logs": self.logs
        }

    @staticmethod
    def from_dict(data: Dict[str, Any]) -> 'TestResult':
        """Create from dictionary."""
        result = TestResult(
            name=data["name"],
            id=data.get("id")
        )
        result.status = data.get("status", "Not Run")
        if data.get("plot"):
            result.plot = Plot.from_dict(data["plot"])
        if data.get("data"):
            result._data = pd.DataFrame(**data["data"])
        result.measurements = data.get("measurements", {})
        result.error = data.get("error")
        result.logs = data.get("logs", [])
        return result


================================================================================
*** test_script.py ***
### src/pymetr/models/test_script.py ###
================================================================================

# src/pymetr/models/test_script.py
from pathlib import Path
from typing import Dict, List, Optional, Any
from PySide6.QtCore import QObject, Signal

from ..logging import logger
from .base import BaseModel
from .test_result import TestResult

class TestScript(BaseModel, QObject):
    """
    A test container that can hold multiple results.
    
    Signals:
        progress_changed(str, float, str): Emitted when progress changes (test_id, percent, message)
        status_changed(str, str): Emitted when status changes (test_id, new_status)
        result_added(str, str): Emitted when result is added (test_id, result_id)
        result_removed(str, str): Emitted when result is removed (test_id, result_id)
        metadata_changed(str): Emitted when metadata changes (test_id)
    """

    progress_changed = Signal(str, float, str)  # test_id, percent, message
    status_changed = Signal(str, str)  # test_id, status
    result_added = Signal(str, str)  # test_id, result_id
    result_removed = Signal(str, str)  # test_id, result_id
    metadata_changed = Signal(str)  # test_id

    def __init__(self, name: str, script_path: Optional[Path] = None, id: Optional[str] = None):
        BaseModel.__init__(self, id)
        QObject.__init__(self)
        
        self.name = name
        self.script_path = script_path
        self.results: Dict[str, TestResult] = {}
        self.required_instruments: List[Dict[str, str]] = []
        self.metadata: Dict[str, Any] = {}
        
        self._progress = 0.0
        self._progress_message = ""
        self._status = "Not Run"

        logger.debug(f"TestScript.__init__: Created TestScript '{self.name}' with ID={self.id}")

    # ... rest of TestScript implementation stays the same ...

    @property
    def progress(self) -> float:
        return self._progress

    @progress.setter
    def progress(self, value: float):
        old_progress = self._progress
        self._progress = max(0.0, min(100.0, value))
        logger.debug(f"TestScript ID={self.id}: Progress changed from {old_progress} to {self._progress}")
        self.progress_changed.emit(self.id, self._progress, self._progress_message)

    @property
    def status(self) -> str:
        return self._status

    @status.setter
    def status(self, value: str):
        old_status = self._status
        self._status = value
        logger.debug(f"TestScript ID={self.id}: Status changed from '{old_status}' to '{value}'")
        self.status_changed.emit(self.id, value)

    def add_result(self, result: TestResult):
        """Add a new result to the test."""
        self.results[result.id] = result
        logger.debug(f"TestScript ID={self.id}: Added TestResult ID={result.id}")
        self.result_added.emit(self.id, result.id)
        self.calculate_aggregate_status()

    def remove_result(self, result_id: str):
        """Remove a result by ID."""
        if result_id in self.results:
            del self.results[result_id]
            logger.debug(f"TestScript ID={self.id}: Removed TestResult ID={result_id}")
            self.result_removed.emit(self.id, result_id)
            self.calculate_aggregate_status()

    def update_metadata(self, metadata: Dict[str, Any]):
        """Update metadata dictionary."""
        self.metadata.update(metadata)
        logger.debug(f"TestScript ID={self.id}: Metadata updated")
        self.metadata_changed.emit(self.id)

    def calculate_aggregate_status(self) -> str:
        """Calculate and update the aggregate status based on all results."""
        if not self.results:
            self._status = "Not Run"
            return self._status

        statuses = [result.status for result in self.results.values()]
        logger.debug(f"TestScript ID={self.id}: Calculating aggregate status from {statuses}")

        if any(status == "Error" for status in statuses):
            new_status = "Error"
        elif any(status == "Fail" for status in statuses):
            new_status = "Fail"
        elif all(status == "Pass" for status in statuses):
            new_status = "Pass"
        elif all(status in ("Pass", "Complete") for status in statuses):
            new_status = "Complete"
        else:
            new_status = "Not Run"

        if new_status != self._status:
            self._status = new_status
            self.status_changed.emit(self.id, new_status)

        return self._status

    def to_dict(self) -> Dict[str, Any]:
        """Serialize to dictionary."""
        return {
            "id": self.id,
            "name": self.name,
            "script_path": str(self.script_path) if self.script_path else None,
            "metadata": self.metadata,
            "results": {rid: res.to_dict() for rid, res in self.results.items()},
            "required_instruments": self.required_instruments,
            "progress": self.progress,
            "progress_message": self._progress_message,
            "status": self.status
        }

    @staticmethod
    def from_dict(data: Dict[str, Any]) -> 'TestScript':
        """Create from dictionary."""
        test = TestScript(
            name=data["name"],
            script_path=Path(data["script_path"]) if data.get("script_path") else None,
            id=data.get("id")
        )
        test.metadata = data.get("metadata", {})
        test.required_instruments = data.get("required_instruments", [])
        test._progress = data.get("progress", 0.0)
        test._progress_message = data.get("progress_message", "")
        test._status = data.get("status", "Not Run")
        
        for rid, rdata in data.get("results", {}).items():
            result = TestResult.from_dict(rdata)
            test.add_result(result)
            
        return test


================================================================================
*** test_suite.py ***
### src/pymetr/models/test_suite.py ###
================================================================================

# app/models/test_suite.py

from typing import Dict, Optional, Any
from PySide6.QtCore import QObject, Signal

from ..logging import logger
from .base import BaseModel
from .test_script import TestScript
from .test_result import TestResult


class TestSuite(BaseModel, QObject):
    """
    A container for multiple related tests.
    
    Signals:
        status_changed(str, str): Emitted when status changes (suite_id, new_status)
        test_added(str, str): Emitted when test is added (suite_id, test_id)
        test_removed(str, str): Emitted when test is removed (suite_id, test_id)
        result_added(str, str, str): Emitted when result is added (suite_id, test_id, result_id)
        metadata_changed(str): Emitted when metadata changes (suite_id)
    """

    status_changed = Signal(str, str)  # suite_id, new_status
    test_added = Signal(str, str)  # suite_id, test_id
    test_removed = Signal(str, str)  # suite_id, test_id
    result_added = Signal(str, str, str)  # suite_id, test_id, result_id
    metadata_changed = Signal(str)  # suite_id

    def __init__(self, name: str, id: Optional[str] = None):
        BaseModel.__init__(self, id)
        QObject.__init__(self)
        
        self.name = name
        self.tests: Dict[str, TestScript] = {}
        self.metadata: Dict[str, Any] = {}
        self._status = "Not Run"

        logger.debug(f"TestSuite.__init__: Created TestSuite '{self.name}' with ID={self.id}")

    @property
    def status(self) -> str:
        return self._status

    @status.setter
    def status(self, value: str):
        if value != self._status:
            old_status = self._status
            self._status = value
            logger.debug(f"TestSuite ID={self.id}: Status changed from '{old_status}' to '{value}'")
            self.status_changed.emit(self.id, value)

    def add_test(self, test: TestScript):
        """Add a new test to the suite."""
        self.tests[test.id] = test
        logger.debug(f"TestSuite ID={self.id}: Added TestScript ID={test.id}")
        self.test_added.emit(self.id, test.id)
        self.calculate_aggregate_status()

        # Connect test signals
        test.status_changed.connect(lambda t_id, status: self._handle_test_status_changed(t_id, status))
        test.result_added.connect(lambda t_id, r_id: self._handle_test_result_added(t_id, r_id))

    def remove_test(self, test_id: str):
        """Remove a test from the suite."""
        if test_id in self.tests:
            del self.tests[test_id]
            logger.debug(f"TestSuite ID={self.id}: Removed TestScript ID={test_id}")
            self.test_removed.emit(self.id, test_id)
            self.calculate_aggregate_status()

    def _handle_test_status_changed(self, test_id: str, status: str):
        """Handle status changes from contained tests."""
        logger.debug(f"TestSuite ID={self.id}: Test {test_id} status changed to '{status}'")
        self.calculate_aggregate_status()

    def _handle_test_result_added(self, test_id: str, result_id: str):
        """Handle new results from contained tests."""
        logger.debug(f"TestSuite ID={self.id}: Test {test_id} added result {result_id}")
        self.result_added.emit(self.id, test_id, result_id)

    def update_metadata(self, metadata: Dict[str, Any]):
        """Update metadata dictionary."""
        self.metadata.update(metadata)
        logger.debug(f"TestSuite ID={self.id}: Metadata updated")
        self.metadata_changed.emit(self.id)

    def calculate_aggregate_status(self) -> str:
        """Calculate and update the aggregate status based on all tests."""
        if not self.tests:
            self.status = "Not Run"
            return self.status

        statuses = [test.status for test in self.tests.values()]
        logger.debug(f"TestSuite ID={self.id}: Calculating aggregate status from {statuses}")

        if any(status == "Error" for status in statuses):
            new_status = "Error"
        elif any(status == "Fail" for status in statuses):
            new_status = "Fail"
        elif all(status == "Pass" for status in statuses):
            new_status = "Pass"
        elif all(status in ("Pass", "Complete") for status in statuses):
            new_status = "Complete"
        else:
            new_status = "Not Run"

        self.status = new_status
        return self.status

    def to_dict(self) -> Dict[str, Any]:
        """Serialize to dictionary."""
        return {
            "id": self.id,
            "name": self.name,
            "metadata": self.metadata,
            "tests": {tid: test.to_dict() for tid, test in self.tests.items()},
            "status": self.status
        }

    @staticmethod
    def from_dict(data: Dict[str, Any]) -> 'TestSuite':
        """Create from dictionary."""
        suite = TestSuite(
            name=data["name"],
            id=data.get("id")
        )
        suite.metadata = data.get("metadata", {})
        suite._status = data.get("status", "Not Run")
        
        # Load tests
        for tid, tdata in data.get("tests", {}).items():
            test = TestScript.from_dict(tdata)
            suite.add_test(test)
        
        return suite


================================================================================
*** trace.py ***
### src/pymetr/models/trace.py ###
================================================================================

# app/models/trace.py

from typing import Dict, List, Optional, Any
import numpy as np
from .base import BaseModel
from PySide6.QtCore import QObject, Signal

import logging

logger = logging.getLogger(__name__)

class Trace(BaseModel, QObject):
    """
    A single data trace on a plot.
    
    Signals:
        data_changed(str): Emitted when x_data or y_data changes (trace_id)
        style_changed(str, str, Any): Emitted when any style property changes (trace_id, property_name, value)
        visibility_changed(str, bool): Emitted when visibility changes (trace_id, is_visible)
        mode_changed(str, str): Emitted when mode changes (trace_id, new_mode)
    """
    
    # Define signals
    data_changed = Signal(str)  # trace_id
    style_changed = Signal(str, str, Any)  # trace_id, property_name, new_value
    visibility_changed = Signal(str, bool)  # trace_id, is_visible
    mode_changed = Signal(str, str)  # trace_id, new_mode

    def __init__(
        self,
        plot_id: str,
        name: str,
        x_data: Optional[np.ndarray] = None,
        y_data: Optional[np.ndarray] = None,
        id: Optional[str] = None,
        **style_kwargs
    ):
        BaseModel.__init__(self, id)
        QObject.__init__(self)
        
        self.plot_id = plot_id
        self.name = name
        
        # Data arrays
        self._x_data = self._ensure_numpy_array(x_data) if x_data is not None else np.array([])
        self._y_data = self._ensure_numpy_array(y_data) if y_data is not None else np.array([])

        # Style properties with defaults
        self._color = style_kwargs.get("color", "#000000")
        self._width = style_kwargs.get("width", 1.0)
        self._style = style_kwargs.get("style", "solid")  # solid, dash, dot, dash-dot
        self._opacity = style_kwargs.get("opacity", 1.0)
        self._mode = style_kwargs.get("mode", "Group")  # "Group" or "Isolate"
        self._visible = style_kwargs.get("visible", True)

        logger.debug(f"Created Trace '{self.name}' with ID: {self.id}")

    def _ensure_numpy_array(self, data: Any) -> np.ndarray:
        """Ensure data is a numpy array."""
        if not isinstance(data, np.ndarray):
            return np.array(data)
        return data

    # Data Methods
    def set_data(self, x: np.ndarray, y: np.ndarray):
        """Set both x_data and y_data atomically."""
        if len(x) != len(y):
            logger.error(f"Trace ID={self.id}: x_data length {len(x)} does not match y_data length {len(y)}.")
            raise ValueError("x_data and y_data must be of the same length.")
            
        self._x_data = self._ensure_numpy_array(x)
        self._y_data = self._ensure_numpy_array(y)
        
        logger.debug(f"Trace ID={self.id}: Data set with {len(x)} points each for x and y.")
        self.data_changed.emit(self.id)

    # Property Definitions
    @property
    def x_data(self) -> np.ndarray:
        return self._x_data

    @x_data.setter
    def x_data(self, value: np.ndarray):
        if len(value) != len(self._y_data):
            logger.error(f"Trace ID={self.id}: x_data length {len(value)} does not match y_data length {len(self._y_data)}.")
            raise ValueError("x_data and y_data must be of the same length.")
        self._x_data = self._ensure_numpy_array(value)
        logger.debug(f"Trace ID={self.id}: x_data updated with {len(value)} points.")
        self.data_changed.emit(self.id)

    @property
    def y_data(self) -> np.ndarray:
        return self._y_data

    @y_data.setter
    def y_data(self, value: np.ndarray):
        if len(value) != len(self._x_data):
            logger.error(f"Trace ID={self.id}: y_data length {len(value)} does not match x_data length {len(self._x_data)}.")
            raise ValueError("y_data and x_data must be of the same length.")
        self._y_data = self._ensure_numpy_array(value)
        logger.debug(f"Trace ID={self.id}: y_data updated with {len(value)} points.")
        self.data_changed.emit(self.id)

    @property
    def color(self) -> str:
        return self._color

    @color.setter
    def color(self, value: str):
        self._color = value
        logger.debug(f"Trace ID={self.id}: Color set to {value}.")
        self.style_changed.emit(self.id, "color", value)

    @property
    def width(self) -> float:
        return self._width

    @width.setter
    def width(self, value: float):
        self._width = value
        logger.debug(f"Trace ID={self.id}: Width set to {value}.")
        self.style_changed.emit(self.id, "width", value)

    @property
    def style(self) -> str:
        return self._style

    @style.setter
    def style(self, value: str):
        if value not in {"solid", "dash", "dot", "dash-dot"}:
            logger.warning(f"Trace ID={self.id}: Invalid style '{value}'. Keeping existing style '{self._style}'.")
            return
        self._style = value
        logger.debug(f"Trace ID={self.id}: Style set to {value}.")
        self.style_changed.emit(self.id, "style", value)

    @property
    def opacity(self) -> float:
        return self._opacity

    @opacity.setter
    def opacity(self, value: float):
        self._opacity = value
        logger.debug(f"Trace ID={self.id}: Opacity set to {value}.")
        self.style_changed.emit(self.id, "opacity", value)

    @property
    def mode(self) -> str:
        return self._mode

    @mode.setter
    def mode(self, value: str):
        if value not in {"Group", "Isolate"}:
            logger.warning(f"Trace ID={self.id}: Invalid mode '{value}'. Keeping existing mode '{self._mode}'.")
            return
        old_mode = self._mode
        self._mode = value
        logger.debug(f"Trace ID={self.id}: Mode changed from '{old_mode}' to '{value}'.")
        self.mode_changed.emit(self.id, value)

    @property
    def visible(self) -> bool:
        return self._visible

    @visible.setter
    def visible(self, value: bool):
        self._visible = value
        logger.debug(f"Trace ID={self.id}: Visibility set to {value}.")
        self.visibility_changed.emit(self.id, value)

    # Serialization
    def to_dict(self) -> Dict[str, Any]:
        """Serialize the Trace to a dictionary."""
        return {
            "id": self.id,
            "plot_id": self.plot_id,
            "name": self.name,
            "x_data": self._x_data.tolist(),
            "y_data": self._y_data.tolist(),
            "color": self.color,
            "width": self.width,
            "style": self.style,
            "opacity": self.opacity,
            "mode": self.mode,
            "visible": self.visible
        }

    @staticmethod
    def from_dict(data: Dict[str, Any]) -> 'Trace':
        """Deserialize a Trace from a dictionary."""
        trace = Trace(
            plot_id=data["plot_id"],
            name=data["name"],
            x_data=np.array(data["x_data"]),
            y_data=np.array(data["y_data"]),
            id=data.get("id"),
            color=data.get("color", "#000000"),
            width=data.get("width", 1.0),
            style=data.get("style", "solid"),
            opacity=data.get("opacity", 1.0),
            mode=data.get("mode", "Group"),
            visible=data.get("visible", True)
        )
        logger.debug(f"Trace.from_dict: Deserialized Trace ID={trace.id}")
        return trace


================================================================================
*** __init__.py ***
### src/pymetr/views/__init__.py ###
================================================================================




================================================================================
*** manager.py ***
### src/pymetr/views/manager.py ###
================================================================================

# src/pymetr/views/manager.py
from typing import Dict, Set, Any, Optional, Callable, TYPE_CHECKING
from dataclasses import dataclass, field
from enum import Enum, auto

if TYPE_CHECKING:
    from pymetr.state import ApplicationState
    
class ViewType(Enum):
    """Enumeration of supported view types"""
    HOME = auto()
    TREE = auto()
    SCRIPT = auto()
    PLOT = auto()
    RESULT = auto()
    INSTRUMENT = auto()
    DATA_TABLE = auto()

@dataclass
class ViewState:
    """Tracks state for a specific view instance"""
    view_type: ViewType
    model_id: str
    properties: Dict[str, Any] = field(default_factory=dict)
    is_dirty: bool = False
    is_active: bool = False

class ViewManager:
    """Manages view states and synchronization"""
    def __init__(self, state: 'ApplicationState'):
        self.state = state
        self._views: Dict[str, ViewState] = {}
        self._model_views: Dict[str, Set[str]] = {}  # model_id -> view_ids
        self._active_view: Optional[str] = None
        
        # Connect to state signals
        self.state.signals.connect('model_changed', self._handle_model_change)
        self.state.signals.connect('model_deleted', self._handle_model_delete)
        
    def register_view(self, view_id: str, view_type: ViewType, model_id: str) -> ViewState:
        """Register a new view and create its state"""
        view_state = ViewState(view_type=view_type, model_id=model_id)
        self._views[view_id] = view_state
        
        # Track which views are showing this model
        if model_id not in self._model_views:
            self._model_views[model_id] = set()
        self._model_views[model_id].add(view_id)
        
        # Initial view setup
        self._sync_view_with_model(view_id)
        return view_state
    
    def unregister_view(self, view_id: str) -> None:
        """Remove a view registration"""
        if view_id in self._views:
            view_state = self._views[view_id]
            # Remove from model tracking
            if view_state.model_id in self._model_views:
                self._model_views[view_state.model_id].discard(view_id)
            # Clear active view if needed
            if self._active_view == view_id:
                self._active_view = None
            # Remove view state
            del self._views[view_id]
    
    def set_active_view(self, view_id: Optional[str]) -> None:
        """Set the currently active view"""
        if view_id == self._active_view:
            return
            
        # Deactivate current
        if self._active_view and self._active_view in self._views:
            self._views[self._active_view].is_active = False
            
        # Activate new
        self._active_view = view_id
        if view_id and view_id in self._views:
            self._views[view_id].is_active = True
            
        # Notify state of active model change
        if view_id and view_id in self._views:
            self.state.set_active_model(self._views[view_id].model_id)
        else:
            self.state.set_active_model(None)
    
    def get_view_state(self, view_id: str) -> Optional[ViewState]:
        """Get the state for a specific view"""
        return self._views.get(view_id)
    
    def set_view_property(self, view_id: str, key: str, value: Any) -> None:
        """Set a property on a view's state"""
        if view_id in self._views:
            self._views[view_id].properties[key] = value
    
    def mark_dirty(self, view_id: str) -> None:
        """Mark a view as needing update"""
        if view_id in self._views:
            self._views[view_id].is_dirty = True
    
    def _handle_model_change(self, model_id: str, property_name: str, value: Any) -> None:
        """Handle model property changes"""
        if model_id in self._model_views:
            for view_id in self._model_views[model_id]:
                self.mark_dirty(view_id)
    
    def _handle_model_delete(self, model_id: str) -> None:
        """Handle model deletion"""
        if model_id in self._model_views:
            # Get list of affected views
            affected_views = list(self._model_views[model_id])
            # Clean up registrations
            for view_id in affected_views:
                self.unregister_view(view_id)
            # Remove model tracking
            del self._model_views[model_id]
    
    def _sync_view_with_model(self, view_id: str) -> None:
        """Synchronize view state with its model"""
        view_state = self._views.get(view_id)
        if not view_state:
            return
            
        model = self.state.registry.get_model(view_state.model_id)
        if not model:
            return
            
        # Update view properties based on model
        view_state.properties.update({
            'model_type': type(model).__name__,
            'model_properties': model.to_dict().get('properties', {})
        })
        view_state.is_dirty = False


================================================================================
*** __init__.py ***
### src/pymetr/views/ribbon/__init__.py ###
================================================================================




================================================================================
*** context.py ***
### src/pymetr/views/ribbon/context.py ###
================================================================================

# src/pymetr/views/ribbon/context.py
from abc import ABC, abstractmethod
from typing import List, Dict, Any
from dataclasses import dataclass
from enum import Enum, auto
from pathlib import Path

from pymetr.state import ApplicationState

class ActionCategory(Enum):
    """Categories for ribbon actions."""
    FILE = auto()
    EDIT = auto()
    RUN = auto()
    ANALYZE = auto()
    PLOT = auto()
    DATA = auto()

@dataclass
class RibbonAction:
    """Represents a single ribbon action."""
    id: str
    name: str
    category: ActionCategory
    icon: str
    enabled: bool = True
    menu_items: Dict[str, tuple[str, callable]] = None
    tooltip: str = ""

class RibbonContext(ABC):
    """Base class for ribbon contexts."""
    def __init__(self, state: ApplicationState):
        self.state = state
        
    @abstractmethod
    def get_actions(self) -> List[RibbonAction]:
        """Get available actions for this context."""
        pass
    
    @abstractmethod
    def get_title(self) -> str:
        """Get context title for ribbon."""
        pass
    
    def can_execute(self, action_id: str) -> bool:
        """Check if an action can be executed."""
        return True

class DefaultContext(RibbonContext):
    """Default context when no model is selected."""
    def get_actions(self) -> List[RibbonAction]:
        # Return empty list since standard buttons are handled by permanent groups
        return []
    
    def get_title(self) -> str:
        return "Home"

class ScriptContext(RibbonContext):
    """Context for test script editing."""
    def get_actions(self) -> List[RibbonAction]:
        save_menu_items = {
            "Save": ("save.png", lambda: self.state.save_script()),
            "Save As...": ("save_as.png", lambda: self.state.save_script_as())
        }
        
        return [
            RibbonAction(
                id="save",
                name="Save",
                category=ActionCategory.FILE,
                icon="save.png",
                menu_items=save_menu_items,
                tooltip="Save script"
            ),
            RibbonAction(
                id="run",
                name="Run",
                category=ActionCategory.RUN,
                icon="run.png",
                tooltip="Run test script"
            ),
            RibbonAction(
                id="stop",
                name="Stop",
                category=ActionCategory.RUN,
                icon="stop.png",
                enabled=False,
                tooltip="Stop test execution"
            )
        ]
    
    def get_title(self) -> str:
        return "Script Editor"

class PlotContext(RibbonContext):
    """Context for plot editing."""
    def get_actions(self) -> List[RibbonAction]:
        return [
            RibbonAction(
                id="autorange",
                name="Auto Range",
                category=ActionCategory.PLOT,
                icon="autorange.png",
                tooltip="Auto-scale plot axes"
            ),
            RibbonAction(
                id="roi",
                name="ROI",
                category=ActionCategory.PLOT,
                icon="roi.png",
                tooltip="Toggle region of interest"
            ),
            RibbonAction(
                id="export_plot",
                name="Export",
                category=ActionCategory.FILE,
                icon="export.png",
                tooltip="Export plot as image"
            )
        ]
    
    def get_title(self) -> str:
        return "Plot Editor"
    
class DataTableContext(RibbonContext):
    """Context for data table manipulation."""
    def get_actions(self) -> List[RibbonAction]:
        export_menu_items = {
            "Export CSV": ("csv.png", lambda: self.state.export_data("csv")),
            "Export Excel": ("excel.png", lambda: self.state.export_data("excel")),
            "Export JSON": ("json.png", lambda: self.state.export_data("json"))
        }

        return [
            RibbonAction(
                id="export_data",
                name="Export",
                category=ActionCategory.DATA,
                icon="export.png",
                menu_items=export_menu_items,
                tooltip="Export data table"
            ),
            RibbonAction(
                id="sort_data",
                name="Sort",
                category=ActionCategory.DATA,
                icon="sort.png",
                tooltip="Sort data table"
            ),
            RibbonAction(
                id="filter_data",
                name="Filter",
                category=ActionCategory.DATA,
                icon="filter.png",
                tooltip="Filter data table"
            )
        ]
    
    def get_title(self) -> str:
        return "Data Table"


================================================================================
*** manager.py ***
### src/pymetr/views/ribbon/manager.py ###
================================================================================

# src/pymetr/views/ribbon/manager.py
from typing import Dict, Type, Optional, List
from PySide6.QtWidgets import (
    QWidget, QToolBar, QLabel, QHBoxLayout, QVBoxLayout,
    QToolButton, QMenu, QFrame
)
from PySide6.QtCore import Qt, Signal
from PySide6.QtGui import QAction, QIcon
from pathlib import Path

from pymetr.state import ApplicationState
from .context import RibbonContext, DefaultContext, ScriptContext, PlotContext, ActionCategory, DataTableContext


class RibbonToolButton(QToolButton):
    """Enhanced tool button with better styling and interaction."""
    def __init__(self, icon_path: str, text: str, parent=None, large=False):
        super().__init__(parent)
        
        # Set text and icon
        self.setText(text)
        self.setIcon(QIcon(str(icon_path)))
        
        # Configure appearance
        self.setToolButtonStyle(Qt.ToolButtonTextUnderIcon)
        self.setAutoRaise(True)
        
        # Size based on large flag
        if large:
            self.setIconSize(QIcon(str(icon_path)).pixmap(42, 42).size())
            self.setFixedSize(64, 64)
        else:
            self.setIconSize(QIcon(str(icon_path)).pixmap(24, 24).size())
            self.setFixedSize(48, 48)
        
        # Apply styling
        self.setStyleSheet("""
            QToolButton {
                border: none;
                border-radius: 4px;
                padding: 4px;
                color: #333333;
            }
            QToolButton:hover {
                background-color: rgba(0, 0, 0, 0.1);
            }
            QToolButton:pressed {
                background-color: rgba(0, 0, 0, 0.2);
            }
            QToolButton:disabled {
                color: #999999;
            }
            QToolButton[popupMode="MenuButtonPopup"] {
                padding-right: 16px;
            }
        """)

class RibbonGroup(QWidget):
    """A group of related ribbon actions."""
    
    action_triggered = Signal(str)  # Emits action_id
    
    def __init__(self, title: str, parent=None):
        super().__init__(parent)
        self.title = title
        self.buttons: Dict[str, RibbonToolButton] = {}
        
        # Layout
        self.layout = QVBoxLayout(self)
        self.layout.setContentsMargins(4, 4, 4, 4)
        self.layout.setSpacing(2)
        
        # Button container
        self.button_container = QWidget()
        self.button_layout = QHBoxLayout(self.button_container)
        self.button_layout.setContentsMargins(0, 0, 0, 0)
        self.button_layout.setSpacing(4)
        self.layout.addWidget(self.button_container)
        
        # Group title
        self.title_label = QLabel(title)
        self.title_label.setAlignment(Qt.AlignCenter)
        self.layout.addWidget(self.title_label)
        
        # Style
        self.setStyleSheet("""
            RibbonGroup {
                background-color: transparent;
                border-right: 1px solid #CCCCCC;
                padding: 2px;
                margin: 0px;
            }
            QLabel {
                color: #666666;
                font-size: 11px;
            }
        """)

    def add_button(self, action_id: str, name: str, icon_path: Path, 
                  menu_items=None, large=False, enabled=True) -> RibbonToolButton:
        """Add a button to the group."""
        button = RibbonToolButton(icon_path, name, self, large)
        
        # Setup menu if provided
        if menu_items:
            menu = QMenu(button)
            for item_text, (item_icon, handler) in menu_items.items():
                action = menu.addAction(QIcon(str(self.parent().icons_path / item_icon)), item_text)
                if handler:
                    action.triggered.connect(handler)
            button.setMenu(menu)
            button.setPopupMode(QToolButton.MenuButtonPopup)
            # Connect clicked to default menu item
            if len(menu_items) > 0:
                first_item = list(menu_items.items())[0]
                button.clicked.connect(first_item[1][1])
        else:
            # For regular buttons, connect clicked to action_triggered
            button.clicked.connect(lambda: self.action_triggered.emit(action_id))
        
        button.setEnabled(enabled)
        self.buttons[action_id] = button
        self.button_layout.addWidget(button)
        return button

class RibbonManager(QWidget):
    """Manages the ribbon UI and context switching."""
    
    action_triggered = Signal(str)  # Emits action_id
    
    def __init__(self, state: ApplicationState, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.state = state
        self.icons_path = Path(__file__).parent / "icons"
        
        # Setup UI
        self._setup_ui()
        
        # Track current context
        self._current_context: Optional[RibbonContext] = None
        
        # Map model types to context classes
        self._context_map: Dict[str, Type[RibbonContext]] = {
            'TestScript': ScriptContext,
            'Plot': PlotContext,
            'DataTable': DataTableContext
        }
        
        # Connect to state signals
        self.state.signals.connect('active_model_changed', self._handle_active_model)
        
        # Set to default context initially
        self._set_context(DefaultContext(self.state))
    
    def _setup_ui(self) -> None:
        """Setup ribbon UI layout."""
        self.layout = QVBoxLayout(self)
        self.layout.setContentsMargins(0, 0, 0, 0)
        self.layout.setSpacing(0)
        
        # Title bar
        self.title_bar = QWidget()
        title_layout = QHBoxLayout(self.title_bar)
        title_layout.setContentsMargins(8, 4, 8, 4)
        self.title_label = QLabel()
        title_layout.addWidget(self.title_label)
        title_layout.addStretch()
        self.layout.addWidget(self.title_bar)
        
        # Main ribbon container
        ribbon_container = QWidget()
        ribbon_layout = QHBoxLayout(ribbon_container)
        ribbon_layout.setContentsMargins(4, 4, 4, 4)
        ribbon_layout.setSpacing(0)
        
        # Standard section (always visible)
        self.standard_section = QWidget()
        self.standard_layout = QHBoxLayout(self.standard_section)
        self.standard_layout.setContentsMargins(0, 0, 0, 0)
        self.standard_layout.setSpacing(4)
        ribbon_layout.addWidget(self.standard_section)
        
        # Create permanent File group
        self._setup_file_group()
        
        # Create permanent Instruments group
        self._setup_instruments_group()
        
        # Separator
        separator = QFrame()
        separator.setFrameShape(QFrame.VLine)
        separator.setStyleSheet("QFrame { color: #CCCCCC; }")
        ribbon_layout.addWidget(separator)
        
        # Context section
        self.context_section = QWidget()
        self.context_layout = QHBoxLayout(self.context_section)
        self.context_layout.setContentsMargins(0, 0, 0, 0)
        self.context_layout.setSpacing(4)
        ribbon_layout.addWidget(self.context_section)
        
        ribbon_layout.addStretch()
        self.layout.addWidget(ribbon_container)

    def _setup_file_group(self):
        """Setup permanent File group."""
        file_group = RibbonGroup("File", self)
        
        # New button with menu
        new_menu_items = {
            "New Script": ("new_script.png", lambda: self.action_triggered.emit("new_script")),
            "New Suite": ("new_suite.png", lambda: self.action_triggered.emit("new_suite"))
        }
        file_group.add_button("new", "New", self.icons_path / "new.png", menu_items=new_menu_items, large=True)
        
        # Open button with menu
        open_menu_items = {
            "Open Script": ("open_script.png", lambda: self.action_triggered.emit("open_script")),
            "Open Suite": ("open_suite.png", lambda: self.action_triggered.emit("open_suite"))
        }
        file_group.add_button("open", "Open", self.icons_path / "open.png", menu_items=open_menu_items, large=True)
        
        self.standard_layout.addWidget(file_group)
        
    def _setup_instruments_group(self):
        """Setup permanent Instruments group."""
        instruments_group = RibbonGroup("Instruments", self)
        instruments_group.add_button("instruments", "Connect", self.icons_path / "instruments.png", large=True)
        self.standard_layout.addWidget(instruments_group)
    
    def _set_context(self, context: RibbonContext) -> None:
        """Switch to new ribbon context."""
        self._current_context = context
        
        # Update title
        self.title_label.setText(context.get_title())
        
        # Clear existing context actions
        while self.context_layout.count():
            item = self.context_layout.takeAt(0)
            if item.widget():
                item.widget().deleteLater()
        
        # Add context-specific groups
        for action in context.get_actions():
            group = RibbonGroup(action.name, self)
            icon_path = self.icons_path / f"{action.id}.png"
            
            if not icon_path.exists():
                icon_path = self.icons_path / "default.png"
            
            button = group.add_button(
                action.id, 
                action.name,
                icon_path,
                menu_items=action.menu_items,
                large=True,
                enabled=action.enabled
            )
            
            group.action_triggered.connect(self._handle_action)
            self.context_layout.addWidget(group)
            
    def _handle_action(self, action_id: str) -> None:
        """Handle ribbon action triggered."""
        if self._current_context and self._current_context.can_execute(action_id):
            self.action_triggered.emit(action_id)

    def _handle_active_model(self, model_id: str, old_id: str) -> None:
        """Update ribbon context based on active model."""
        if not model_id:
            self._set_context(DefaultContext(self.state))
            return
            
        model = self.state.registry.get_model(model_id)
        if not model:
            return
            
        # Get appropriate context for model type
        model_type = type(model).__name__
        context_class = self._context_map.get(model_type, DefaultContext)
        self._set_context(context_class(self.state))


================================================================================
*** __init__.py ***
### src/pymetr/views/widgets/__init__.py ###
================================================================================




================================================================================
*** html_view.py ***
### src/pymetr/views/widgets/html_view.py ###
================================================================================

from PySide6.QtWidgets import QWidget, QVBoxLayout, QTextBrowser

class HtmlView(QWidget):
    """A simple HTML-based view for reports and welcome messages"""
    def __init__(self, state, title, html_content, parent=None):
        super().__init__(parent)
        self.state = state
        self.title = title

        layout = QVBoxLayout(self)
        self.browser = QTextBrowser()
        self.browser.setHtml(html_content)
        layout.addWidget(self.browser)



================================================================================
*** plot_view.py ***
### src/pymetr/views/widgets/plot_view.py ###
================================================================================




================================================================================
*** result_view.py ***
### src/pymetr/views/widgets/result_view.py ###
================================================================================




================================================================================
*** script_view.py ***
### src/pymetr/views/widgets/script_view.py ###
================================================================================

# src/pymetr/views/widgets/script_view.py
from pathlib import Path
from typing import Optional
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPlainTextEdit,
    QFontComboBox, QComboBox, QStatusBar, QTextEdit
)
from PySide6.QtGui import QSyntaxHighlighter, QTextCharFormat, QColor, QFont, QTextCursor, QPainter, QTextFormat
from PySide6.QtCore import Qt, QRegularExpression, QRect, QSize

from ...state import ApplicationState

class LineNumberArea(QWidget):
    def __init__(self, editor):
        super().__init__(editor)
        self.editor = editor

    def sizeHint(self):
        return QSize(self.editor.line_number_area_width(), 0)

    def paintEvent(self, event):
        self.editor.line_number_area_paint_event(event)

class PythonHighlighter(QSyntaxHighlighter):
    """Syntax highlighter for Python code"""
    def __init__(self, document):
        super().__init__(document)
        self._rules = []  # Store the highlighting rules
        self._setup_formats()
        self._initialize_rules()

    def _setup_formats(self):
        """Initialize text formats for different syntax elements"""
        self.formats = {
            'keyword': self._create_format("#C586C0", True),     # Purple
            'builtin': self._create_format("#4EC9B0", True),     # Teal
            'function': self._create_format("#DCDCAA", False),   # Yellow
            'comment': self._create_format("#6A9955", False, True), # Green
            'string': self._create_format("#CE9178", False),     # Orange
            'number': self._create_format("#B5CEA8", False),     # Light green
            'decorator': self._create_format("#D7BA7D", False),  # Gold
        }

    def _create_format(self, color: str, bold: bool = False, italic: bool = False) -> QTextCharFormat:
        fmt = QTextCharFormat()
        fmt.setForeground(QColor(color))
        if bold:
            fmt.setFontWeight(QFont.Bold)
        if italic:
            fmt.setFontItalic(True)
        return fmt

    def _initialize_rules(self):
        """Setup syntax highlighting rules."""
        # Python keywords
        keywords = [
            'and', 'as', 'assert', 'break', 'class', 'continue', 'def',
            'del', 'elif', 'else', 'except', 'False', 'finally', 'for',
            'from', 'global', 'if', 'import', 'in', 'is', 'lambda',
            'None', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return',
            'True', 'try', 'while', 'with', 'yield'
        ]

        # Add keyword rules
        for word in keywords:
            pattern = QRegularExpression(r'\b' + word + r'\b')
            self._rules.append((pattern, self.formats['keyword']))

        # Add other rules
        self._rules.extend([
            # Functions
            (QRegularExpression(r'\b[A-Za-z0-9_]+(?=\s*\()'), self.formats['function']),
            
            # Double-quoted strings
            (QRegularExpression(r'"[^"\\]*(\\.[^"\\]*)*"'), self.formats['string']),
            
            # Single-quoted strings
            (QRegularExpression(r'\'[^\'\\]*(\\.[^\'\\]*)*\''), self.formats['string']),
            
            # Comments
            (QRegularExpression(r'#[^\n]*'), self.formats['comment']),
            
            # Numbers
            (QRegularExpression(r'\b\d+\b'), self.formats['number']),
            
            # Decorators
            (QRegularExpression(r'@\w+'), self.formats['decorator']),
        ])

    def highlightBlock(self, text: str):
        """Apply highlighting to a block of text."""
        for pattern, format in self._rules:
            matches = pattern.globalMatch(text)
            while matches.hasNext():
                match = matches.next()
                self.setFormat(match.capturedStart(), match.capturedLength(), format)

class ScriptEditor(QPlainTextEdit):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setup_editor()
        
        # Create and set up line number area
        self.line_number_area = LineNumberArea(self)
        
        # Connect signals for line numbers
        self.blockCountChanged.connect(self.update_line_number_area_width)
        self.updateRequest.connect(self.update_line_number_area)
        self.cursorPositionChanged.connect(self.highlight_current_line)
        
        # Initial setup
        self.update_line_number_area_width(0)
        self.highlight_current_line()

    def setup_editor(self):
        """Configure editor appearance and behavior"""
        # Set default font
        font = QFont("Consolas", 11)
        self.setFont(font)
        
        # Set colors and styling
        self.setStyleSheet("""
            QPlainTextEdit {
                background-color: #1E1E1E;
                color: #D4D4D4;
                padding: 8px;
                selection-background-color: #264F78;
                selection-color: #D4D4D4;
            }
        """)
        
        # Editor settings
        self.setTabStopDistance(self.fontMetrics().horizontalAdvance(' ') * 4)
        self.setLineWrapMode(QPlainTextEdit.NoWrap)

    def line_number_area_width(self):
        """Calculate the width needed for the line number area."""
        digits = 1
        max_num = max(1, self.blockCount())
        while max_num >= 10:
            max_num //= 10
            digits += 1
            
        space = 3 + self.fontMetrics().horizontalAdvance('9') * digits
        return space

    def update_line_number_area_width(self, new_block_count):
        """Update the editor's viewport margins."""
        self.setViewportMargins(self.line_number_area_width(), 0, 0, 0)

    def update_line_number_area(self, rect, dy):
        """Handle scrolling of the line number area."""
        if dy:
            self.line_number_area.scroll(0, dy)
        else:
            self.line_number_area.update(0, rect.y(), 
                self.line_number_area.width(), rect.height())

        if rect.contains(self.viewport().rect()):
            self.update_line_number_area_width(0)

    def resizeEvent(self, event):
        """Handle resize events to adjust the line number area."""
        super().resizeEvent(event)
        cr = self.contentsRect()
        self.line_number_area.setGeometry(QRect(cr.left(), cr.top(),
            self.line_number_area_width(), cr.height()))

    def line_number_area_paint_event(self, event):
        """Paint the line numbers."""
        painter = QPainter(self.line_number_area)
        painter.fillRect(event.rect(), QColor("#1E1E1E"))

        block = self.firstVisibleBlock()
        block_number = block.blockNumber()
        offset = self.contentOffset()
        top = self.blockBoundingGeometry(block).translated(offset).top()
        bottom = top + self.blockBoundingRect(block).height()

        while block.isValid() and top <= event.rect().bottom():
            if block.isVisible() and bottom >= event.rect().top():
                number = str(block_number + 1)
                painter.setPen(QColor("#858585"))  # Gray color for line numbers
                painter.drawText(0, int(top), self.line_number_area.width(), 
                    self.fontMetrics().height(),
                    Qt.AlignRight, number)

            block = block.next()
            top = bottom
            bottom = top + self.blockBoundingRect(block).height()
            block_number += 1

    def highlight_current_line(self):
        """Highlight the current line."""
        extra_selections = []

        if not self.isReadOnly():
            selection = QTextEdit.ExtraSelection()
            selection.format.setBackground(QColor("#282828"))  # Dark gray for current line
            selection.format.setProperty(QTextFormat.FullWidthSelection, True)
            selection.cursor = self.textCursor()
            selection.cursor.clearSelection()
            extra_selections.append(selection)

        self.setExtraSelections(extra_selections)

class ScriptView(QWidget):
    """Widget for editing Python test scripts"""
    def __init__(self, state: ApplicationState, model_id: str, parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.state = state
        self.model_id = model_id
        self.model = self.state.registry.get_model(model_id)
        
        if not self.model:
            raise ValueError(f"No model found with ID: {model_id}")
            
        self.setup_ui()
        self.register_observers()
        self.load_content()

    def setup_ui(self):
        """Initialize the UI components"""
        layout = QVBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(0)

        # Editor settings panel
        self.settings_panel = QWidget()
        settings_layout = QHBoxLayout(self.settings_panel)
        settings_layout.setContentsMargins(4, 4, 4, 4)
        
        # Font controls
        self.font_combo = QFontComboBox()
        self.font_combo.setCurrentFont(QFont("Consolas"))
        self.font_combo.currentFontChanged.connect(self.change_font)
        settings_layout.addWidget(self.font_combo)
        
        self.size_combo = QComboBox()
        self.size_combo.addItems([str(s) for s in [8,9,10,11,12,14,16,18,20]])
        self.size_combo.setCurrentText("11")
        self.size_combo.currentTextChanged.connect(self.change_font_size)
        settings_layout.addWidget(self.size_combo)
        
        settings_layout.addStretch()
        layout.addWidget(self.settings_panel)

        # Editor
        self.editor = ScriptEditor()
        self.highlighter = PythonHighlighter(self.editor.document())
        layout.addWidget(self.editor)
        
        # Status bar
        self.status_bar = QStatusBar()
        self.status_bar.setStyleSheet("""
            QStatusBar {
                background: #007ACC;
                color: white;
            }
        """)
        layout.addWidget(self.status_bar)

    def register_observers(self):
        """Register for state changes"""
        self.state.signals.connect(
            f"test.{self.model_id}.status",
            self.handle_test_status_changed
        )
        self.state.signals.connect(
            f"test.{self.model_id}.progress",
            self.handle_test_progress
        )

    def handle_test_status_changed(self, payload: dict):
        """Handle test status updates"""
        new_status = payload["new_status"]
        self.status_bar.showMessage(f"TestScript Status: {new_status}")

    def handle_test_progress(self, payload: dict):
        """Handle test progress updates"""
        percent = payload["percent"]
        message = payload.get("message", "")
        self.status_bar.showMessage(f"Progress: {percent}% - {message}")

    def load_content(self):
        """Load script content from model"""
        script_path = self.model.get_property('script_path')
        if script_path:
            path = Path(script_path)
            if path.exists():
                try:
                    content = path.read_text(encoding='utf-8')
                    self.editor.setPlainText(content)
                    self.status_bar.showMessage(f"Loaded {path}")
                except Exception as e:
                    self.status_bar.showMessage(f"Error loading script: {str(e)}")

    def change_font(self, font: QFont):
        """Update editor font family"""
        current_font = self.editor.font()
        current_font.setFamily(font.family())
        self.editor.setFont(current_font)

    def change_font_size(self, size_str: str):
        """Update editor font size"""
        try:
            size = int(size_str)
            current_font = self.editor.font()
            current_font.setPointSize(size)
            self.editor.setFont(current_font)
        except ValueError:
            pass


================================================================================
*** tab_manager.py ***
### src/pymetr/views/widgets/tab_manager.py ###
================================================================================

# src/pymetr/views/widgets/tab_manager.py
from typing import Dict, Optional, Type, TYPE_CHECKING
from PySide6.QtWidgets import QTabWidget, QWidget, QLabel, QVBoxLayout
from ..manager import ViewType
from pymetr.logging import logger

if TYPE_CHECKING:
    from pymetr.state import ApplicationState

class TabManager(QTabWidget):
    """Manages content tabs based on model selection"""
    
    # Map model types to their default view types
    DEFAULT_VIEWS = {
        'TestScript': ViewType.SCRIPT,
        'TestResult': ViewType.RESULT,
        'Plot': ViewType.PLOT,
        'DataTable': ViewType.DATA_TABLE
    }
    
    def __init__(self, state: 'ApplicationState', parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.state = state
        self.setTabsClosable(True)
        
        # Track open tabs by model_id
        self._tabs: Dict[str, QWidget] = {}
        
        # Connect to tab close button
        self.tabCloseRequested.connect(self._handle_tab_close)
        
        # Connect to state signals
        self.state.signals.connect('active_model_changed', self._handle_active_model)
        self.state.signals.connect('model_deleted', self._handle_model_deleted)

        # Open welcome tab initially
        self.open_welcome_tab()

    def open_welcome_tab(self):
        """Opens the welcome tab as an HTML-like view"""
        if "welcome" in self._tabs:
            self.setCurrentWidget(self._tabs["welcome"])
            return

        # Create a simple QWidget for now (HTML rendering can be added later)
        welcome_widget = QWidget()
        layout = QVBoxLayout()
        layout.addWidget(QLabel("<h1>Welcome to PyMetr</h1><p>Start by selecting a test or data table.</p>"))
        welcome_widget.setLayout(layout)

        self._tabs["welcome"] = welcome_widget
        self.addTab(welcome_widget, "ð  Welcome")
        self.setCurrentWidget(welcome_widget)
        
    def _handle_active_model(self, model_id: str, old_id: str) -> None:
        """Open or switch to tab for active model"""
        logger.debug(f"Active model changed: {model_id} (old: {old_id})")

        if not model_id:
            logger.warning("No active model ID received.")
            return

        if model_id in self._tabs:
            logger.info(f"Switching to existing tab for model: {model_id}")
            self.setCurrentWidget(self._tabs[model_id])
            return

        model = self.state.registry.get_model(model_id)
        if not model:
            logger.error(f"Model not found in registry: {model_id}")
            return

        view_type = self.DEFAULT_VIEWS.get(type(model).__name__, None)
        if not view_type:
            logger.warning(f"No default view type for model: {model_id} ({type(model).__name__})")
            return

        new_tab = self._create_view(model_id, view_type)
        if new_tab:
            name = model.get_property('name', 'Unnamed')
            self._tabs[model_id] = new_tab
            self.addTab(new_tab, name)
            self.setCurrentWidget(new_tab)
            logger.info(f"Opened new tab for model: {model_id}")
        else:
            logger.error(f"Failed to create view for model: {model_id}")
    
    def _create_view(self, model_id: str, view_type: ViewType) -> Optional[QWidget]:
        logger.debug(f"Creating view for model {model_id} with type {view_type}")
        if view_type == ViewType.SCRIPT:
            from .script_view import ScriptView
            return ScriptView(self.state, model_id, self)
        elif view_type == ViewType.RESULT:
            from .result_view import ResultView
            return ResultView(self.state, model_id, self)
        elif view_type == ViewType.PLOT:
            from .plot_view import PlotView
            return PlotView(self.state, model_id, self)
        elif view_type == ViewType.DATA_TABLE:
            from .table_view import TableView
            return TableView(self.state, model_id, self)
        logger.error(f"No view created for model {model_id} with type {view_type}")
        return None
    
    def _handle_tab_close(self, index: int) -> None:
        """Handle tab close button"""
        widget = self.widget(index)
        for model_id, tab in self._tabs.items():
            if tab == widget:
                self.removeTab(index)
                del self._tabs[model_id]
                break

    def _handle_model_deleted(self, model_id: str) -> None:
        """Handle model deletion"""
        if model_id in self._tabs:
            widget = self._tabs[model_id]
            index = self.indexOf(widget)
            if index >= 0:
                self.removeTab(index)
            del self._tabs[model_id]


================================================================================
*** table_view.py ***
### src/pymetr/views/widgets/table_view.py ###
================================================================================

from PySide6.QtWidgets import QWidget, QVBoxLayout, QTableWidget, QTableWidgetItem
from PySide6.QtCore import Qt
import pandas as pd

from pymetr.state import ApplicationState
from pymetr.models.data_table import DataTable

class TableView(QWidget):
    """Widget for displaying DataTable models."""
    
    def __init__(self, state: ApplicationState, model_id: str, parent=None):
        super().__init__(parent)
        self.state = state
        self.model_id = model_id
        self.model: DataTable = state.registry.get_model(model_id)

        if not self.model:
            raise ValueError(f"No DataTable model found with ID: {model_id}")

        self._setup_ui()
        self._load_data()
        self._register_signals()

    def _setup_ui(self):
        """Setup the table UI."""
        self.layout = QVBoxLayout(self)
        self.table = QTableWidget()
        self.layout.addWidget(self.table)

    def _load_data(self):
        """Load data from DataTable model into the table widget."""
        if self.model and isinstance(self.model.data, pd.DataFrame):
            df = self.model.data
            self.table.setRowCount(len(df))
            self.table.setColumnCount(len(df.columns))
            self.table.setHorizontalHeaderLabels(df.columns.tolist())

            for row_idx, row in df.iterrows():
                for col_idx, value in enumerate(row):
                    item = QTableWidgetItem(str(value))
                    item.setFlags(Qt.ItemIsSelectable | Qt.ItemIsEnabled)
                    self.table.setItem(row_idx, col_idx, item)

    def _register_signals(self):
        """Register model signals to update the view when data changes."""
        self.model.data_changed.connect(self._on_data_changed)
        self.model.row_added.connect(self._on_row_added)
        self.model.row_removed.connect(self._on_row_removed)

    def _on_data_changed(self):
        """Reloads the table when the entire dataset changes."""
        self._load_data()

    def _on_row_added(self, row):
        """Handles when a new row is added."""
        self._load_data()

    def _on_row_removed(self, row):
        """Handles when a row is removed."""
        self._load_data()



================================================================================
*** tree_view.py ***
### src/pymetr/views/widgets/tree_view.py ###
================================================================================

# src/pymetr/views/widgets/tree_view.py
from typing import Dict, Optional, Any, TYPE_CHECKING
from PySide6.QtWidgets import QWidget
from PySide6.QtCore import Signal
import pyqtgraph.parametertree as pt
from pyqtgraph.parametertree import Parameter, ParameterTree

if TYPE_CHECKING:
    from pymetr.state import ApplicationState
    from pymetr.models.base import BaseModel

from ..manager import ViewType
from pymetr.logging import logger

class ModelTreeItem(pt.Parameter):
    """Parameter tree item with model information"""
    def __init__(self, model_id: str, model_type: str, name: str, **kwargs):
        # For TestScript types, include progress parameter in the root
        if model_type == 'TestScript':
            kwargs['type'] = 'int'
            kwargs['value'] = 0
            kwargs['suffix'] = '%'
            kwargs['limits'] = (0, 100)
        else:
            kwargs['type'] = 'group'  # Other types are groups
            
        super().__init__(name=name, **kwargs)
        self.model_id = model_id
        self.model_type = model_type

class ModelTreeView(pt.ParameterTree):
    """Tree view using PyQtGraph's ParameterTree"""
    
    selection_changed = Signal(str)  # Emits model_id
    
    MODEL_ICONS = {
        'TestScript': 'ð',
        'TestResult': 'ð',
        'Plot': 'ð',
        'DataTable': 'ð',
        'default': 'ð'
    }
    
    def __init__(self, state: 'ApplicationState', parent: Optional[QWidget] = None):
        super().__init__(parent)
        self.state = state
        self.view_id = f"tree_view_{id(self)}"
        
        logger.debug("Initializing ModelTreeView")
        
        self.root = pt.Parameter.create(name='Models', type='group', children=[])
        self.setParameters(self.root)
        
        self._item_map: Dict[str, ModelTreeItem] = {}
        
        self.state.views.register_view(self.view_id, ViewType.TREE, None)
        
        self.state.signals.connect('model_created', self._handle_model_created)
        self.state.signals.connect('model_deleted', self._handle_model_deleted)
        self.state.signals.connect('models_linked', self._handle_models_linked)
        self.state.signals.connect('models_unlinked', self._handle_models_unlinked)
        self.state.signals.connect('model_changed', self._handle_model_changed)
        
        self.itemSelectionChanged.connect(self._handle_selection_changed)

    def _create_model_item(self, model: 'BaseModel') -> ModelTreeItem:
        """Create a parameter tree item for a model"""
        model_type = type(model).__name__
        icon = self.MODEL_ICONS.get(model_type, self.MODEL_ICONS['default'])
        name = model.name if hasattr(model, 'name') else model.get_property('name', 'Unnamed')
        
        item = ModelTreeItem(
            model_id=model.id,
            model_type=model_type,
            name=f"{icon} {name}"
        )
        
        if model_type == 'TestScript':
            progress = model.get_property('progress', 0)
            status = model.get_property('status', 'Not Run')
            item.setValue(progress)
            
        return item

    def _handle_model_created(self, model_id: str, model_type: str) -> None:
        """Handle new model creation"""
        model = self.state.registry.get_model(model_id)
        if model:
            item = self._create_model_item(model)
            self._item_map[model_id] = item
            self.root.addChild(item)
            logger.info(f"Model created: {model_id} ({model_type})")

    def _handle_model_changed(self, model_id: str, property_name: str, value: Any) -> None:
        if model_id in self._item_map:
            item = self._item_map[model_id]
            model = self.state.registry.get_model(model_id)
            
            if property_name == 'name':
                icon = self.MODEL_ICONS.get(type(model).__name__, self.MODEL_ICONS['default'])
                item.setName(f"{icon} {value}")
            elif property_name == 'progress' and type(model).__name__ == 'TestScript':
                item.setValue(value)
            elif property_name == 'status' and type(model).__name__ == 'TestScript':
                item.setOpts(status=value)

    def _handle_models_linked(self, parent_id: str, child_id: str) -> None:
        if parent_id in self._item_map and child_id in self._item_map:
            parent_item = self._item_map[parent_id]
            child_item = self._item_map[child_id]
            
            if child_item.parent():
                child_item.remove()
            parent_item.addChild(child_item)
            logger.info(f"Linked models: {parent_id} -> {child_id}")

    def _handle_selection_changed(self) -> None:
        """Handle tree selection change and notify state"""
        selected = self.selectedItems()
        
        if not selected:
            logger.warning("No items selected in the tree.")
            self.state.set_active_model(None)
            self.selection_changed.emit("")
            return

        logger.debug(f"Raw selected items: {selected}")

        param_item = selected[0]
        param = param_item.param

        if param is None:
            logger.error(f"Selected item has no 'param' attribute: {type(param_item)}")
            self.state.set_active_model(None)
            self.selection_changed.emit("")
            return

        logger.debug(f"Extracted Parameter: {param.name()} ({param.type()})")

        if hasattr(param, 'model_id'):
            logger.info(f"Setting active model to: {param.model_id}")
            self.state.set_active_model(param.model_id)
            self.selection_changed.emit(param.model_id)
        else:
            logger.warning("Selected item does not have a 'model_id' attribute.")
            self.state.set_active_model(None)
            self.selection_changed.emit("")

    def _handle_model_deleted(self, model_id: str) -> None:
        if model_id in self._item_map:
            item = self._item_map[model_id]
            item.remove()
            del self._item_map[model_id]
            logger.info(f"Model deleted: {model_id}")
    
    def _handle_models_unlinked(self, parent_id: str, child_id: str) -> None:
        if child_id in self._item_map:
            child_item = self._item_map[child_id]
            if child_item.parent():
                child_item.remove()
                self.root.addChild(child_item)
                logger.info(f"Unlinked models: {parent_id} -> {child_id}")


================================================================================
*** __init__.py ***
### src/pymetr/views/windows/__init__.py ###
================================================================================




================================================================================
*** instrument_discovery.py ***
### src/pymetr/views/windows/instrument_discovery.py ###
================================================================================

from PySide6.QtWidgets import (QDialog, QVBoxLayout, QTableWidget, 
    QTableWidgetItem, QPushButton, QDialogButtonBox, QComboBox, 
    QLabel, QHeaderView)
from PySide6.QtCore import Qt
import logging

from drivers.base import Instrument
from drivers.registry import get_driver_info

logger = logging.getLogger(__name__)

class InstrumentDiscoveryDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Discover Instruments")
        self.setModal(True)
        self.resize(800, 400)
        
        self.selected_instrument = None
        self.setup_ui()
        
    def setup_ui(self):
        layout = QVBoxLayout(self)
        
        # Status label
        self.status_label = QLabel("Click Refresh to start instrument discovery...")
        layout.addWidget(self.status_label)
        
        # Instrument table
        self.table = QTableWidget()
        self.table.setColumnCount(5)
        self.table.setHorizontalHeaderLabels([
            "Manufacturer", "Model", "Serial", "Firmware", "Resource"
        ])
        self.table.setSelectionBehavior(QTableWidget.SelectRows)
        self.table.setSelectionMode(QTableWidget.SingleSelection)
        layout.addWidget(self.table)
        
        # QHeaderView resize mode is an enum in PySide6
        header = self.table.horizontalHeader()
        header.setSectionResizeMode(0, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(1, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(2, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(3, QHeaderView.ResizeMode.ResizeToContents)
        header.setSectionResizeMode(4, QHeaderView.ResizeMode.Stretch)
        
        # Buttons
        button_box = QDialogButtonBox()
        refresh_btn = QPushButton("Refresh")
        refresh_btn.clicked.connect(self.refresh_instruments)
        button_box.addButton(refresh_btn, QDialogButtonBox.ActionRole)
        
        button_box.addButton(QDialogButtonBox.Ok)
        button_box.addButton(QDialogButtonBox.Cancel)
        button_box.accepted.connect(self.accept)
        button_box.rejected.connect(self.reject)
        layout.addWidget(button_box)
        
    def refresh_instruments(self):
        """Use Instrument.list_instruments() to discover available devices."""
        self.table.setRowCount(0)
        self.status_label.setText("Discovering instruments...")
        self.repaint()  # Force UI update
        
        try:
            # Use the Instrument class's discovery method
            instruments = Instrument.list_instruments()
            
            for unique_id, info in instruments.items():
                row = self.table.rowCount()
                self.table.insertRow(row)
                
                # Add instrument information to table
                self.table.setItem(row, 0, QTableWidgetItem(info['manufacturer']))
                self.table.setItem(row, 1, QTableWidgetItem(info['model']))
                self.table.setItem(row, 2, QTableWidgetItem(info['serial']))
                self.table.setItem(row, 3, QTableWidgetItem(info['firmware']))
                self.table.setItem(row, 4, QTableWidgetItem(info['resource']))
            
            self.status_label.setText(f"Found {self.table.rowCount()} instruments")
            
        except Exception as e:
            logger.error(f"Error discovering instruments: {e}")
            self.status_label.setText(f"Error during discovery: {str(e)}")
            
    def accept(self):
        """Handle OK button click."""
        current_row = self.table.currentRow()
        if current_row >= 0:
            # Gather selected instrument information
            self.selected_instrument = {
                'manufacturer': self.table.item(current_row, 0).text(),
                'model': self.table.item(current_row, 1).text(),
                'serial': self.table.item(current_row, 2).text(),
                'firmware': self.table.item(current_row, 3).text(),
                'resource': self.table.item(current_row, 4).text()
            }
            
            try:
                # Check if we have a driver for this model
                driver_info = get_driver_info(self.selected_instrument['model'])
                self.selected_instrument['driver_info'] = driver_info
                super().accept()
            except ValueError as e:
                logger.error(f"No driver found: {e}")
                self.status_label.setText(f"No driver found for {self.selected_instrument['model']}")
        else:
            self.status_label.setText("Please select an instrument")


================================================================================
*** main_window.py ***
### src/pymetr/views/windows/main_window.py ###
================================================================================

from typing import Optional, TYPE_CHECKING
from PySide6.QtWidgets import (
    QMainWindow, QWidget, QDockWidget,
    QVBoxLayout, QApplication, QMessageBox
)
from PySide6.QtCore import Qt, QSize

from ..widgets.tree_view import ModelTreeView
from ..widgets.tab_manager import TabManager
from ..ribbon.manager import RibbonManager

if TYPE_CHECKING:
    from pymetr.state import ApplicationState

class MainWindow(QMainWindow):
    """Main application window"""
    def __init__(self, state: 'ApplicationState'):
        super().__init__()
        self.state = state
        
        self._setup_ui()
        self._setup_actions()
        
        # Set window properties
        self.setWindowTitle("pymetr")
        self.setMinimumSize(QSize(1200, 800))
    
    def _setup_ui(self) -> None:
        """Setup the main window UI layout"""
        # Create ribbon
        self.ribbon = RibbonManager(self.state)
        self.ribbon.setMaximumHeight(120)
        self.setMenuWidget(self.ribbon)  # Ensure ribbon spans the entire top
        
        # Create central widget
        central_widget = QWidget()
        self.setCentralWidget(central_widget)
        layout = QVBoxLayout(central_widget)
        layout.setContentsMargins(0, 0, 0, 0)  # Remove margins
        layout.setSpacing(0)  # Remove any layout spacing
        
        # Create tab manager
        self.tab_manager = TabManager(self.state)
        layout.addWidget(self.tab_manager)
        
        # Create model tree dock
        tree_dock = QDockWidget("Models", self)
        tree_dock.setAllowedAreas(Qt.LeftDockWidgetArea | Qt.RightDockWidgetArea)
        tree_dock.setMinimumWidth(300)  # Set minimum width for the tree dock
        self.tree_view = ModelTreeView(self.state)
        tree_dock.setWidget(self.tree_view)
        self.addDockWidget(Qt.LeftDockWidgetArea, tree_dock)
    
    def _setup_actions(self) -> None:
        """Connect actions to handlers"""
        self.ribbon.action_triggered.connect(self._handle_action)
    
    def _handle_action(self, action_id: str) -> None:
        """Handle ribbon action triggered"""
        try:
            # Execute action through action manager
            result = self.state.actions.execute(action_id)
            
            if not result.success:
                QMessageBox.warning(
                    self,
                    "Action Failed",
                    f"Failed to execute action: {result.error}"
                )
                
        except Exception as e:
            QMessageBox.critical(
                self,
                "Error",
                f"An error occurred: {str(e)}"
            )

def create_application(state: 'ApplicationState') -> tuple[QApplication, MainWindow]:
    """Create and setup the application and main window"""
    app = QApplication([])
    
    # Set application properties
    app.setApplicationName("pymetr")
    app.setApplicationVersion("0.1.0")
    
    # Create main window
    window = MainWindow(state)
    window.show()
    
    return app, window



================================================================================
*** __init__.py ***
### src/pymetr/visitors/__init__.py ###
================================================================================

# gui/visitors/__init__.py

from .instrument_visitor import InstrumentVisitor

__all__ = ['InstrumentVisitor']



================================================================================
*** instrument_visitor.py ***
### src/pymetr/visitors/instrument_visitor.py ###
================================================================================

import ast
import logging

logger = logging.getLogger(__name__)
from copy import deepcopy
import ast

class InstrumentVisitor(ast.NodeVisitor):
    def __init__(self):
        super().__init__()
        self.instruments = {}
        self.current_instrument = None
        self.current_subsystem = None
        logger.debug("ð¼ InstrumentVisitor initialized ð¼")

    def visit_ClassDef(self, node):
        logger.debug(f"ð Visiting Class Definition: {node.name} ð")
        bases = [base.id for base in node.bases if isinstance(base, ast.Name)]
        if any(base in ['Instrument', 'SCPIInstrument'] for base in bases):
            self.current_instrument = node.name
            logger.debug(f"ð· Found Instrument: {self.current_instrument} ð·")
            self.instruments[node.name] = {
                'subsystems': {},
                'properties': [],
                'methods': {},
                'gui_methods': {},
                'other_methods': {},
                'sources': []
            }
            self.extract_instrument_info(node)

        elif 'Subsystem' in bases and self.current_instrument:
            logger.debug(f"ð© Found Subsystem: {node.name} within {self.current_instrument} ð©")
            subsystem_visitor = SubsystemVisitor()
            subsystem_visitor.visit(node)
            subsystem_info = self.instruments[self.current_instrument]['subsystems'].get(node.name, {
                'properties': [],
                'methods': [],
                'instances': {}
            })

            if subsystem_info.get('needs_indexing', False):
                self.handle_indexed_subsystem(node, subsystem_info, subsystem_visitor.properties_methods)
            else:
                self.instruments[self.current_instrument]['subsystems'][node.name].update(subsystem_visitor.properties_methods)
            logger.debug(f"â¨ Subsystem info updated for {node.name} in {self.current_instrument} â¨")

        super().generic_visit(node)

    def extract_instrument_info(self, node):
        for item in node.body:
            if isinstance(item, ast.FunctionDef) and not item.name.startswith('_'):
                self.extract_method_info(item)
            elif isinstance(item, ast.Assign):
                self.process_assignment(item)

    def extract_method_info(self, item):
        logger.debug(f"Found method in {self.current_instrument}: {item.name}")
        method_info = {
            'args': [arg.arg for arg in item.args.args if arg.arg != 'self'],
            'return': self.get_return_annotation(item),
            'is_gui_method': self.is_gui_method(item)
        }
        if method_info['is_gui_method']:
            self.instruments[self.current_instrument]['gui_methods'][item.name] = method_info
        else:
            self.instruments[self.current_instrument]['other_methods'][item.name] = method_info

    def is_gui_method(self, node):
        for decorator in node.decorator_list:
            if (isinstance(decorator, ast.Attribute) and
                isinstance(decorator.value, ast.Name) and
                decorator.value.id == 'Instrument' and
                decorator.attr == 'gui_command'):
                return True
        return False

    def process_assignment(self, item):
        if (isinstance(item.value, ast.Call) and
                isinstance(item.value.func, ast.Name) and
                item.value.func.id == 'Sources'):
            sources_list = self.get_ast_node_value(item.value.args[0])
            self.instruments[self.current_instrument]['sources'] = sources_list
            logger.debug(f"Captured Sources for {self.current_instrument}: {sources_list}")

    def get_return_annotation(self, node):
        if node.returns:
            if isinstance(node.returns, ast.Name):
                return node.returns.id
            elif isinstance(node.returns, ast.Attribute):
                return f"{node.returns.value.id}.{node.returns.attr}"
        return None

    def handle_indexed_subsystem(self, node, subsystem_info, properties_methods):
        for index in range(1, subsystem_info['indices'] + 1):
            logger.debug(f"ð Indexing {index} in {node.name} ð")
            instance_info = deepcopy(properties_methods)
            self.instruments[self.current_instrument]['subsystems'][node.name]['instances'][index] = instance_info

    def visit_Assign(self, node):
        if self.current_instrument:
            if isinstance(node.value, ast.Call) and getattr(node.value.func, 'attr', '') == 'build':
                logger.debug(f"ð Parsing build call in {self.current_instrument} ð")
                subsystem_class_name = node.value.func.value.id
                indices = next((self.get_ast_node_value(kw.value) for kw in node.value.keywords if kw.arg == 'indices'), 1)

                subsystem_info = {
                    'indices': indices,
                    'needs_indexing': indices > 1,
                    'properties': [],
                    'methods': [],
                    'instances': {} if indices > 1 else None
                }
                self.instruments[self.current_instrument]['subsystems'][subsystem_class_name] = subsystem_info
                logger.debug(f"ð  Subsystem {subsystem_class_name} initialized with indexing: {indices > 1} ð ")
            elif (isinstance(node.value, ast.Call) and
                isinstance(node.value.func, ast.Name) and
                node.value.func.id == 'Sources'):
                logger.debug(f"Found Sources initialization: {ast.dump(node.value)}")
                sources_list = []
                
                # Check for positional arguments
                if node.value.args:
                    sources_arg = node.value.args[0]
                    if isinstance(sources_arg, ast.List):
                        sources_list = [el.value for el in sources_arg.elts]
                
                # Check for keyword arguments
                sources_keyword = next((kw for kw in node.value.keywords if kw.arg == 'sources'), None)
                if sources_keyword and isinstance(sources_keyword.value, ast.List):
                    sources_list = [el.value for el in sources_keyword.value.elts]
                
                if sources_list:
                    self.instruments[self.current_instrument]['sources'] = sources_list
                    logger.debug(f"Captured Sources for {self.current_instrument}: {sources_list}")
                else:
                    logger.warning(f"No sources found in Sources initialization for {self.current_instrument}")
        
        super().generic_visit(node)

    def get_ast_node_value(self, node):
        if isinstance(node, ast.Constant):
            return node.value
        elif isinstance(node, ast.Name):
            return node.id
        elif isinstance(node, ast.List):
            return [self.get_ast_node_value(el) for el in node.elts]
        elif isinstance(node, ast.Dict):
            return {key.value: self.get_ast_node_value(value) for key, value in zip(node.keys, node.values)}
        elif isinstance(node, ast.UnaryOp):
            operand = self.get_ast_node_value(node.operand)
            if isinstance(node.op, ast.UAdd):
                return +operand
            elif isinstance(node.op, ast.USub):
                return -operand
        else:
            logger.error(f"Unhandled node type: {type(node).__name__}")
            logger.debug(f"Node dump: {ast.dump(node)}")
            return None

class SubsystemVisitor(ast.NodeVisitor):
    def __init__(self):
        super().__init__()
        self.properties_methods = {'properties': [], 'methods': []}
        self.current_subsystem = None
        logger.debug("ð Initialized SubsystemVisitor ð")

    def visit_ClassDef(self, node):
        bases = [base.id for base in node.bases if isinstance(base, ast.Name)]
        if 'Subsystem' in bases:
            self.current_subsystem = node.name
            logger.debug(f"ð Visiting Subsystem: {self.current_subsystem} ð")
        self.generic_visit(node)
        if self.current_subsystem == node.name:
            self.current_subsystem = None

    def visit_Assign(self, node):
        logger.debug(f"ð Visiting Assign Node: {ast.dump(node)} ð")
        if isinstance(node.value, ast.Call) and isinstance(node.value.func, ast.Name):
            prop_class_name = node.value.func.id
            if prop_class_name in ['SelectProperty', 'ValueProperty', 'SwitchProperty', 'StringProperty', 'DataProperty']:
                logger.debug(f"â¨ Found a property: {prop_class_name} â¨")
                prop_name = node.targets[0].id
                prop_details = self.parse_property_details(node.value, prop_class_name, prop_name)
                if prop_details:
                    if self.current_subsystem:
                        prop_details['subsystem'] = self.current_subsystem
                    self.properties_methods['properties'].append(prop_details)
                    logger.debug(f"ð Added property details for {prop_name}: {prop_details} ð")
        super().generic_visit(node)

    def parse_property_details(self, call_node, prop_class_name, prop_name):
        logger.debug(f"ð§ Parsing property details for type: {prop_class_name} ð§")
        details = {'type': prop_class_name, 'name': prop_name}
        
        for kw in call_node.keywords:
            if kw.arg == 'access':
                details['access'] = self.get_ast_node_value(kw.value)
                logger.debug(f"ð Access mode set for {prop_name}: {details['access']} ð")

        if prop_class_name == 'SelectProperty':
            if len(call_node.args) > 1:
                choices_arg = call_node.args[1]
                if isinstance(choices_arg, ast.List):
                    details['choices'] = [self.get_ast_node_value(el) for el in choices_arg.elts]
                    logger.debug(f"ð Choices set for SelectProperty: {details['choices']} ð")

        elif prop_class_name == 'ValueProperty':
            for kw in call_node.keywords:
                if kw.arg in ['type', 'range', 'units', 'doc_str']:
                    details[kw.arg] = self.get_ast_node_value(kw.value)
                    logger.debug(f"ð§ Setting {kw.arg}: {details[kw.arg]} ð§")

        elif prop_class_name in ['SwitchProperty', 'StringProperty', 'DataProperty']:
            logger.debug(f"âï¸ No additional processing needed for {prop_class_name} âï¸")

        else:
            logger.warning(f"ð¨ Unsupported property class: {prop_class_name} ð¨")

        return details

    def get_ast_node_value(self, node):
        if isinstance(node, ast.Constant):
            return node.value
        elif isinstance(node, ast.Name):
            return node.id
        elif isinstance(node, ast.List):
            return [self.get_ast_node_value(el) for el in node.elts]
        elif isinstance(node, ast.UnaryOp):
            operand = self.get_ast_node_value(node.operand)
            if isinstance(node.op, ast.UAdd):
                return +operand
            elif isinstance(node.op, ast.USub):
                return -operand
        else:
            logger.error(f"Unhandled node type: {type(node).__name__}")
            return None
    
if __name__ == "__main__":

    def print_consolidated_view(instrument):
        for instrument_name, instrument_info in instrument.items():
            print(f"{instrument_name}/")

            # Print sources
            print("âââ Sources")
            for source in instrument_info['sources']:
                print(f"â   âââ {source}")

            # Print GUI methods
            print("âââ GUI Methods")
            for method_name, method_info in instrument_info['gui_methods'].items():
                args_str = ', '.join(method_info['args'])
                return_str = f" -> {method_info['return']}" if method_info['return'] else ""
                print(f"â   âââ {method_name}({args_str}){return_str}")

            # Print other methods
            print("âââ Other Methods")
            for method_name, method_info in instrument_info['other_methods'].items():
                args_str = ', '.join(method_info['args'])
                return_str = f" -> {method_info['return']}" if method_info['return'] else ""
                print(f"â   âââ {method_name}({args_str}){return_str}")

            # Print subsystems and their properties
            subsystems = instrument_info['subsystems'].items()
            for subsystem_name, subsystem_info in subsystems:
                if 'instances' in subsystem_info and subsystem_info['instances']:
                    print(f"âââ {subsystem_name}")
                    for instance_name, instance_info in subsystem_info['instances'].items():
                        print(f"â   âââ {instance_name}")
                        print_properties(instance_info['properties'], is_last=False)
                else:
                    print(f"âââ {subsystem_name}")
                    print_properties(subsystem_info['properties'], is_last=False)
            print()  # For a newline after each instrument

    def print_properties(properties, is_last):
        indent = "â   â   " if not is_last else "    "  # Adjust the indentation based on hierarchy
        for prop in properties:
            prop_summary = format_property_summary(prop)
            print(f"{indent}âââ {prop_summary}")

    def format_property_summary(prop):
        """Formats a property summary based on its type and details."""
        prop_type = prop.get('type')
        summary_parts = [f"{prop['name']} ({prop_type})"]
        if 'choices' in prop:
            if isinstance(prop['choices'][0], str):
                choices_str = ", ".join(prop['choices'])
                summary_parts.append(f"[Choices: {choices_str}]")
            else:
                summary_parts.append(f"[Choices: {len(prop['choices'])} items]")
        elif 'range' in prop:
            range_str = f"[Range: {prop['range'][0]} to {prop['range'][1]}]"
            summary_parts.append(range_str)
        if 'units' in prop:
            summary_parts.append(f"[Units: {prop['units']}]")
        if 'access' in prop:
            summary_parts.append(f"[Access: {prop['access']}]")
        return " ".join(summary_parts)
    
    # Load a test driver
    path = 'scpi/drivers/DSOX1204G.py'  
    with open(path, 'r') as file:
        source = file.read()

    tree = ast.parse(source, filename=path)

    # Assuming scpiClassVisitor is your revised visitor class
    visitor = InstrumentVisitor()
    visitor.visit(tree)  # First pass to identify structure

    print_consolidated_view(visitor.instruments)
    #print(visitor.instruments)


================================================================================
*** __init__.py ***
### tests/__init__.py ###
================================================================================




================================================================================
*** conftest.py ***
### tests/conftest.py ###
================================================================================

# tests/conftest.py
import pytest
from PySide6.QtWidgets import QApplication
from pymetr.state import ApplicationState
from pymetr.models.base import BaseModel
from pymetr.views.manager import ViewType  # Add this import
from pymetr.actions.commands import Result

# Base test models that can be used across all tests
@pytest.mark.no_collect
class TestModel(BaseModel):
    """Generic test model for testing"""
    def __init__(self, name: str, model_id: str = None):
        super().__init__(model_id)
        self.set_property('name', name)

@pytest.mark.no_collect
class TestScript(BaseModel):
    """Test script model for testing"""
    def __init__(self, name: str, model_id: str = None):
        super().__init__(model_id)
        self.set_property('name', name)

@pytest.mark.no_collect
class TestResult(BaseModel):
    """Test result model for testing"""
    def __init__(self, name: str, model_id: str = None):
        super().__init__(model_id)
        self.set_property('name', name)

# Fixtures that can be used across all tests
@pytest.fixture(scope="session")
def qapp():
    """Create the Qt Application"""
    return QApplication([])

@pytest.fixture
def state():
    """Create a fresh application state for each test"""
    return ApplicationState()

@pytest.fixture
def test_model(state):
    """Create a test model and register it with the state"""
    model = TestModel("Test Model")
    state.registry.register(model)
    return model

@pytest.fixture
def test_script(state):
    """Create a test script and register it with the state"""
    script = TestScript("Test Script")
    state.registry.register(script)
    return script

@pytest.fixture
def test_result(state):
    """Create a test result and register it with the state"""
    result = TestResult("Test Result")
    state.registry.register(result)
    return result

@pytest.fixture
def success_result():
    """Fixture for successful command result"""
    return Result(success=True)

@pytest.fixture
def failed_result():
    """Fixture for failed command result"""
    return Result(success=False, error="Test error")


================================================================================
*** test_actions.py ***
### tests/test_actions.py ###
================================================================================

# tests/test_actions.py
import pytest
from pymetr.actions.commands import Command, ModelCommand, Result
from pymetr.actions.manager import ActionManager
from .conftest import TestModel
from pymetr.state import ApplicationState

class SetNameCommand(ModelCommand):
    def __init__(self, state: 'ApplicationState', model_id: str, name: str):
        super().__init__(state, model_id)
        self.new_name = name
    
    def execute(self) -> Result:
        self.store_model_state()
        model = self.state.registry.get_model(self.model_id)
        if model:
            model.set_property('name', self.new_name)
            return Result(True)
        return Result(False, error="Model not found")
    
    def undo(self) -> bool:
        return self.restore_model_state()

def test_command_execution(state, test_model):
    action_manager = ActionManager(state)
    action_manager.register_command('set_name', SetNameCommand)
    
    result = action_manager.execute('set_name', model_id=test_model.id, name="Updated")
    
    assert result.success
    assert state.registry.get_model(test_model.id).get_property('name') == "Updated"

def test_command_undo(state, test_model):
    action_manager = ActionManager(state)
    action_manager.register_command('set_name', SetNameCommand)
    
    original_name = test_model.get_property('name')
    action_manager.execute('set_name', model_id=test_model.id, name="Updated")
    
    result = action_manager.undo()
    assert result.success
    assert state.registry.get_model(test_model.id).get_property('name') == original_name


================================================================================
*** test_core.py ***
### tests/test_core.py ###
================================================================================

# tests/test_core.py
import pytest
from pymetr.registry import ModelRegistry
from .conftest import TestModel

def test_model_creation_and_registration(state):
    # Create and register a model
    model = TestModel("Test1")
    state.registry.register(model)
    
    retrieved = state.registry.get_model(model.id)
    assert retrieved is not None
    assert retrieved.get_property('name') == "Test1"

def test_model_relationships(state):
    parent = TestModel("Parent")
    child = TestModel("Child")
    
    state.registry.register(parent)
    state.registry.register(child)
    
    state.registry.link(parent.id, child.id)
    
    children = state.registry.get_children(parent.id)
    assert len(children) == 1
    assert children[0] == child.id

def test_model_type_query(state):
    model1 = TestModel("Test1")
    model2 = TestModel("Test2")
    
    state.registry.register(model1)
    state.registry.register(model2)
    
    test_models = state.registry.get_models_by_type(TestModel)
    assert len(test_models) == 2
    names = {m.get_property('name') for m in test_models}
    assert names == {"Test1", "Test2"}


================================================================================
*** test_main.py ***
### tests/test_main.py ###
================================================================================

# tests/test_main.py
import pytest
from unittest.mock import Mock, patch
from pymetr.__main__ import main

def test_main():
    with patch('pymetr.__main__.create_application') as mock_create:
        with patch('sys.exit') as mock_exit:
            # Create mock app and window
            mock_app = Mock()
            mock_window = Mock()
            mock_create.return_value = (mock_app, mock_window)
            
            main()
            
            # Verify application was created and executed
            mock_create.assert_called_once()
            mock_app.exec.assert_called_once()
            mock_exit.assert_called_once()


================================================================================
*** test_main_window.py ***
### tests/test_main_window.py ###
================================================================================

# tests/test_main_window.py
import pytest
from PySide6.QtWidgets import QDockWidget, QMessageBox
from PySide6.QtCore import Qt
from pymetr.views.windows.main_window import MainWindow
from pymetr.actions.commands import Result  # Add this import

def test_window_creation(state, qapp, qtbot):
    """Test basic window creation and components"""
    window = MainWindow(state)
    qtbot.addWidget(window)
    
    # Verify core components exist
    assert window.tree_view is not None
    assert window.tab_manager is not None
    assert window.ribbon is not None
    
    # Check tree view is properly docked
    docks = window.findChildren(QDockWidget)
    assert len(docks) > 0
    model_dock = next((d for d in docks if d.windowTitle() == "Models"), None)
    assert model_dock is not None
    assert model_dock.widget() == window.tree_view

def test_action_handling_success(state, qapp, qtbot, test_script):
    """Test successful action handling"""
    window = MainWindow(state)
    qtbot.addWidget(window)
    
    # Mock successful action execution
    state.actions.execute = lambda action_id: Result(success=True)
    
    # Trigger action
    with qtbot.wait_signal(window.ribbon.action_triggered):
        window.ribbon.action_triggered.emit("test_action")

def test_action_handling_failure(state, qapp, qtbot, monkeypatch):
    """Test failed action handling shows error message"""
    window = MainWindow(state)
    qtbot.addWidget(window)
    
    # Mock QMessageBox to capture error display
    shown_messages = []
    def mock_warning(parent, title, message):
        shown_messages.append((title, message))
    
    monkeypatch.setattr(QMessageBox, 'warning', mock_warning)
    
    # Mock failed action execution
    state.actions.execute = lambda action_id: Result(success=False, error="Test error")
    
    # Trigger action
    window.ribbon.action_triggered.emit("test_action")
    
    # Verify error was shown
    assert len(shown_messages) == 1
    assert "Action Failed" in shown_messages[0][0]
    assert "Test error" in shown_messages[0][1]

def test_window_layout_constraints(state, qapp, qtbot):
    """Test window layout and size constraints"""
    window = MainWindow(state)
    qtbot.addWidget(window)
    
    # Verify minimum size
    assert window.minimumSize().width() >= 800
    assert window.minimumSize().height() >= 600
    
    # Verify dock widget areas
    model_dock = next(d for d in window.findChildren(QDockWidget) 
                     if d.windowTitle() == "Models")
    assert model_dock.allowedAreas() & Qt.LeftDockWidgetArea
    assert model_dock.allowedAreas() & Qt.RightDockWidgetArea


================================================================================
*** test_ribbon.py ***
### tests/test_ribbon.py ###
================================================================================

# tests/test_ribbon.py
import pytest
from pymetr.views.ribbon.context import (
    RibbonContext, DefaultContext, ScriptContext, PlotContext,
    ActionCategory, RibbonAction
)
from pymetr.views.ribbon.manager import RibbonManager

def test_default_context(state, qapp):
    ribbon_manager = RibbonManager(state)
    context = DefaultContext(state)
    actions = context.get_actions()
    
    assert any(a.id == "new_script" for a in actions)
    assert any(a.category == ActionCategory.FILE for a in actions)

def test_script_context(state, qapp, test_script):
    ribbon_manager = RibbonManager(state)
    
    # Set active model
    state.set_active_model(test_script.id)
    
    assert isinstance(ribbon_manager._current_context, ScriptContext)
    actions = ribbon_manager._current_context.get_actions()
    assert any(a.id == "run_script" for a in actions)
    assert any(a.id == "stop_script" for a in actions)

def test_action_triggering(state, qapp, test_script, qtbot):
    ribbon_manager = RibbonManager(state)
    qtbot.addWidget(ribbon_manager)

    # Track triggered actions
    triggered_actions = []
    ribbon_manager.action_triggered.connect(
        lambda aid: triggered_actions.append(aid)
    )

    # Create a context with known actions
    context = ScriptContext(state)
    ribbon_manager._set_context(context)

    state.set_active_model(test_script.id)

    # Find and trigger the run action
    run_toolbar = ribbon_manager.toolbars[ActionCategory.RUN]
    run_actions = run_toolbar.actions()
    assert len(run_actions) > 0, "No actions found in RUN category"
    
    run_action = run_actions[0]
    run_action.trigger()

    assert len(triggered_actions) == 1
    assert triggered_actions[0] == "run_script"


================================================================================
*** test_state.py ***
### tests/test_state.py ###
================================================================================

# tests/test_state.py
import pytest
from pymetr.state import ApplicationState, SignalManager
from .conftest import TestModel

def test_create_model(state):
    model = state.create_model(TestModel, name="Test1")
    assert model.get_property('name') == "Test1"
    assert state.registry.get_model(model.id) is not None

def test_signal_emission(state):
    received_signals = []
    
    def handler(model_id, model_type):
        received_signals.append((model_id, model_type))
    
    state.signals.connect('model_created', handler)
    model = state.create_model(TestModel, name="Test1")
    
    assert len(received_signals) == 1
    assert received_signals[0][1] == "TestModel"

def test_active_model(state):
    model1 = state.create_model(TestModel, name="Test1")
    model2 = state.create_model(TestModel, name="Test2")
    
    changes = []
    state.signals.connect('active_model_changed', 
                         lambda new_id, old_id: changes.append((new_id, old_id)))
    
    state.set_active_model(model1.id)
    assert state.get_active_model().id == model1.id
    assert len(changes) == 1
    
    state.set_active_model(model2.id)
    assert state.get_active_model().id == model2.id
    assert len(changes) == 2


================================================================================
*** test_tab_manager.py ***
### tests/test_tab_manager.py ###
================================================================================

# tests/test_tab_manager.py
import pytest
from PySide6.QtWidgets import QWidget
from pymetr.views.widgets.tab_manager import TabManager
from pymetr.views.manager import ViewType

# Mock view classes for testing
class MockScriptView(QWidget):
    def __init__(self, state, model_id, parent=None):
        super().__init__(parent)
        self.state = state
        self.model_id = model_id

class MockResultView(QWidget):
    def __init__(self, state, model_id, parent=None):
        super().__init__(parent)
        self.state = state
        self.model_id = model_id

def test_tab_creation(state, qapp, test_script):
    tab_manager = TabManager(state)
    # Override view creation for testing
    tab_manager._create_view = lambda model_id, view_type: (
        MockScriptView(state, model_id) if view_type == ViewType.SCRIPT
        else MockResultView(state, model_id)
    )
    
    # Simulate active model change
    state.set_active_model(test_script.id)
    
    assert test_script.id in tab_manager._tabs
    assert isinstance(tab_manager._tabs[test_script.id], MockScriptView)
    assert tab_manager.currentWidget() == tab_manager._tabs[test_script.id]

def test_tab_switching(state, qapp, test_script, test_result):
    tab_manager = TabManager(state)
    tab_manager._create_view = lambda model_id, view_type: (
        MockScriptView(state, model_id) if view_type == ViewType.SCRIPT
        else MockResultView(state, model_id) if view_type == ViewType.RESULT
        else None
    )
    
    # Activate first model
    state.set_active_model(test_script.id)
    first_tab = tab_manager.currentWidget()
    
    # Activate second model
    state.set_active_model(test_result.id)
    second_tab = tab_manager.currentWidget()
    
    assert first_tab != second_tab
    assert isinstance(first_tab, MockScriptView)
    assert isinstance(second_tab, MockResultView)


================================================================================
*** test_tree_view.py ***
### tests/test_tree_view.py ###
================================================================================

# tests/test_tree_view.py
import pytest
from pymetr.views.widgets.tree_view import ModelTreeView
from .conftest import TestScript, TestResult

def test_model_creation(state, qapp, test_script):
    tree_view = ModelTreeView(state)
    
    # Emit model created signal
    state.signals.emit('model_created', test_script.id, type(test_script).__name__)
    
    # Verify tree node created
    assert test_script.id in tree_view._item_map
    item = tree_view._item_map[test_script.id]
    assert 'ð' in item.text(0)  # Script icon
    assert "Test Script" in item.text(0)

def test_model_hierarchy(state, qapp, test_script, test_result):
    tree_view = ModelTreeView(state)
    
    # Emit creation signals
    state.signals.emit('model_created', test_script.id, type(test_script).__name__)
    state.signals.emit('model_created', test_result.id, type(test_result).__name__)
    
    # Link models
    state.signals.emit('models_linked', test_script.id, test_result.id)
    
    # Verify hierarchy
    script_item = tree_view._item_map[test_script.id]
    result_item = tree_view._item_map[test_result.id]
    assert result_item.parent() == script_item

def test_selection_signal(state, qapp, test_script, qtbot):
    tree_view = ModelTreeView(state)
    state.signals.emit('model_created', test_script.id, type(test_script).__name__)
    
    # Track selection signal
    with qtbot.wait_signal(tree_view.selection_changed) as blocker:
        item = tree_view._item_map[test_script.id]
        item.setSelected(True)
    
    assert blocker.args == [test_script.id]

def test_selection_triggers_tab_and_context(state, qapp, test_script, qtbot):
    """Test that selecting an item updates tabs and context"""
    tree_view = ModelTreeView(state)
    qtbot.addWidget(tree_view)
    
    # Track selection signal
    selection_signals = []
    tree_view.selection_changed.connect(lambda mid: selection_signals.append(mid))
    
    # Create and select item
    state.signals.emit('model_created', test_script.id, type(test_script).__name__)
    
    # Get the created item and select it
    item = tree_view._item_map[test_script.id]
    tree_view.setCurrentItem(item)
    
    # Verify selection was handled
    assert len(selection_signals) > 0
    assert selection_signals[-1] == test_script.id
    assert state.get_active_model().id == test_script.id


================================================================================
*** test_views.py ***
### tests/test_views.py ###
================================================================================

# tests/test_views.py
import pytest
from pymetr.views.manager import ViewManager, ViewType, ViewState

def test_view_registration(state, test_script):  # Added test_script fixture
    view_manager = ViewManager(state)
    
    # Register view for test model
    view_state = view_manager.register_view(
        'view1',
        ViewType.SCRIPT,
        test_script.id
    )
    
    assert view_state.view_type == ViewType.SCRIPT
    assert view_state.model_id == test_script.id
    assert not view_state.is_dirty
    assert test_script.id in view_manager._model_views

def test_active_view(state, test_script, test_result):  # Using both fixtures
    view_manager = ViewManager(state)
    
    # Register two views
    view_manager.register_view('view1', ViewType.SCRIPT, test_script.id)
    view_manager.register_view('view2', ViewType.RESULT, test_result.id)
    
    # Set active view
    view_manager.set_active_view('view1')
    
    # Verify active states
    assert view_manager._active_view == 'view1'
    assert view_manager._views['view1'].is_active
    assert not view_manager._views['view2'].is_active
    
    # Verify active model in state
    assert state.get_active_model().id == test_script.id

def test_model_change_propagation(state, test_script):  # Added test_script fixture
    view_manager = ViewManager(state)
    view_manager.register_view('view1', ViewType.SCRIPT, test_script.id)
    
    # Update model
    test_script.set_property('name', "Updated")
    state.notify_model_changed(test_script.id, 'name', "Updated")
    
    # Verify view is marked dirty
    view_state = view_manager.get_view_state('view1')
    assert view_state.is_dirty

def test_model_deletion(state, test_script):  # Added test_script fixture
    view_manager = ViewManager(state)
    
    # Register two views for same model
    view_manager.register_view('view1', ViewType.SCRIPT, test_script.id)
    view_manager.register_view('view2', ViewType.SCRIPT, test_script.id)
    
    # Delete model
    state.delete_model(test_script.id)
    
    # Verify views are cleaned up
    assert test_script.id not in view_manager._model_views
    assert 'view1' not in view_manager._views
    assert 'view2' not in view_manager._views

def test_view_properties(state, test_script):  # Added test_script fixture
    view_manager = ViewManager(state)
    view_manager.register_view('view1', ViewType.SCRIPT, test_script.id)
    
    # Set view property
    view_manager.set_view_property('view1', 'cursor_position', 100)
    
    # Verify property
    view_state = view_manager.get_view_state('view1')
    assert view_state.properties['cursor_position'] == 100


================================================================================
# End of Project Source Code Collection
